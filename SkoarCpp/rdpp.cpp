// =====================================================================================================================
// rdpp.cpp - Generated by Code_Parser_Cpp - Create Recursive Descent Predictive Parser on 2015-08-01 00:03:39 for C++14
// =====================================================================================================================
#include "rdpp.hpp"
#include "exception.hpp"
#include "lex.hpp"
#include "noad.hpp"

void SkoarParser::fail() {
    toker->dump();
    throw new SkoarParseException("Fail");;
}

void SkoarParser::fail_too_deep() {
    toker->dump();
    throw new SkoarParseException("Parse tree too deep!");;
}

 SkoarParser::SkoarParser(SkoarToker * toker) {

    this->deep = 0;
    this->toker = toker;
    this->init_desirables();
    
}

void SkoarParser::init_desirables() {

    // listy
    desirables["listy -> ListS listy_suffix"] = {Toke_ListS::instance()};

    // cthulhu
    desirables["cthulhu -> LWing Semicolon cthulhu_prime"] = {Toke_LWing::instance()};

    // loop_condition
    desirables["loop_condition -> LoopSep boolean"] = {Toke_LoopSep::instance()};

    // ottavas
    desirables["ottavas -> OctaveShift"] = {Toke_OctaveShift::instance()};
    desirables["ottavas -> OttavaA"] = {Toke_OttavaA::instance()};
    desirables["ottavas -> OttavaB"] = {Toke_OttavaB::instance()};
    desirables["ottavas -> QuindicesimaA"] = {Toke_QuindicesimaA::instance()};
    desirables["ottavas -> QuindicesimaB"] = {Toke_QuindicesimaB::instance()};
    desirables["ottavas -> Loco"] = {Toke_Loco::instance()};

    // pedally
    desirables["pedally -> PedalDown"] = {Toke_PedalDown::instance()};
    desirables["pedally -> PedalUp"] = {Toke_PedalUp::instance()};

    // deref_prime
    desirables["deref_prime -> MsgNameWithArgs listy_suffix"] = {Toke_MsgNameWithArgs::instance()};
    desirables["deref_prime -> MsgName"] = {Toke_MsgName::instance()};

    // dynamic
    desirables["dynamic -> DynPiano"] = {Toke_DynPiano::instance()};
    desirables["dynamic -> DynForte"] = {Toke_DynForte::instance()};
    desirables["dynamic -> DynSFZ"] = {Toke_DynSFZ::instance()};
    desirables["dynamic -> DynFP"] = {Toke_DynFP::instance()};

    // args_entries
    desirables["args_entries -> SymbolName moar_args_entries"] = {Toke_SymbolName::instance()};

    // assignment
    desirables["assignment -> AssOp settable"] = {Toke_AssOp::instance()};

    // msgable
    desirables["msgable -> nouny msg_chain_node"] = {Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Freq::instance(), Toke_DynSFZ::instance(), Toke_PedalUp::instance(),
               Toke_QuindicesimaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Caesura::instance(),
               Toke_Float::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(),
               Toke_Symbol::instance(), Toke_Deref::instance(), Toke_CondS::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_NamedNoat::instance(),
               Toke_Portamento::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(), Toke_Fairy::instance(),
               Toke_Tuplet::instance()};

    // branch
    desirables["branch -> optional_voice phrases Newline"] = {Toke_Tuplet::instance(), Toke_Fairy::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Comment::instance(),
               Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(), Toke_Deref::instance(),
               Toke_Symbol::instance(), Toke_Coda::instance(), Toke_DynForte::instance(), Toke_LoopS::instance(), Toke_PedalDown::instance(),
               Toke_DynPiano::instance(), Toke_Int::instance(), Toke_DynFP::instance(), Toke_Portamento::instance(), Toke_Bars::instance(),
               Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(), Toke_OttavaB::instance(),
               Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Newline::instance(), Toke_Eighths::instance(), Toke_Float::instance(),
               Toke_Caesura::instance(), Toke_LWing::instance(), Toke_Voice::instance(), Toke_SkoarpionStart::instance(), Toke_DaCapo::instance(),
               Toke_Meter::instance(), Toke_Slash::instance(), Toke_Fine::instance(), Toke_CondS::instance(), Toke_Volta::instance(),
               Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_Segno::instance(), Toke_ListS::instance(),
               Toke_DynSFZ::instance(), Toke_Freq::instance()};

    // listy_entries
    desirables["listy_entries -> expr moar_listy_entries"] = {Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(),
               Toke_QuindicesimaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Caesura::instance(),
               Toke_Float::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(),
               Toke_Symbol::instance(), Toke_Deref::instance(), Toke_CondS::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_NamedNoat::instance(),
               Toke_Portamento::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(),
               Toke_Fairy::instance()};

    // skrp_moar_lines
    desirables["skrp_moar_lines -> skrp_sep_or_nl skrp_lines"] = {Toke_Newline::instance(), Toke_SkoarpionSep::instance()};

    // phrasey
    desirables["phrasey -> Comment"] = {Toke_Comment::instance()};
    desirables["phrasey -> marker"] = {Toke_Fine::instance(), Toke_Coda::instance(), Toke_Bars::instance(), Toke_Volta::instance(), Toke_Segno::instance()};
    desirables["phrasey -> Meter"] = {Toke_Meter::instance()};
    desirables["phrasey -> expr"] = {Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(),
               Toke_QuindicesimaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Caesura::instance(),
               Toke_Float::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(),
               Toke_Symbol::instance(), Toke_Deref::instance(), Toke_CondS::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_NamedNoat::instance(),
               Toke_Portamento::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(),
               Toke_Fairy::instance()};
    desirables["phrasey -> dal_goto"] = {Toke_DaCapo::instance(), Toke_DalSegno::instance()};
    desirables["phrasey -> beat"] = {Toke_Quavers::instance(), Toke_Eighths::instance(), Toke_Slash::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance()};

    // deref
    desirables["deref -> Deref deref_prime"] = {Toke_Deref::instance()};

    // moar_listy_entries
    desirables["moar_listy_entries -> ListSep listy_entries"] = {Toke_ListSep::instance()};
    desirables["moar_listy_entries -> Newline"] = {Toke_Newline::instance()};

    // beat
    desirables["beat -> Crotchets"] = {Toke_Crotchets::instance()};
    desirables["beat -> Quavers"] = {Toke_Quavers::instance()};
    desirables["beat -> Quarters"] = {Toke_Quarters::instance()};
    desirables["beat -> Eighths"] = {Toke_Eighths::instance()};
    desirables["beat -> Slash"] = {Toke_Slash::instance()};

    // args
    desirables["args -> ListS args_suffix"] = {Toke_ListS::instance()};

    // cond_ifs_suffix
    desirables["cond_ifs_suffix -> Newline cond_ifs"] = {Toke_Newline::instance()};

    // loop
    desirables["loop -> LoopS loop_body loop_condition LoopE"] = {Toke_LoopS::instance()};

    // coda
    desirables["coda -> Coda optional_al_coda"] = {Toke_Coda::instance()};

    // expr
    desirables["expr -> msgable expr_prime"] = {Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(),
               Toke_QuindicesimaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Caesura::instance(),
               Toke_Float::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(),
               Toke_Symbol::instance(), Toke_Deref::instance(), Toke_CondS::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_NamedNoat::instance(),
               Toke_Portamento::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(),
               Toke_Fairy::instance()};

    // al_x
    desirables["al_x -> AlCoda"] = {Toke_AlCoda::instance()};
    desirables["al_x -> AlSegno"] = {Toke_AlSegno::instance()};
    desirables["al_x -> AlFine"] = {Toke_AlFine::instance()};

    // optional_voice
    desirables["optional_voice -> Voice"] = {Toke_Voice::instance()};

    // marker
    desirables["marker -> Segno"] = {Toke_Segno::instance()};
    desirables["marker -> Fine"] = {Toke_Fine::instance()};
    desirables["marker -> coda"] = {Toke_Coda::instance()};
    desirables["marker -> Volta"] = {Toke_Volta::instance()};
    desirables["marker -> Bars"] = {Toke_Bars::instance()};

    // skrp_sig
    desirables["skrp_sig -> args"] = {Toke_ListS::instance()};
    desirables["skrp_sig -> SymbolName optional_args"] = {Toke_SymbolName::instance()};

    // listy_suffix
    desirables["listy_suffix -> listy_entries ListE"] = {Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(),
               Toke_QuindicesimaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Caesura::instance(),
               Toke_Float::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(),
               Toke_Symbol::instance(), Toke_Deref::instance(), Toke_CondS::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_NamedNoat::instance(),
               Toke_Portamento::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(),
               Toke_Fairy::instance()};
    desirables["listy_suffix -> ListE"] = {Toke_ListE::instance()};

    // math
    desirables["math -> MathOp msgable"] = {Toke_MathOp::instance()};

    // cond_ifs
    desirables["cond_ifs -> cond_if cond_ifs_suffix"] = {Toke_Freq::instance(), Toke_Fairy::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Rep::instance(),
               Toke_Carrot::instance(), Toke_Symbol::instance(), Toke_Deref::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_Portamento::instance(),
               Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(),
               Toke_Caesura::instance(), Toke_Float::instance(), Toke_LWing::instance(), Toke_Voice::instance(), Toke_SkoarpionStart::instance(),
               Toke_CondS::instance(), Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(),
               Toke_DynSFZ::instance(), Toke_Tuplet::instance()};

    // skoarpion
    desirables["skoarpion -> SkoarpionStart skrp_sig SkoarpionSep skrp_suffix"] = {Toke_SkoarpionStart::instance()};

    // cthulhu_prime
    desirables["cthulhu_prime -> boolean Semicolon RWing"] = {Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(),
               Toke_QuindicesimaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Caesura::instance(),
               Toke_Float::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(),
               Toke_Symbol::instance(), Toke_Deref::instance(), Toke_CondS::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_NamedNoat::instance(),
               Toke_Portamento::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(),
               Toke_Fairy::instance()};
    desirables["cthulhu_prime -> Nosey Semicolon RWing"] = {Toke_Nosey::instance()};

    // skrp_suffix
    desirables["skrp_suffix -> skrp_lines SkoarpionEnd"] = {Toke_Tuplet::instance(), Toke_DynSFZ::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Comment::instance(),
               Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(), Toke_Deref::instance(),
               Toke_Symbol::instance(), Toke_SkoarpionEnd::instance(), Toke_Coda::instance(), Toke_DynForte::instance(), Toke_LoopS::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_Int::instance(), Toke_DynFP::instance(), Toke_Portamento::instance(),
               Toke_Bars::instance(), Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(),
               Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Newline::instance(), Toke_Eighths::instance(),
               Toke_Float::instance(), Toke_Caesura::instance(), Toke_SkoarpionSep::instance(), Toke_LWing::instance(), Toke_Voice::instance(),
               Toke_SkoarpionStart::instance(), Toke_DaCapo::instance(), Toke_Meter::instance(), Toke_Slash::instance(), Toke_Fine::instance(),
               Toke_CondS::instance(), Toke_Volta::instance(), Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(),
               Toke_Segno::instance(), Toke_ListS::instance(), Toke_Fairy::instance(), Toke_Freq::instance()};

    // branches
    desirables["branches -> branch branches"] = {Toke_Fairy::instance(), Toke_Tuplet::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Comment::instance(),
               Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(), Toke_Deref::instance(),
               Toke_Symbol::instance(), Toke_Coda::instance(), Toke_DynForte::instance(), Toke_LoopS::instance(), Toke_PedalDown::instance(),
               Toke_DynPiano::instance(), Toke_Int::instance(), Toke_DynFP::instance(), Toke_Portamento::instance(), Toke_Bars::instance(),
               Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(), Toke_OttavaB::instance(),
               Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Newline::instance(), Toke_Eighths::instance(), Toke_Float::instance(),
               Toke_Caesura::instance(), Toke_LWing::instance(), Toke_Voice::instance(), Toke_SkoarpionStart::instance(), Toke_DaCapo::instance(),
               Toke_Meter::instance(), Toke_Slash::instance(), Toke_Fine::instance(), Toke_CondS::instance(), Toke_Volta::instance(),
               Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_Segno::instance(), Toke_ListS::instance(),
               Toke_DynSFZ::instance(), Toke_Freq::instance()};

    // dal_goto
    desirables["dal_goto -> DaCapo al_x"] = {Toke_DaCapo::instance()};
    desirables["dal_goto -> DalSegno al_x"] = {Toke_DalSegno::instance()};

    // musical_keyword_misc
    desirables["musical_keyword_misc -> Rep"] = {Toke_Rep::instance()};
    desirables["musical_keyword_misc -> Portamento"] = {Toke_Portamento::instance()};
    desirables["musical_keyword_misc -> Carrot"] = {Toke_Carrot::instance()};

    // skoar
    desirables["skoar -> branches"] = {Toke_Fairy::instance(), Toke_Tuplet::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Comment::instance(),
               Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(), Toke_Deref::instance(),
               Toke_Symbol::instance(), Toke_Coda::instance(), Toke_DynForte::instance(), Toke_LoopS::instance(), Toke_PedalDown::instance(),
               Toke_DynPiano::instance(), Toke_Int::instance(), Toke_DynFP::instance(), Toke_Portamento::instance(), Toke_EOF::instance(),
               Toke_Bars::instance(), Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(),
               Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Newline::instance(), Toke_Eighths::instance(),
               Toke_Float::instance(), Toke_Caesura::instance(), Toke_LWing::instance(), Toke_Voice::instance(), Toke_SkoarpionStart::instance(),
               Toke_DaCapo::instance(), Toke_Meter::instance(), Toke_Slash::instance(), Toke_Fine::instance(), Toke_CondS::instance(),
               Toke_Volta::instance(), Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_Segno::instance(),
               Toke_ListS::instance(), Toke_DynSFZ::instance(), Toke_Freq::instance()};

    // cond_if
    desirables["cond_if -> optional_voice boolean CondIf if_body cond_else"] = {Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Rep::instance(),
               Toke_Carrot::instance(), Toke_Symbol::instance(), Toke_Deref::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_Portamento::instance(),
               Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(),
               Toke_Caesura::instance(), Toke_Float::instance(), Toke_LWing::instance(), Toke_Voice::instance(), Toke_SkoarpionStart::instance(),
               Toke_CondS::instance(), Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(),
               Toke_DynSFZ::instance(), Toke_Fairy::instance()};

    // optional_args
    desirables["optional_args -> args"] = {Toke_ListS::instance()};

    // if_body
    desirables["if_body -> phrases"] = {Toke_Tuplet::instance(), Toke_Fairy::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Comment::instance(),
               Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(), Toke_Deref::instance(),
               Toke_Symbol::instance(), Toke_Coda::instance(), Toke_DynForte::instance(), Toke_LoopS::instance(), Toke_PedalDown::instance(),
               Toke_DynPiano::instance(), Toke_Int::instance(), Toke_DynFP::instance(), Toke_Portamento::instance(), Toke_Bars::instance(),
               Toke_CondIf::instance(), Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(),
               Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Newline::instance(), Toke_Eighths::instance(),
               Toke_Float::instance(), Toke_Caesura::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(), Toke_DaCapo::instance(),
               Toke_Meter::instance(), Toke_Slash::instance(), Toke_Fine::instance(), Toke_CondS::instance(), Toke_Volta::instance(),
               Toke_NamedNoat::instance(), Toke_String::instance(), Toke_CondE::instance(), Toke_OttavaA::instance(), Toke_Segno::instance(),
               Toke_ListS::instance(), Toke_DynSFZ::instance(), Toke_Freq::instance()};

    // settable
    desirables["settable -> Caesura"] = {Toke_Caesura::instance()};
    desirables["settable -> Symbol"] = {Toke_Symbol::instance()};
    desirables["settable -> listy"] = {Toke_ListS::instance()};
    desirables["settable -> Quarters"] = {Toke_Quarters::instance()};
    desirables["settable -> Eighths"] = {Toke_Eighths::instance()};
    desirables["settable -> Fairy"] = {Toke_Fairy::instance()};

    // phrases
    desirables["phrases -> phrasey phrases"] = {Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Comment::instance(),
               Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(), Toke_Deref::instance(),
               Toke_Symbol::instance(), Toke_Coda::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(), Toke_PedalDown::instance(),
               Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_Portamento::instance(), Toke_Bars::instance(),
               Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(), Toke_OttavaB::instance(),
               Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Eighths::instance(), Toke_Caesura::instance(), Toke_Float::instance(),
               Toke_LWing::instance(), Toke_SkoarpionStart::instance(), Toke_DaCapo::instance(), Toke_Meter::instance(), Toke_Slash::instance(),
               Toke_Fine::instance(), Toke_CondS::instance(), Toke_Volta::instance(), Toke_NamedNoat::instance(), Toke_String::instance(),
               Toke_OttavaA::instance(), Toke_Segno::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(), Toke_Fairy::instance()};

    // musical_keyword
    desirables["musical_keyword -> dynamic"] = {Toke_DynFP::instance(), Toke_DynForte::instance(), Toke_DynSFZ::instance(), Toke_DynPiano::instance()};
    desirables["musical_keyword -> ottavas"] = {Toke_QuindicesimaB::instance(), Toke_Loco::instance(), Toke_OttavaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(),
               Toke_QuindicesimaA::instance()};
    desirables["musical_keyword -> pedally"] = {Toke_PedalUp::instance(), Toke_PedalDown::instance()};
    desirables["musical_keyword -> musical_keyword_misc"] = {Toke_Portamento::instance(), Toke_Rep::instance(), Toke_Carrot::instance()};

    // args_suffix
    desirables["args_suffix -> args_entries ListE"] = {Toke_SymbolName::instance()};

    // msg
    desirables["msg -> MsgNameWithArgs listy_suffix"] = {Toke_MsgNameWithArgs::instance()};
    desirables["msg -> MsgName"] = {Toke_MsgName::instance()};
    desirables["msg -> listy"] = {Toke_ListS::instance()};
    desirables["msg -> loop"] = {Toke_LoopS::instance()};

    // nouny
    desirables["nouny -> cthulhu"] = {Toke_LWing::instance()};
    desirables["nouny -> conditional"] = {Toke_CondS::instance()};
    desirables["nouny -> loop"] = {Toke_LoopS::instance()};
    desirables["nouny -> nouny_literal"] = {Toke_Freq::instance(), Toke_Symbol::instance(), Toke_NamedNoat::instance(), Toke_Int::instance(), Toke_Choard::instance(),
               Toke_String::instance(), Toke_Caesura::instance(), Toke_Float::instance(), Toke_Fairy::instance(), Toke_Tuplet::instance()};
    desirables["nouny -> musical_keyword"] = {Toke_QuindicesimaB::instance(), Toke_PedalUp::instance(), Toke_DynForte::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(),
               Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_QuindicesimaA::instance(), Toke_PedalDown::instance(), Toke_Portamento::instance(),
               Toke_OttavaA::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_DynSFZ::instance(), Toke_Loco::instance()};
    desirables["nouny -> listy"] = {Toke_ListS::instance()};
    desirables["nouny -> deref"] = {Toke_Deref::instance()};
    desirables["nouny -> skoarpion"] = {Toke_SkoarpionStart::instance()};

    // expr_prime
    desirables["expr_prime -> assignment expr_prime"] = {Toke_AssOp::instance()};
    desirables["expr_prime -> math expr_prime"] = {Toke_MathOp::instance()};

    // cond_else
    desirables["cond_else -> CondIf if_body"] = {Toke_CondIf::instance()};

    // loop_body
    desirables["loop_body -> phrases"] = {Toke_Tuplet::instance(), Toke_Fairy::instance(), Toke_LoopE::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(),
               Toke_Comment::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(),
               Toke_Deref::instance(), Toke_Symbol::instance(), Toke_Coda::instance(), Toke_DynForte::instance(), Toke_LoopS::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_Int::instance(), Toke_DynFP::instance(), Toke_Portamento::instance(),
               Toke_Bars::instance(), Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(),
               Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Eighths::instance(), Toke_Float::instance(),
               Toke_Caesura::instance(), Toke_LoopSep::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(), Toke_DaCapo::instance(),
               Toke_Meter::instance(), Toke_Slash::instance(), Toke_Fine::instance(), Toke_CondS::instance(), Toke_Volta::instance(),
               Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_Segno::instance(), Toke_ListS::instance(),
               Toke_DynSFZ::instance(), Toke_Freq::instance()};

    // moar_args_entries
    desirables["moar_args_entries -> ListSep args_entries"] = {Toke_ListSep::instance()};

    // boolean
    desirables["boolean -> expr BooleanOp expr"] = {Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Tuplet::instance(), Toke_Freq::instance(), Toke_PedalUp::instance(),
               Toke_QuindicesimaA::instance(), Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Caesura::instance(),
               Toke_Float::instance(), Toke_Rep::instance(), Toke_Carrot::instance(), Toke_LWing::instance(), Toke_SkoarpionStart::instance(),
               Toke_Symbol::instance(), Toke_Deref::instance(), Toke_CondS::instance(), Toke_LoopS::instance(), Toke_DynForte::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_DynFP::instance(), Toke_Int::instance(), Toke_NamedNoat::instance(),
               Toke_Portamento::instance(), Toke_String::instance(), Toke_OttavaA::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(),
               Toke_Fairy::instance()};

    // skrp_sep_or_nl
    desirables["skrp_sep_or_nl -> Newline"] = {Toke_Newline::instance()};
    desirables["skrp_sep_or_nl -> SkoarpionSep"] = {Toke_SkoarpionSep::instance()};

    // msg_chain_node
    desirables["msg_chain_node -> MsgOp msg msg_chain_node"] = {Toke_MsgOp::instance()};

    // conditional
    desirables["conditional -> CondS cond_ifs CondE"] = {Toke_CondS::instance()};

    // nouny_literal
    desirables["nouny_literal -> Tuplet"] = {Toke_Tuplet::instance()};
    desirables["nouny_literal -> Caesura"] = {Toke_Caesura::instance()};
    desirables["nouny_literal -> Freq"] = {Toke_Freq::instance()};
    desirables["nouny_literal -> Int"] = {Toke_Int::instance()};
    desirables["nouny_literal -> Float"] = {Toke_Float::instance()};
    desirables["nouny_literal -> String"] = {Toke_String::instance()};
    desirables["nouny_literal -> Choard"] = {Toke_Choard::instance()};
    desirables["nouny_literal -> NamedNoat"] = {Toke_NamedNoat::instance()};
    desirables["nouny_literal -> Symbol"] = {Toke_Symbol::instance()};
    desirables["nouny_literal -> Fairy"] = {Toke_Fairy::instance()};

    // skrp_lines
    desirables["skrp_lines -> optional_voice phrases skrp_moar_lines"] = {Toke_Tuplet::instance(), Toke_Fairy::instance(), Toke_PedalUp::instance(), Toke_QuindicesimaA::instance(), Toke_Comment::instance(),
               Toke_Rep::instance(), Toke_Carrot::instance(), Toke_Quavers::instance(), Toke_DalSegno::instance(), Toke_Deref::instance(),
               Toke_Symbol::instance(), Toke_SkoarpionEnd::instance(), Toke_Coda::instance(), Toke_DynForte::instance(), Toke_LoopS::instance(),
               Toke_PedalDown::instance(), Toke_DynPiano::instance(), Toke_Int::instance(), Toke_DynFP::instance(), Toke_Portamento::instance(),
               Toke_Bars::instance(), Toke_Loco::instance(), Toke_QuindicesimaB::instance(), Toke_Crotchets::instance(), Toke_Quarters::instance(),
               Toke_OttavaB::instance(), Toke_OctaveShift::instance(), Toke_Choard::instance(), Toke_Newline::instance(), Toke_Eighths::instance(),
               Toke_Float::instance(), Toke_Caesura::instance(), Toke_SkoarpionSep::instance(), Toke_LWing::instance(), Toke_Voice::instance(),
               Toke_SkoarpionStart::instance(), Toke_DaCapo::instance(), Toke_Meter::instance(), Toke_Slash::instance(), Toke_Fine::instance(),
               Toke_CondS::instance(), Toke_Volta::instance(), Toke_NamedNoat::instance(), Toke_String::instance(), Toke_OttavaA::instance(),
               Toke_Segno::instance(), Toke_ListS::instance(), Toke_DynSFZ::instance(), Toke_Freq::instance()};

    // optional_al_coda
    desirables["optional_al_coda -> AlCoda"] = {Toke_AlCoda::instance()};
}

SkoarNoad* SkoarParser::listy(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("listy"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["listy -> ListS listy_suffix"];
    // listy -> ListS listy_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_ListS", toker->burn(Toke_ListS::instance()));
        this->listy_suffix(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cthulhu(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("cthulhu"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["cthulhu -> LWing Semicolon cthulhu_prime"];
    // cthulhu -> LWing Semicolon cthulhu_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_LWing", toker->burn(Toke_LWing::instance()));
        noad->add_toke("Toke_Semicolon", toker->burn(Toke_Semicolon::instance()));
        this->cthulhu_prime(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::loop_condition(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("loop_condition"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["loop_condition -> LoopSep boolean"];
    // loop_condition -> LoopSep boolean
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_LoopSep", toker->burn(Toke_LoopSep::instance()));
        noad->add_noad(this->boolean(noad));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::ottavas(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("ottavas"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["ottavas -> OctaveShift"];
    // ottavas -> OctaveShift
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_OctaveShift", toker->burn(Toke_OctaveShift::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["ottavas -> OttavaA"];
    // ottavas -> OttavaA
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_OttavaA", toker->burn(Toke_OttavaA::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["ottavas -> OttavaB"];
    // ottavas -> OttavaB
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_OttavaB", toker->burn(Toke_OttavaB::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["ottavas -> QuindicesimaA"];
    // ottavas -> QuindicesimaA
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_QuindicesimaA", toker->burn(Toke_QuindicesimaA::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["ottavas -> QuindicesimaB"];
    // ottavas -> QuindicesimaB
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_QuindicesimaB", toker->burn(Toke_QuindicesimaB::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["ottavas -> Loco"];
    // ottavas -> Loco
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Loco", toker->burn(Toke_Loco::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::pedally(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("pedally"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["pedally -> PedalDown"];
    // pedally -> PedalDown
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_PedalDown", toker->burn(Toke_PedalDown::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["pedally -> PedalUp"];
    // pedally -> PedalUp
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_PedalUp", toker->burn(Toke_PedalUp::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::deref_prime(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["deref_prime -> MsgNameWithArgs listy_suffix"];
    // deref_prime -> MsgNameWithArgs listy_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_MsgNameWithArgs", toker->burn(Toke_MsgNameWithArgs::instance()));
        this->listy_suffix(noad);
        --deep;;
        return noad;
    }

    desires = &desirables["deref_prime -> MsgName"];
    // deref_prime -> MsgName
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_MsgName", toker->burn(Toke_MsgName::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::dynamic(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("dynamic"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["dynamic -> DynPiano"];
    // dynamic -> DynPiano
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_DynPiano", toker->burn(Toke_DynPiano::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["dynamic -> DynForte"];
    // dynamic -> DynForte
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_DynForte", toker->burn(Toke_DynForte::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["dynamic -> DynSFZ"];
    // dynamic -> DynSFZ
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_DynSFZ", toker->burn(Toke_DynSFZ::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["dynamic -> DynFP"];
    // dynamic -> DynFP
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_DynFP", toker->burn(Toke_DynFP::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::args_entries(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["args_entries -> SymbolName moar_args_entries"];
    // args_entries -> SymbolName moar_args_entries
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_SymbolName", toker->burn(Toke_SymbolName::instance()));
        this->moar_args_entries(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::assignment(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("assignment"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["assignment -> AssOp settable"];
    // assignment -> AssOp settable
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_AssOp", toker->burn(Toke_AssOp::instance()));
        this->settable(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::msgable(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("msgable"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["msgable -> nouny msg_chain_node"];
    // msgable -> nouny msg_chain_node
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->nouny(noad));
        this->msg_chain_node(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::branch(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("branch"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["branch -> optional_voice phrases Newline"];
    // branch -> optional_voice phrases Newline
    if (toker->sees(desires) != nullptr) {
        this->optional_voice(noad);
        this->phrases(noad);
        noad->add_toke("Toke_Newline", toker->burn(Toke_Newline::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::listy_entries(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["listy_entries -> expr moar_listy_entries"];
    // listy_entries -> expr moar_listy_entries
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->expr(noad));
        this->moar_listy_entries(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_moar_lines(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["skrp_moar_lines -> skrp_sep_or_nl skrp_lines"];
    // skrp_moar_lines -> skrp_sep_or_nl skrp_lines
    if (toker->sees(desires) != nullptr) {
        this->skrp_sep_or_nl(noad);
        this->skrp_lines(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::phrasey(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["phrasey -> Comment"];
    // phrasey -> Comment
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Comment", toker->burn(Toke_Comment::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["phrasey -> marker"];
    // phrasey -> marker
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->marker(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["phrasey -> Meter"];
    // phrasey -> Meter
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Meter", toker->burn(Toke_Meter::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["phrasey -> expr"];
    // phrasey -> expr
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->expr(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["phrasey -> dal_goto"];
    // phrasey -> dal_goto
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->dal_goto(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["phrasey -> beat"];
    // phrasey -> beat
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->beat(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::deref(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("deref"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["deref -> Deref deref_prime"];
    // deref -> Deref deref_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Deref", toker->burn(Toke_Deref::instance()));
        this->deref_prime(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::moar_listy_entries(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["moar_listy_entries -> ListSep listy_entries"];
    // moar_listy_entries -> ListSep listy_entries
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_ListSep", toker->burn(Toke_ListSep::instance()));
        this->listy_entries(noad);
        --deep;;
        return noad;
    }

    desires = &desirables["moar_listy_entries -> Newline"];
    // moar_listy_entries -> Newline
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Newline", toker->burn(Toke_Newline::instance()));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::beat(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("beat"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["beat -> Crotchets"];
    // beat -> Crotchets
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Crotchets", toker->burn(Toke_Crotchets::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["beat -> Quavers"];
    // beat -> Quavers
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Quavers", toker->burn(Toke_Quavers::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["beat -> Quarters"];
    // beat -> Quarters
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Quarters", toker->burn(Toke_Quarters::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["beat -> Eighths"];
    // beat -> Eighths
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Eighths", toker->burn(Toke_Eighths::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["beat -> Slash"];
    // beat -> Slash
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Slash", toker->burn(Toke_Slash::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::args(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("args"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["args -> ListS args_suffix"];
    // args -> ListS args_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_ListS", toker->burn(Toke_ListS::instance()));
        noad->add_noad(this->args_suffix(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cond_ifs_suffix(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["cond_ifs_suffix -> Newline cond_ifs"];
    // cond_ifs_suffix -> Newline cond_ifs
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Newline", toker->burn(Toke_Newline::instance()));
        this->cond_ifs(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::loop(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("loop"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["loop -> LoopS loop_body loop_condition LoopE"];
    // loop -> LoopS loop_body loop_condition LoopE
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_LoopS", toker->burn(Toke_LoopS::instance()));
        noad->add_noad(this->loop_body(noad));
        noad->add_noad(this->loop_condition(noad));
        noad->add_toke("Toke_LoopE", toker->burn(Toke_LoopE::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::coda(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("coda"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["coda -> Coda optional_al_coda"];
    // coda -> Coda optional_al_coda
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Coda", toker->burn(Toke_Coda::instance()));
        noad->add_noad(this->optional_al_coda(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::expr(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("expr"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["expr -> msgable expr_prime"];
    // expr -> msgable expr_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->msgable(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::al_x(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("al_x"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["al_x -> AlCoda"];
    // al_x -> AlCoda
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_AlCoda", toker->burn(Toke_AlCoda::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["al_x -> AlSegno"];
    // al_x -> AlSegno
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_AlSegno", toker->burn(Toke_AlSegno::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["al_x -> AlFine"];
    // al_x -> AlFine
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_AlFine", toker->burn(Toke_AlFine::instance()));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::optional_voice(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["optional_voice -> Voice"];
    // optional_voice -> Voice
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Voice", toker->burn(Toke_Voice::instance()));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::marker(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("marker"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["marker -> Segno"];
    // marker -> Segno
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Segno", toker->burn(Toke_Segno::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["marker -> Fine"];
    // marker -> Fine
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Fine", toker->burn(Toke_Fine::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["marker -> coda"];
    // marker -> coda
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->coda(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["marker -> Volta"];
    // marker -> Volta
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Volta", toker->burn(Toke_Volta::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["marker -> Bars"];
    // marker -> Bars
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Bars", toker->burn(Toke_Bars::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_sig(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("skrp_sig"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["skrp_sig -> args"];
    // skrp_sig -> args
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->args(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["skrp_sig -> SymbolName optional_args"];
    // skrp_sig -> SymbolName optional_args
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_SymbolName", toker->burn(Toke_SymbolName::instance()));
        this->optional_args(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::listy_suffix(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["listy_suffix -> listy_entries ListE"];
    // listy_suffix -> listy_entries ListE
    if (toker->sees(desires) != nullptr) {
        this->listy_entries(noad);
        noad->add_toke("Toke_ListE", toker->burn(Toke_ListE::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["listy_suffix -> ListE"];
    // listy_suffix -> ListE
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_ListE", toker->burn(Toke_ListE::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::math(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("math"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["math -> MathOp msgable"];
    // math -> MathOp msgable
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_MathOp", toker->burn(Toke_MathOp::instance()));
        noad->add_noad(this->msgable(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cond_ifs(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["cond_ifs -> cond_if cond_ifs_suffix"];
    // cond_ifs -> cond_if cond_ifs_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->cond_if(noad));
        this->cond_ifs_suffix(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skoarpion(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("skoarpion"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["skoarpion -> SkoarpionStart skrp_sig SkoarpionSep skrp_suffix"];
    // skoarpion -> SkoarpionStart skrp_sig SkoarpionSep skrp_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_SkoarpionStart", toker->burn(Toke_SkoarpionStart::instance()));
        noad->add_noad(this->skrp_sig(noad));
        noad->add_toke("Toke_SkoarpionSep", toker->burn(Toke_SkoarpionSep::instance()));
        noad->add_noad(this->skrp_suffix(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cthulhu_prime(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["cthulhu_prime -> boolean Semicolon RWing"];
    // cthulhu_prime -> boolean Semicolon RWing
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->boolean(noad));
        noad->add_toke("Toke_Semicolon", toker->burn(Toke_Semicolon::instance()));
        noad->add_toke("Toke_RWing", toker->burn(Toke_RWing::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["cthulhu_prime -> Nosey Semicolon RWing"];
    // cthulhu_prime -> Nosey Semicolon RWing
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Nosey", toker->burn(Toke_Nosey::instance()));
        noad->add_toke("Toke_Semicolon", toker->burn(Toke_Semicolon::instance()));
        noad->add_toke("Toke_RWing", toker->burn(Toke_RWing::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_suffix(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("skrp_suffix"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["skrp_suffix -> skrp_lines SkoarpionEnd"];
    // skrp_suffix -> skrp_lines SkoarpionEnd
    if (toker->sees(desires) != nullptr) {
        this->skrp_lines(noad);
        noad->add_toke("Toke_SkoarpionEnd", toker->burn(Toke_SkoarpionEnd::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::branches(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["branches -> branch branches"];
    // branches -> branch branches
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->branch(noad));
        this->branches(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::dal_goto(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("dal_goto"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["dal_goto -> DaCapo al_x"];
    // dal_goto -> DaCapo al_x
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_DaCapo", toker->burn(Toke_DaCapo::instance()));
        noad->add_noad(this->al_x(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["dal_goto -> DalSegno al_x"];
    // dal_goto -> DalSegno al_x
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_DalSegno", toker->burn(Toke_DalSegno::instance()));
        noad->add_noad(this->al_x(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::musical_keyword_misc(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("musical_keyword_misc"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["musical_keyword_misc -> Rep"];
    // musical_keyword_misc -> Rep
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Rep", toker->burn(Toke_Rep::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["musical_keyword_misc -> Portamento"];
    // musical_keyword_misc -> Portamento
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Portamento", toker->burn(Toke_Portamento::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["musical_keyword_misc -> Carrot"];
    // musical_keyword_misc -> Carrot
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Carrot", toker->burn(Toke_Carrot::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skoar(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("skoar"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["skoar -> branches"];
    // skoar -> branches
    if (toker->sees(desires) != nullptr) {
        this->branches(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cond_if(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("cond_if"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["cond_if -> optional_voice boolean CondIf if_body cond_else"];
    // cond_if -> optional_voice boolean CondIf if_body cond_else
    if (toker->sees(desires) != nullptr) {
        this->optional_voice(noad);
        noad->add_noad(this->boolean(noad));
        noad->add_toke("Toke_CondIf", toker->burn(Toke_CondIf::instance()));
        noad->add_noad(this->if_body(noad));
        this->cond_else(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::optional_args(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["optional_args -> args"];
    // optional_args -> args
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->args(noad));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::if_body(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("if_body"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["if_body -> phrases"];
    // if_body -> phrases
    if (toker->sees(desires) != nullptr) {
        this->phrases(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::settable(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["settable -> Caesura"];
    // settable -> Caesura
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Caesura", toker->burn(Toke_Caesura::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["settable -> Symbol"];
    // settable -> Symbol
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Symbol", toker->burn(Toke_Symbol::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["settable -> listy"];
    // settable -> listy
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->listy(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["settable -> Quarters"];
    // settable -> Quarters
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Quarters", toker->burn(Toke_Quarters::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["settable -> Eighths"];
    // settable -> Eighths
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Eighths", toker->burn(Toke_Eighths::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["settable -> Fairy"];
    // settable -> Fairy
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Fairy", toker->burn(Toke_Fairy::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::phrases(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["phrases -> phrasey phrases"];
    // phrases -> phrasey phrases
    if (toker->sees(desires) != nullptr) {
        this->phrasey(noad);
        this->phrases(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::musical_keyword(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("musical_keyword"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["musical_keyword -> dynamic"];
    // musical_keyword -> dynamic
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->dynamic(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["musical_keyword -> ottavas"];
    // musical_keyword -> ottavas
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->ottavas(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["musical_keyword -> pedally"];
    // musical_keyword -> pedally
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->pedally(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["musical_keyword -> musical_keyword_misc"];
    // musical_keyword -> musical_keyword_misc
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->musical_keyword_misc(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::args_suffix(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("args_suffix"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["args_suffix -> args_entries ListE"];
    // args_suffix -> args_entries ListE
    if (toker->sees(desires) != nullptr) {
        this->args_entries(noad);
        noad->add_toke("Toke_ListE", toker->burn(Toke_ListE::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::msg(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("msg"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["msg -> MsgNameWithArgs listy_suffix"];
    // msg -> MsgNameWithArgs listy_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_MsgNameWithArgs", toker->burn(Toke_MsgNameWithArgs::instance()));
        this->listy_suffix(noad);
        --deep;;
        return noad;
    }

    desires = &desirables["msg -> MsgName"];
    // msg -> MsgName
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_MsgName", toker->burn(Toke_MsgName::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["msg -> listy"];
    // msg -> listy
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->listy(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["msg -> loop"];
    // msg -> loop
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->loop(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::nouny(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("nouny"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["nouny -> cthulhu"];
    // nouny -> cthulhu
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->cthulhu(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny -> conditional"];
    // nouny -> conditional
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->conditional(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny -> loop"];
    // nouny -> loop
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->loop(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny -> nouny_literal"];
    // nouny -> nouny_literal
    if (toker->sees(desires) != nullptr) {
        this->nouny_literal(noad);
        --deep;;
        return noad;
    }

    desires = &desirables["nouny -> musical_keyword"];
    // nouny -> musical_keyword
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->musical_keyword(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny -> listy"];
    // nouny -> listy
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->listy(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny -> deref"];
    // nouny -> deref
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->deref(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny -> skoarpion"];
    // nouny -> skoarpion
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->skoarpion(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::expr_prime(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("expr_prime"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["expr_prime -> assignment expr_prime"];
    // expr_prime -> assignment expr_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->assignment(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;;
        return noad;
    }

    desires = &desirables["expr_prime -> math expr_prime"];
    // expr_prime -> math expr_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->math(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::cond_else(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["cond_else -> CondIf if_body"];
    // cond_else -> CondIf if_body
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_CondIf", toker->burn(Toke_CondIf::instance()));
        noad->add_noad(this->if_body(noad));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::loop_body(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("loop_body"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["loop_body -> phrases"];
    // loop_body -> phrases
    if (toker->sees(desires) != nullptr) {
        this->phrases(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::moar_args_entries(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["moar_args_entries -> ListSep args_entries"];
    // moar_args_entries -> ListSep args_entries
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_ListSep", toker->burn(Toke_ListSep::instance()));
        this->args_entries(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::boolean(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("boolean"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["boolean -> expr BooleanOp expr"];
    // boolean -> expr BooleanOp expr
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->expr(noad));
        noad->add_toke("Toke_BooleanOp", toker->burn(Toke_BooleanOp::instance()));
        noad->add_noad(this->expr(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_sep_or_nl(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["skrp_sep_or_nl -> Newline"];
    // skrp_sep_or_nl -> Newline
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Newline", toker->burn(Toke_Newline::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["skrp_sep_or_nl -> SkoarpionSep"];
    // skrp_sep_or_nl -> SkoarpionSep
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_SkoarpionSep", toker->burn(Toke_SkoarpionSep::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::msg_chain_node(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["msg_chain_node -> MsgOp msg msg_chain_node"];
    // msg_chain_node -> MsgOp msg msg_chain_node
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_MsgOp", toker->burn(Toke_MsgOp::instance()));
        noad->add_noad(this->msg(noad));
        this->msg_chain_node(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::conditional(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("conditional"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["conditional -> CondS cond_ifs CondE"];
    // conditional -> CondS cond_ifs CondE
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_CondS", toker->burn(Toke_CondS::instance()));
        this->cond_ifs(noad);
        noad->add_toke("Toke_CondE", toker->burn(Toke_CondE::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::nouny_literal(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["nouny_literal -> Tuplet"];
    // nouny_literal -> Tuplet
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Tuplet", toker->burn(Toke_Tuplet::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> Caesura"];
    // nouny_literal -> Caesura
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Caesura", toker->burn(Toke_Caesura::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> Freq"];
    // nouny_literal -> Freq
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Freq", toker->burn(Toke_Freq::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> Int"];
    // nouny_literal -> Int
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Int", toker->burn(Toke_Int::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> Float"];
    // nouny_literal -> Float
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Float", toker->burn(Toke_Float::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> String"];
    // nouny_literal -> String
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_String", toker->burn(Toke_String::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> Choard"];
    // nouny_literal -> Choard
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Choard", toker->burn(Toke_Choard::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> NamedNoat"];
    // nouny_literal -> NamedNoat
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_NamedNoat", toker->burn(Toke_NamedNoat::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> Symbol"];
    // nouny_literal -> Symbol
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Symbol", toker->burn(Toke_Symbol::instance()));
        --deep;;
        return noad;
    }

    desires = &desirables["nouny_literal -> Fairy"];
    // nouny_literal -> Fairy
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_Fairy", toker->burn(Toke_Fairy::instance()));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_lines(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["skrp_lines -> optional_voice phrases skrp_moar_lines"];
    // skrp_lines -> optional_voice phrases skrp_moar_lines
    if (toker->sees(desires) != nullptr) {
        this->optional_voice(noad);
        this->phrases(noad);
        this->skrp_moar_lines(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::optional_al_coda(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(string("optional_al_coda"), parent);;
    list<SkoarToke *>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables["optional_al_coda -> AlCoda"];
    // optional_al_coda -> AlCoda
    if (toker->sees(desires) != nullptr) {
        noad->add_toke("Toke_AlCoda", toker->burn(Toke_AlCoda::instance()));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

