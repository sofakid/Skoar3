// =====================================================================================================================
// rdpp.cpp - Generated by Code_Parser_Cpp - Create Recursive Descent Predictive Parser on 2015-08-05 18:46:19 for C++14
// =====================================================================================================================
#include "rdpp.hpp"
#include "exception.hpp"
#include "lex.hpp"
#include "noad.hpp"

void SkoarParser::fail() {
    toker->dump();
    throw new SkoarParseException(L"Fail");;
}

void SkoarParser::fail_too_deep() {
    toker->dump();
    throw new SkoarParseException(L"Parse tree too deep!");;
}

 SkoarParser::SkoarParser(SkoarToker * toker) {

    this->deep = 0;
    this->toker = toker;
    this->init_desirables();
    
}

void SkoarParser::init_desirables() {

    // dynamic
    desirables[L"dynamic -> DynPiano"] = {ESkoarToke::DynPiano};
    desirables[L"dynamic -> DynForte"] = {ESkoarToke::DynForte};
    desirables[L"dynamic -> DynSFZ"] = {ESkoarToke::DynSFZ};
    desirables[L"dynamic -> DynFP"] = {ESkoarToke::DynFP};

    // skrp_moar_lines
    desirables[L"skrp_moar_lines -> Newline skrp_lines"] = {ESkoarToke::Newline};

    // times
    desirables[L"times -> Times"] = {ESkoarToke::Times};

    // skrp_sig
    desirables[L"skrp_sig -> ArgSpec SkoarpionSep"] = {ESkoarToke::ArgSpec};
    desirables[L"skrp_sig -> SymbolName opt_arg_spec SkoarpionSep"] = {ESkoarToke::SymbolName};

    // loop
    desirables[L"loop -> LoopS loop_body loop_condition LoopE"] = {ESkoarToke::LoopS};

    // ottavas
    desirables[L"ottavas -> OctaveShift"] = {ESkoarToke::OctaveShift};
    desirables[L"ottavas -> OttavaA"] = {ESkoarToke::OttavaA};
    desirables[L"ottavas -> OttavaB"] = {ESkoarToke::OttavaB};
    desirables[L"ottavas -> QuindicesimaA"] = {ESkoarToke::QuindicesimaA};
    desirables[L"ottavas -> QuindicesimaB"] = {ESkoarToke::QuindicesimaB};
    desirables[L"ottavas -> Loco"] = {ESkoarToke::Loco};

    // assignment
    desirables[L"assignment -> AssOp settable"] = {ESkoarToke::AssOp};

    // expr
    desirables[L"expr -> msgable expr_prime"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::QuindicesimaB,
               ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco, ESkoarToke::Caesura,
               ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::DynSFZ,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::OttavaA};

    // deref_prime
    desirables[L"deref_prime -> MsgNameWithArgs listy_suffix"] = {ESkoarToke::MsgNameWithArgs};
    desirables[L"deref_prime -> MsgName"] = {ESkoarToke::MsgName};

    // phrasey
    desirables[L"phrasey -> Comment"] = {ESkoarToke::Comment};
    desirables[L"phrasey -> marker"] = {ESkoarToke::Fine, ESkoarToke::Coda, ESkoarToke::Volta, ESkoarToke::Bars, ESkoarToke::Segno};
    desirables[L"phrasey -> Meter"] = {ESkoarToke::Meter};
    desirables[L"phrasey -> expr"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::QuindicesimaB,
               ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco, ESkoarToke::Caesura,
               ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::DynSFZ,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::OttavaA};
    desirables[L"phrasey -> dal_goto"] = {ESkoarToke::DaCapo, ESkoarToke::DalSegno};
    desirables[L"phrasey -> beat"] = {ESkoarToke::Quavers, ESkoarToke::Quarters, ESkoarToke::Crotchets, ESkoarToke::Eighths, ESkoarToke::Slash};

    // listy_suffix
    desirables[L"listy_suffix -> listy_entries ListE"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::QuindicesimaB,
               ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco, ESkoarToke::Caesura,
               ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::DynSFZ,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::OttavaA};
    desirables[L"listy_suffix -> ListE"] = {ESkoarToke::ListE};

    // skoar
    desirables[L"skoar -> branches"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::Volta,
               ESkoarToke::QuindicesimaB, ESkoarToke::DynPiano, ESkoarToke::Voice, ESkoarToke::ListS, ESkoarToke::Eighths,
               ESkoarToke::Slash, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown, ESkoarToke::String,
               ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Meter, ESkoarToke::Coda, ESkoarToke::Loco,
               ESkoarToke::Quavers, ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::Comment,
               ESkoarToke::NamedNoat, ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS, ESkoarToke::Quarters,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets, ESkoarToke::Int,
               ESkoarToke::HashLevel, ESkoarToke::Newline, ESkoarToke::Bars, ESkoarToke::DynSFZ, ESkoarToke::OttavaB,
               ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap, ESkoarToke::Carrot,
               ESkoarToke::Eof, ESkoarToke::OctaveShift, ESkoarToke::Segno, ESkoarToke::DynForte, ESkoarToke::CondS,
               ESkoarToke::Fine, ESkoarToke::OttavaA};

    // skrp_suffix
    desirables[L"skrp_suffix -> skrp_lines SkoarpionEnd"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::SkoarpionEnd, ESkoarToke::Rep, ESkoarToke::Tuplet,
               ESkoarToke::Volta, ESkoarToke::QuindicesimaB, ESkoarToke::DynPiano, ESkoarToke::Voice, ESkoarToke::ListS,
               ESkoarToke::Eighths, ESkoarToke::Slash, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Meter, ESkoarToke::Coda,
               ESkoarToke::Loco, ESkoarToke::Quavers, ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento,
               ESkoarToke::Comment, ESkoarToke::NamedNoat, ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::Quarters, ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets,
               ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::Newline, ESkoarToke::Bars, ESkoarToke::DynSFZ,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::Segno, ESkoarToke::DynForte, ESkoarToke::CondS,
               ESkoarToke::Fine, ESkoarToke::OttavaA};

    // skrp_lines
    desirables[L"skrp_lines -> optional_voice phrases skrp_moar_lines"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::SkoarpionEnd, ESkoarToke::Rep, ESkoarToke::QuindicesimaB,
               ESkoarToke::Volta, ESkoarToke::Tuplet, ESkoarToke::DynPiano, ESkoarToke::Voice, ESkoarToke::ListS,
               ESkoarToke::Eighths, ESkoarToke::Slash, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Meter, ESkoarToke::Coda,
               ESkoarToke::Loco, ESkoarToke::Quavers, ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento,
               ESkoarToke::Comment, ESkoarToke::NamedNoat, ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::Quarters, ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets,
               ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::Bars, ESkoarToke::DynSFZ, ESkoarToke::Newline,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::Segno, ESkoarToke::DynForte, ESkoarToke::CondS,
               ESkoarToke::Fine, ESkoarToke::OttavaA};

    // conditional
    desirables[L"conditional -> CondS cond_ifs CondE"] = {ESkoarToke::CondS};

    // listy_entries
    desirables[L"listy_entries -> expr moar_listy_entries"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::QuindicesimaB,
               ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco, ESkoarToke::Caesura,
               ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::DynSFZ,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::OttavaA};

    // msgable
    desirables[L"msgable -> nouny msg_chain_node"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::QuindicesimaB, ESkoarToke::Tuplet,
               ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco, ESkoarToke::Caesura,
               ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::DynSFZ,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::OttavaA};

    // musical_keyword_misc
    desirables[L"musical_keyword_misc -> Rep"] = {ESkoarToke::Rep};
    desirables[L"musical_keyword_misc -> Portamento"] = {ESkoarToke::Portamento};
    desirables[L"musical_keyword_misc -> Carrot"] = {ESkoarToke::Carrot};

    // moar_listy_entries
    desirables[L"moar_listy_entries -> ListSep listy_entries"] = {ESkoarToke::ListSep};
    desirables[L"moar_listy_entries -> Newline"] = {ESkoarToke::Newline};

    // nouny_literal
    desirables[L"nouny_literal -> Tuplet"] = {ESkoarToke::Tuplet};
    desirables[L"nouny_literal -> Caesura"] = {ESkoarToke::Caesura};
    desirables[L"nouny_literal -> Freq"] = {ESkoarToke::Freq};
    desirables[L"nouny_literal -> Int"] = {ESkoarToke::Int};
    desirables[L"nouny_literal -> Float"] = {ESkoarToke::Float};
    desirables[L"nouny_literal -> String"] = {ESkoarToke::String};
    desirables[L"nouny_literal -> Choard"] = {ESkoarToke::Choard};
    desirables[L"nouny_literal -> NamedNoat"] = {ESkoarToke::NamedNoat};
    desirables[L"nouny_literal -> Symbol"] = {ESkoarToke::Symbol};
    desirables[L"nouny_literal -> Fairy"] = {ESkoarToke::Fairy};
    desirables[L"nouny_literal -> HashLevel"] = {ESkoarToke::HashLevel};
    desirables[L"nouny_literal -> False"] = {ESkoarToke::False};
    desirables[L"nouny_literal -> True"] = {ESkoarToke::True};
    desirables[L"nouny_literal -> Crap"] = {ESkoarToke::Crap};

    // settable
    desirables[L"settable -> Caesura"] = {ESkoarToke::Caesura};
    desirables[L"settable -> Symbol"] = {ESkoarToke::Symbol};
    desirables[L"settable -> listy"] = {ESkoarToke::ListS};
    desirables[L"settable -> Quarters"] = {ESkoarToke::Quarters};
    desirables[L"settable -> Eighths"] = {ESkoarToke::Eighths};
    desirables[L"settable -> Fairy"] = {ESkoarToke::Fairy};

    // msg_chain_node
    desirables[L"msg_chain_node -> MsgOp msg msg_chain_node"] = {ESkoarToke::MsgOp};

    // branches
    desirables[L"branches -> branch branches"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::Volta,
               ESkoarToke::QuindicesimaB, ESkoarToke::DynPiano, ESkoarToke::Voice, ESkoarToke::ListS, ESkoarToke::Eighths,
               ESkoarToke::Slash, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown, ESkoarToke::String,
               ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Meter, ESkoarToke::Coda, ESkoarToke::Loco,
               ESkoarToke::Quavers, ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::Comment,
               ESkoarToke::NamedNoat, ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS, ESkoarToke::Quarters,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets, ESkoarToke::Int,
               ESkoarToke::HashLevel, ESkoarToke::Newline, ESkoarToke::Bars, ESkoarToke::DynSFZ, ESkoarToke::OttavaB,
               ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap, ESkoarToke::Carrot,
               ESkoarToke::OctaveShift, ESkoarToke::Segno, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::Fine,
               ESkoarToke::OttavaA};

    // cond_else
    desirables[L"cond_else -> CondIf if_body"] = {ESkoarToke::CondIf};

    // musical_keyword
    desirables[L"musical_keyword -> dynamic"] = {ESkoarToke::DynSFZ, ESkoarToke::DynFP, ESkoarToke::DynPiano, ESkoarToke::DynForte};
    desirables[L"musical_keyword -> ottavas"] = {ESkoarToke::QuindicesimaB, ESkoarToke::OttavaA, ESkoarToke::OttavaB, ESkoarToke::Loco, ESkoarToke::QuindicesimaA,
               ESkoarToke::OctaveShift};
    desirables[L"musical_keyword -> pedally"] = {ESkoarToke::PedalDown, ESkoarToke::PedalUp};
    desirables[L"musical_keyword -> musical_keyword_misc"] = {ESkoarToke::Portamento, ESkoarToke::Rep, ESkoarToke::Carrot};

    // msg
    desirables[L"msg -> MsgNameWithArgs listy_suffix"] = {ESkoarToke::MsgNameWithArgs};
    desirables[L"msg -> MsgName"] = {ESkoarToke::MsgName};
    desirables[L"msg -> listy"] = {ESkoarToke::ListS};
    desirables[L"msg -> loop"] = {ESkoarToke::LoopS};

    // loop_body
    desirables[L"loop_body -> phrases"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::QuindicesimaB, ESkoarToke::Volta,
               ESkoarToke::Tuplet, ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Eighths, ESkoarToke::Slash,
               ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::LoopSep, ESkoarToke::PedalDown, ESkoarToke::String,
               ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Meter, ESkoarToke::Coda, ESkoarToke::Loco,
               ESkoarToke::Quavers, ESkoarToke::LoopE, ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento,
               ESkoarToke::Comment, ESkoarToke::NamedNoat, ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::Quarters, ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets,
               ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::Bars, ESkoarToke::DynSFZ, ESkoarToke::OttavaB,
               ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap, ESkoarToke::Carrot,
               ESkoarToke::OctaveShift, ESkoarToke::Segno, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::Fine,
               ESkoarToke::OttavaA};

    // coda
    desirables[L"coda -> Coda optional_al_coda"] = {ESkoarToke::Coda};

    // beat
    desirables[L"beat -> Crotchets"] = {ESkoarToke::Crotchets};
    desirables[L"beat -> Quavers"] = {ESkoarToke::Quavers};
    desirables[L"beat -> Quarters"] = {ESkoarToke::Quarters};
    desirables[L"beat -> Eighths"] = {ESkoarToke::Eighths};
    desirables[L"beat -> Slash"] = {ESkoarToke::Slash};

    // pedally
    desirables[L"pedally -> PedalDown"] = {ESkoarToke::PedalDown};
    desirables[L"pedally -> PedalUp"] = {ESkoarToke::PedalUp};

    // cthulhu
    desirables[L"cthulhu -> LWing Semicolon cthulhu_prime"] = {ESkoarToke::LWing};

    // nouny
    desirables[L"nouny -> cthulhu"] = {ESkoarToke::LWing};
    desirables[L"nouny -> conditional"] = {ESkoarToke::CondS};
    desirables[L"nouny -> loop"] = {ESkoarToke::LoopS};
    desirables[L"nouny -> nouny_literal"] = {ESkoarToke::Float, ESkoarToke::Crap, ESkoarToke::NamedNoat, ESkoarToke::Fairy, ESkoarToke::False,
               ESkoarToke::Choard, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::Freq, ESkoarToke::Tuplet,
               ESkoarToke::String, ESkoarToke::HashLevel, ESkoarToke::Symbol, ESkoarToke::Caesura};
    desirables[L"nouny -> musical_keyword"] = {ESkoarToke::DynFP, ESkoarToke::Portamento, ESkoarToke::PedalUp, ESkoarToke::Carrot, ESkoarToke::QuindicesimaA,
               ESkoarToke::OctaveShift, ESkoarToke::PedalDown, ESkoarToke::DynForte, ESkoarToke::Rep, ESkoarToke::QuindicesimaB,
               ESkoarToke::DynSFZ, ESkoarToke::OttavaA, ESkoarToke::OttavaB, ESkoarToke::DynPiano, ESkoarToke::Loco};
    desirables[L"nouny -> listy"] = {ESkoarToke::ListS};
    desirables[L"nouny -> deref"] = {ESkoarToke::Deref};
    desirables[L"nouny -> skoarpion"] = {ESkoarToke::SkoarpionStart};

    // deref
    desirables[L"deref -> Deref deref_prime"] = {ESkoarToke::Deref};

    // math
    desirables[L"math -> MathOp msgable"] = {ESkoarToke::MathOp};

    // al_x
    desirables[L"al_x -> AlCoda"] = {ESkoarToke::AlCoda};
    desirables[L"al_x -> AlSegno"] = {ESkoarToke::AlSegno};
    desirables[L"al_x -> AlFine"] = {ESkoarToke::AlFine};

    // listy
    desirables[L"listy -> ListS listy_suffix"] = {ESkoarToke::ListS};

    // dal_goto
    desirables[L"dal_goto -> DaCapo al_x"] = {ESkoarToke::DaCapo};
    desirables[L"dal_goto -> DalSegno al_x"] = {ESkoarToke::DalSegno};

    // branch
    desirables[L"branch -> optional_voice phrases Newline"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::QuindicesimaB, ESkoarToke::Volta,
               ESkoarToke::Tuplet, ESkoarToke::DynPiano, ESkoarToke::Voice, ESkoarToke::ListS, ESkoarToke::Eighths,
               ESkoarToke::Slash, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown, ESkoarToke::String,
               ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Meter, ESkoarToke::Coda, ESkoarToke::Loco,
               ESkoarToke::Quavers, ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::Comment,
               ESkoarToke::NamedNoat, ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS, ESkoarToke::Quarters,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets, ESkoarToke::Int,
               ESkoarToke::HashLevel, ESkoarToke::Bars, ESkoarToke::DynSFZ, ESkoarToke::Newline, ESkoarToke::OttavaB,
               ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap, ESkoarToke::Carrot,
               ESkoarToke::OctaveShift, ESkoarToke::Segno, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::Fine,
               ESkoarToke::OttavaA};

    // loop_condition
    desirables[L"loop_condition -> LoopSep expr"] = {ESkoarToke::LoopSep};

    // optional_voice
    desirables[L"optional_voice -> Voice"] = {ESkoarToke::Voice};

    // cthulhu_prime
    desirables[L"cthulhu_prime -> expr Semicolon RWing"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::QuindicesimaB,
               ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown,
               ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco, ESkoarToke::Caesura,
               ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing, ESkoarToke::LoopS,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel, ESkoarToke::DynSFZ,
               ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap,
               ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::OttavaA};
    desirables[L"cthulhu_prime -> Nosey Semicolon RWing"] = {ESkoarToke::Nosey};

    // cond_ifs
    desirables[L"cond_ifs -> cond_if cond_ifs_suffix"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::QuindicesimaB, ESkoarToke::Tuplet,
               ESkoarToke::DynPiano, ESkoarToke::Voice, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False,
               ESkoarToke::PedalDown, ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco,
               ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing,
               ESkoarToke::LoopS, ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel,
               ESkoarToke::DynSFZ, ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float,
               ESkoarToke::Crap, ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS,
               ESkoarToke::OttavaA};

    // boolean
    desirables[L"boolean -> BooleanOp expr"] = {ESkoarToke::BooleanOp};

    // opt_arg_spec
    desirables[L"opt_arg_spec -> ArgSpec"] = {ESkoarToke::ArgSpec};

    // skoarpion
    desirables[L"skoarpion -> SkoarpionStart skrp_sig skrp_suffix"] = {ESkoarToke::SkoarpionStart};

    // cond_ifs_suffix
    desirables[L"cond_ifs_suffix -> Newline cond_ifs"] = {ESkoarToke::Newline};

    // phrases
    desirables[L"phrases -> phrasey phrases"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::QuindicesimaB, ESkoarToke::Volta,
               ESkoarToke::Tuplet, ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Eighths, ESkoarToke::Slash,
               ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown, ESkoarToke::String, ESkoarToke::Deref,
               ESkoarToke::Freq, ESkoarToke::Quavers, ESkoarToke::Meter, ESkoarToke::Coda, ESkoarToke::Loco,
               ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::Comment, ESkoarToke::NamedNoat,
               ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS, ESkoarToke::Quarters, ESkoarToke::QuindicesimaA,
               ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets, ESkoarToke::Int, ESkoarToke::HashLevel,
               ESkoarToke::Bars, ESkoarToke::DynSFZ, ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP,
               ESkoarToke::Float, ESkoarToke::Crap, ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::Segno,
               ESkoarToke::DynForte, ESkoarToke::CondS, ESkoarToke::Fine, ESkoarToke::OttavaA};

    // if_body
    desirables[L"if_body -> phrases"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::QuindicesimaB, ESkoarToke::Volta,
               ESkoarToke::Tuplet, ESkoarToke::DynPiano, ESkoarToke::ListS, ESkoarToke::Eighths, ESkoarToke::Slash,
               ESkoarToke::CondE, ESkoarToke::Fairy, ESkoarToke::False, ESkoarToke::PedalDown, ESkoarToke::String,
               ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Meter, ESkoarToke::Coda, ESkoarToke::Loco,
               ESkoarToke::Quavers, ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::Comment,
               ESkoarToke::NamedNoat, ESkoarToke::DalSegno, ESkoarToke::LWing, ESkoarToke::LoopS, ESkoarToke::Quarters,
               ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::DaCapo, ESkoarToke::Crotchets, ESkoarToke::Int,
               ESkoarToke::HashLevel, ESkoarToke::Bars, ESkoarToke::DynSFZ, ESkoarToke::Newline, ESkoarToke::OttavaB,
               ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float, ESkoarToke::Crap, ESkoarToke::Carrot,
               ESkoarToke::CondIf, ESkoarToke::OctaveShift, ESkoarToke::Segno, ESkoarToke::DynForte, ESkoarToke::CondS,
               ESkoarToke::Fine, ESkoarToke::OttavaA};

    // marker
    desirables[L"marker -> Segno"] = {ESkoarToke::Segno};
    desirables[L"marker -> Fine"] = {ESkoarToke::Fine};
    desirables[L"marker -> coda"] = {ESkoarToke::Coda};
    desirables[L"marker -> Volta"] = {ESkoarToke::Volta};
    desirables[L"marker -> Bars"] = {ESkoarToke::Bars};

    // expr_prime
    desirables[L"expr_prime -> assignment expr_prime"] = {ESkoarToke::AssOp};
    desirables[L"expr_prime -> math expr_prime"] = {ESkoarToke::MathOp};
    desirables[L"expr_prime -> boolean"] = {ESkoarToke::BooleanOp};
    desirables[L"expr_prime -> times"] = {ESkoarToke::Times};

    // cond_if
    desirables[L"cond_if -> optional_voice expr CondIf if_body cond_else"] = {ESkoarToke::SkoarpionStart, ESkoarToke::Choard, ESkoarToke::Rep, ESkoarToke::Tuplet, ESkoarToke::QuindicesimaB,
               ESkoarToke::DynPiano, ESkoarToke::Voice, ESkoarToke::ListS, ESkoarToke::Fairy, ESkoarToke::False,
               ESkoarToke::PedalDown, ESkoarToke::String, ESkoarToke::Freq, ESkoarToke::Deref, ESkoarToke::Loco,
               ESkoarToke::Caesura, ESkoarToke::PedalUp, ESkoarToke::Portamento, ESkoarToke::NamedNoat, ESkoarToke::LWing,
               ESkoarToke::LoopS, ESkoarToke::QuindicesimaA, ESkoarToke::True, ESkoarToke::Int, ESkoarToke::HashLevel,
               ESkoarToke::DynSFZ, ESkoarToke::OttavaB, ESkoarToke::Symbol, ESkoarToke::DynFP, ESkoarToke::Float,
               ESkoarToke::Crap, ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynForte, ESkoarToke::CondS,
               ESkoarToke::OttavaA};

    // optional_al_coda
    desirables[L"optional_al_coda -> AlCoda"] = {ESkoarToke::AlCoda};
}

SkoarNoad* SkoarParser::dynamic(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"dynamic"), ESkoarNoad::dynamic, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"dynamic -> DynPiano"];
    // dynamic -> DynPiano
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_DynPiano", toker->burn(ESkoarToke::DynPiano));
        --deep;;
        return noad;
    }

    desires = &desirables[L"dynamic -> DynForte"];
    // dynamic -> DynForte
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_DynForte", toker->burn(ESkoarToke::DynForte));
        --deep;;
        return noad;
    }

    desires = &desirables[L"dynamic -> DynSFZ"];
    // dynamic -> DynSFZ
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_DynSFZ", toker->burn(ESkoarToke::DynSFZ));
        --deep;;
        return noad;
    }

    desires = &desirables[L"dynamic -> DynFP"];
    // dynamic -> DynFP
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_DynFP", toker->burn(ESkoarToke::DynFP));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_moar_lines(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"skrp_moar_lines -> Newline skrp_lines"];
    // skrp_moar_lines -> Newline skrp_lines
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Newline", toker->burn(ESkoarToke::Newline));
        this->skrp_lines(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::times(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"times"), ESkoarNoad::times, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"times -> Times"];
    // times -> Times
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Times", toker->burn(ESkoarToke::Times));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_sig(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"skrp_sig"), ESkoarNoad::skrp_sig, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"skrp_sig -> ArgSpec SkoarpionSep"];
    // skrp_sig -> ArgSpec SkoarpionSep
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_ArgSpec", toker->burn(ESkoarToke::ArgSpec));
        noad->add_toke(L"Toke_SkoarpionSep", toker->burn(ESkoarToke::SkoarpionSep));
        --deep;;
        return noad;
    }

    desires = &desirables[L"skrp_sig -> SymbolName opt_arg_spec SkoarpionSep"];
    // skrp_sig -> SymbolName opt_arg_spec SkoarpionSep
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_SymbolName", toker->burn(ESkoarToke::SymbolName));
        noad->add_noad(this->opt_arg_spec(noad));
        noad->add_toke(L"Toke_SkoarpionSep", toker->burn(ESkoarToke::SkoarpionSep));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::loop(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"loop"), ESkoarNoad::loop, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"loop -> LoopS loop_body loop_condition LoopE"];
    // loop -> LoopS loop_body loop_condition LoopE
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_LoopS", toker->burn(ESkoarToke::LoopS));
        noad->add_noad(this->loop_body(noad));
        noad->add_noad(this->loop_condition(noad));
        noad->add_toke(L"Toke_LoopE", toker->burn(ESkoarToke::LoopE));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::ottavas(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"ottavas"), ESkoarNoad::ottavas, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"ottavas -> OctaveShift"];
    // ottavas -> OctaveShift
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_OctaveShift", toker->burn(ESkoarToke::OctaveShift));
        --deep;;
        return noad;
    }

    desires = &desirables[L"ottavas -> OttavaA"];
    // ottavas -> OttavaA
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_OttavaA", toker->burn(ESkoarToke::OttavaA));
        --deep;;
        return noad;
    }

    desires = &desirables[L"ottavas -> OttavaB"];
    // ottavas -> OttavaB
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_OttavaB", toker->burn(ESkoarToke::OttavaB));
        --deep;;
        return noad;
    }

    desires = &desirables[L"ottavas -> QuindicesimaA"];
    // ottavas -> QuindicesimaA
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_QuindicesimaA", toker->burn(ESkoarToke::QuindicesimaA));
        --deep;;
        return noad;
    }

    desires = &desirables[L"ottavas -> QuindicesimaB"];
    // ottavas -> QuindicesimaB
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_QuindicesimaB", toker->burn(ESkoarToke::QuindicesimaB));
        --deep;;
        return noad;
    }

    desires = &desirables[L"ottavas -> Loco"];
    // ottavas -> Loco
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Loco", toker->burn(ESkoarToke::Loco));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::assignment(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"assignment"), ESkoarNoad::assignment, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"assignment -> AssOp settable"];
    // assignment -> AssOp settable
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_AssOp", toker->burn(ESkoarToke::AssOp));
        this->settable(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::expr(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"expr"), ESkoarNoad::expr, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"expr -> msgable expr_prime"];
    // expr -> msgable expr_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->msgable(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::deref_prime(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"deref_prime -> MsgNameWithArgs listy_suffix"];
    // deref_prime -> MsgNameWithArgs listy_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_MsgNameWithArgs", toker->burn(ESkoarToke::MsgNameWithArgs));
        this->listy_suffix(noad);
        --deep;;
        return noad;
    }

    desires = &desirables[L"deref_prime -> MsgName"];
    // deref_prime -> MsgName
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_MsgName", toker->burn(ESkoarToke::MsgName));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::phrasey(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"phrasey -> Comment"];
    // phrasey -> Comment
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Comment", toker->burn(ESkoarToke::Comment));
        --deep;;
        return noad;
    }

    desires = &desirables[L"phrasey -> marker"];
    // phrasey -> marker
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->marker(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"phrasey -> Meter"];
    // phrasey -> Meter
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Meter", toker->burn(ESkoarToke::Meter));
        --deep;;
        return noad;
    }

    desires = &desirables[L"phrasey -> expr"];
    // phrasey -> expr
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->expr(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"phrasey -> dal_goto"];
    // phrasey -> dal_goto
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->dal_goto(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"phrasey -> beat"];
    // phrasey -> beat
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->beat(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::listy_suffix(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"listy_suffix -> listy_entries ListE"];
    // listy_suffix -> listy_entries ListE
    if (toker->sees(desires) != nullptr) {
        this->listy_entries(noad);
        noad->add_toke(L"Toke_ListE", toker->burn(ESkoarToke::ListE));
        --deep;;
        return noad;
    }

    desires = &desirables[L"listy_suffix -> ListE"];
    // listy_suffix -> ListE
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_ListE", toker->burn(ESkoarToke::ListE));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skoar(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"skoar"), ESkoarNoad::skoar, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"skoar -> branches"];
    // skoar -> branches
    if (toker->sees(desires) != nullptr) {
        this->branches(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_suffix(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"skrp_suffix"), ESkoarNoad::skrp_suffix, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"skrp_suffix -> skrp_lines SkoarpionEnd"];
    // skrp_suffix -> skrp_lines SkoarpionEnd
    if (toker->sees(desires) != nullptr) {
        this->skrp_lines(noad);
        noad->add_toke(L"Toke_SkoarpionEnd", toker->burn(ESkoarToke::SkoarpionEnd));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::skrp_lines(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"skrp_lines -> optional_voice phrases skrp_moar_lines"];
    // skrp_lines -> optional_voice phrases skrp_moar_lines
    if (toker->sees(desires) != nullptr) {
        this->optional_voice(noad);
        this->phrases(noad);
        this->skrp_moar_lines(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::conditional(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"conditional"), ESkoarNoad::conditional, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"conditional -> CondS cond_ifs CondE"];
    // conditional -> CondS cond_ifs CondE
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_CondS", toker->burn(ESkoarToke::CondS));
        this->cond_ifs(noad);
        noad->add_toke(L"Toke_CondE", toker->burn(ESkoarToke::CondE));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::listy_entries(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"listy_entries -> expr moar_listy_entries"];
    // listy_entries -> expr moar_listy_entries
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->expr(noad));
        this->moar_listy_entries(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::msgable(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"msgable"), ESkoarNoad::msgable, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"msgable -> nouny msg_chain_node"];
    // msgable -> nouny msg_chain_node
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->nouny(noad));
        this->msg_chain_node(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::musical_keyword_misc(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"musical_keyword_misc"), ESkoarNoad::musical_keyword_misc, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"musical_keyword_misc -> Rep"];
    // musical_keyword_misc -> Rep
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Rep", toker->burn(ESkoarToke::Rep));
        --deep;;
        return noad;
    }

    desires = &desirables[L"musical_keyword_misc -> Portamento"];
    // musical_keyword_misc -> Portamento
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Portamento", toker->burn(ESkoarToke::Portamento));
        --deep;;
        return noad;
    }

    desires = &desirables[L"musical_keyword_misc -> Carrot"];
    // musical_keyword_misc -> Carrot
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Carrot", toker->burn(ESkoarToke::Carrot));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::moar_listy_entries(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"moar_listy_entries -> ListSep listy_entries"];
    // moar_listy_entries -> ListSep listy_entries
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_ListSep", toker->burn(ESkoarToke::ListSep));
        this->listy_entries(noad);
        --deep;;
        return noad;
    }

    desires = &desirables[L"moar_listy_entries -> Newline"];
    // moar_listy_entries -> Newline
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Newline", toker->burn(ESkoarToke::Newline));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::nouny_literal(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"nouny_literal -> Tuplet"];
    // nouny_literal -> Tuplet
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Tuplet", toker->burn(ESkoarToke::Tuplet));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Caesura"];
    // nouny_literal -> Caesura
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Caesura", toker->burn(ESkoarToke::Caesura));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Freq"];
    // nouny_literal -> Freq
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Freq", toker->burn(ESkoarToke::Freq));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Int"];
    // nouny_literal -> Int
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Int", toker->burn(ESkoarToke::Int));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Float"];
    // nouny_literal -> Float
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Float", toker->burn(ESkoarToke::Float));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> String"];
    // nouny_literal -> String
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_String", toker->burn(ESkoarToke::String));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Choard"];
    // nouny_literal -> Choard
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Choard", toker->burn(ESkoarToke::Choard));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> NamedNoat"];
    // nouny_literal -> NamedNoat
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_NamedNoat", toker->burn(ESkoarToke::NamedNoat));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Symbol"];
    // nouny_literal -> Symbol
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Symbol", toker->burn(ESkoarToke::Symbol));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Fairy"];
    // nouny_literal -> Fairy
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Fairy", toker->burn(ESkoarToke::Fairy));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> HashLevel"];
    // nouny_literal -> HashLevel
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_HashLevel", toker->burn(ESkoarToke::HashLevel));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> False"];
    // nouny_literal -> False
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_False", toker->burn(ESkoarToke::False));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> True"];
    // nouny_literal -> True
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_True", toker->burn(ESkoarToke::True));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny_literal -> Crap"];
    // nouny_literal -> Crap
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Crap", toker->burn(ESkoarToke::Crap));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::settable(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"settable -> Caesura"];
    // settable -> Caesura
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Caesura", toker->burn(ESkoarToke::Caesura));
        --deep;;
        return noad;
    }

    desires = &desirables[L"settable -> Symbol"];
    // settable -> Symbol
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Symbol", toker->burn(ESkoarToke::Symbol));
        --deep;;
        return noad;
    }

    desires = &desirables[L"settable -> listy"];
    // settable -> listy
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->listy(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"settable -> Quarters"];
    // settable -> Quarters
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Quarters", toker->burn(ESkoarToke::Quarters));
        --deep;;
        return noad;
    }

    desires = &desirables[L"settable -> Eighths"];
    // settable -> Eighths
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Eighths", toker->burn(ESkoarToke::Eighths));
        --deep;;
        return noad;
    }

    desires = &desirables[L"settable -> Fairy"];
    // settable -> Fairy
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Fairy", toker->burn(ESkoarToke::Fairy));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::msg_chain_node(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"msg_chain_node -> MsgOp msg msg_chain_node"];
    // msg_chain_node -> MsgOp msg msg_chain_node
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_MsgOp", toker->burn(ESkoarToke::MsgOp));
        noad->add_noad(this->msg(noad));
        this->msg_chain_node(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::branches(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"branches -> branch branches"];
    // branches -> branch branches
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->branch(noad));
        this->branches(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::cond_else(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"cond_else -> CondIf if_body"];
    // cond_else -> CondIf if_body
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_CondIf", toker->burn(ESkoarToke::CondIf));
        noad->add_noad(this->if_body(noad));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::musical_keyword(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"musical_keyword"), ESkoarNoad::musical_keyword, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"musical_keyword -> dynamic"];
    // musical_keyword -> dynamic
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->dynamic(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"musical_keyword -> ottavas"];
    // musical_keyword -> ottavas
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->ottavas(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"musical_keyword -> pedally"];
    // musical_keyword -> pedally
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->pedally(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"musical_keyword -> musical_keyword_misc"];
    // musical_keyword -> musical_keyword_misc
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->musical_keyword_misc(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::msg(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"msg"), ESkoarNoad::msg, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"msg -> MsgNameWithArgs listy_suffix"];
    // msg -> MsgNameWithArgs listy_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_MsgNameWithArgs", toker->burn(ESkoarToke::MsgNameWithArgs));
        this->listy_suffix(noad);
        --deep;;
        return noad;
    }

    desires = &desirables[L"msg -> MsgName"];
    // msg -> MsgName
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_MsgName", toker->burn(ESkoarToke::MsgName));
        --deep;;
        return noad;
    }

    desires = &desirables[L"msg -> listy"];
    // msg -> listy
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->listy(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"msg -> loop"];
    // msg -> loop
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->loop(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::loop_body(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"loop_body"), ESkoarNoad::loop_body, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"loop_body -> phrases"];
    // loop_body -> phrases
    if (toker->sees(desires) != nullptr) {
        this->phrases(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::coda(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"coda"), ESkoarNoad::coda, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"coda -> Coda optional_al_coda"];
    // coda -> Coda optional_al_coda
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Coda", toker->burn(ESkoarToke::Coda));
        noad->add_noad(this->optional_al_coda(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::beat(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"beat"), ESkoarNoad::beat, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"beat -> Crotchets"];
    // beat -> Crotchets
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Crotchets", toker->burn(ESkoarToke::Crotchets));
        --deep;;
        return noad;
    }

    desires = &desirables[L"beat -> Quavers"];
    // beat -> Quavers
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Quavers", toker->burn(ESkoarToke::Quavers));
        --deep;;
        return noad;
    }

    desires = &desirables[L"beat -> Quarters"];
    // beat -> Quarters
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Quarters", toker->burn(ESkoarToke::Quarters));
        --deep;;
        return noad;
    }

    desires = &desirables[L"beat -> Eighths"];
    // beat -> Eighths
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Eighths", toker->burn(ESkoarToke::Eighths));
        --deep;;
        return noad;
    }

    desires = &desirables[L"beat -> Slash"];
    // beat -> Slash
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Slash", toker->burn(ESkoarToke::Slash));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::pedally(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"pedally"), ESkoarNoad::pedally, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"pedally -> PedalDown"];
    // pedally -> PedalDown
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_PedalDown", toker->burn(ESkoarToke::PedalDown));
        --deep;;
        return noad;
    }

    desires = &desirables[L"pedally -> PedalUp"];
    // pedally -> PedalUp
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_PedalUp", toker->burn(ESkoarToke::PedalUp));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cthulhu(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"cthulhu"), ESkoarNoad::cthulhu, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"cthulhu -> LWing Semicolon cthulhu_prime"];
    // cthulhu -> LWing Semicolon cthulhu_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_LWing", toker->burn(ESkoarToke::LWing));
        noad->add_toke(L"Toke_Semicolon", toker->burn(ESkoarToke::Semicolon));
        this->cthulhu_prime(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::nouny(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"nouny"), ESkoarNoad::nouny, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"nouny -> cthulhu"];
    // nouny -> cthulhu
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->cthulhu(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny -> conditional"];
    // nouny -> conditional
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->conditional(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny -> loop"];
    // nouny -> loop
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->loop(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny -> nouny_literal"];
    // nouny -> nouny_literal
    if (toker->sees(desires) != nullptr) {
        this->nouny_literal(noad);
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny -> musical_keyword"];
    // nouny -> musical_keyword
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->musical_keyword(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny -> listy"];
    // nouny -> listy
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->listy(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny -> deref"];
    // nouny -> deref
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->deref(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"nouny -> skoarpion"];
    // nouny -> skoarpion
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->skoarpion(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::deref(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"deref"), ESkoarNoad::deref, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"deref -> Deref deref_prime"];
    // deref -> Deref deref_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Deref", toker->burn(ESkoarToke::Deref));
        this->deref_prime(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::math(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"math"), ESkoarNoad::math, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"math -> MathOp msgable"];
    // math -> MathOp msgable
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_MathOp", toker->burn(ESkoarToke::MathOp));
        noad->add_noad(this->msgable(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::al_x(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"al_x"), ESkoarNoad::al_x, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"al_x -> AlCoda"];
    // al_x -> AlCoda
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_AlCoda", toker->burn(ESkoarToke::AlCoda));
        --deep;;
        return noad;
    }

    desires = &desirables[L"al_x -> AlSegno"];
    // al_x -> AlSegno
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_AlSegno", toker->burn(ESkoarToke::AlSegno));
        --deep;;
        return noad;
    }

    desires = &desirables[L"al_x -> AlFine"];
    // al_x -> AlFine
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_AlFine", toker->burn(ESkoarToke::AlFine));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::listy(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"listy"), ESkoarNoad::listy, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"listy -> ListS listy_suffix"];
    // listy -> ListS listy_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_ListS", toker->burn(ESkoarToke::ListS));
        this->listy_suffix(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::dal_goto(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"dal_goto"), ESkoarNoad::dal_goto, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"dal_goto -> DaCapo al_x"];
    // dal_goto -> DaCapo al_x
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_DaCapo", toker->burn(ESkoarToke::DaCapo));
        noad->add_noad(this->al_x(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"dal_goto -> DalSegno al_x"];
    // dal_goto -> DalSegno al_x
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_DalSegno", toker->burn(ESkoarToke::DalSegno));
        noad->add_noad(this->al_x(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::branch(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"branch"), ESkoarNoad::branch, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"branch -> optional_voice phrases Newline"];
    // branch -> optional_voice phrases Newline
    if (toker->sees(desires) != nullptr) {
        this->optional_voice(noad);
        this->phrases(noad);
        noad->add_toke(L"Toke_Newline", toker->burn(ESkoarToke::Newline));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::loop_condition(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"loop_condition"), ESkoarNoad::loop_condition, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"loop_condition -> LoopSep expr"];
    // loop_condition -> LoopSep expr
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_LoopSep", toker->burn(ESkoarToke::LoopSep));
        noad->add_noad(this->expr(noad));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::optional_voice(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"optional_voice -> Voice"];
    // optional_voice -> Voice
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Voice", toker->burn(ESkoarToke::Voice));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::cthulhu_prime(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"cthulhu_prime -> expr Semicolon RWing"];
    // cthulhu_prime -> expr Semicolon RWing
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->expr(noad));
        noad->add_toke(L"Toke_Semicolon", toker->burn(ESkoarToke::Semicolon));
        noad->add_toke(L"Toke_RWing", toker->burn(ESkoarToke::RWing));
        --deep;;
        return noad;
    }

    desires = &desirables[L"cthulhu_prime -> Nosey Semicolon RWing"];
    // cthulhu_prime -> Nosey Semicolon RWing
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Nosey", toker->burn(ESkoarToke::Nosey));
        noad->add_toke(L"Toke_Semicolon", toker->burn(ESkoarToke::Semicolon));
        noad->add_toke(L"Toke_RWing", toker->burn(ESkoarToke::RWing));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cond_ifs(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"cond_ifs -> cond_if cond_ifs_suffix"];
    // cond_ifs -> cond_if cond_ifs_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->cond_if(noad));
        this->cond_ifs_suffix(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::boolean(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"boolean"), ESkoarNoad::boolean, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"boolean -> BooleanOp expr"];
    // boolean -> BooleanOp expr
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_BooleanOp", toker->burn(ESkoarToke::BooleanOp));
        noad->add_noad(this->expr(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::opt_arg_spec(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"opt_arg_spec"), ESkoarNoad::opt_arg_spec, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"opt_arg_spec -> ArgSpec"];
    // opt_arg_spec -> ArgSpec
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_ArgSpec", toker->burn(ESkoarToke::ArgSpec));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::skoarpion(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"skoarpion"), ESkoarNoad::skoarpion, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"skoarpion -> SkoarpionStart skrp_sig skrp_suffix"];
    // skoarpion -> SkoarpionStart skrp_sig skrp_suffix
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_SkoarpionStart", toker->burn(ESkoarToke::SkoarpionStart));
        noad->add_noad(this->skrp_sig(noad));
        noad->add_noad(this->skrp_suffix(noad));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::cond_ifs_suffix(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"cond_ifs_suffix -> Newline cond_ifs"];
    // cond_ifs_suffix -> Newline cond_ifs
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Newline", toker->burn(ESkoarToke::Newline));
        this->cond_ifs(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::phrases(SkoarNoad* parent) {
    SkoarNoad* noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"phrases -> phrasey phrases"];
    // phrases -> phrasey phrases
    if (toker->sees(desires) != nullptr) {
        this->phrasey(noad);
        this->phrases(noad);
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::if_body(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"if_body"), ESkoarNoad::if_body, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"if_body -> phrases"];
    // if_body -> phrases
    if (toker->sees(desires) != nullptr) {
        this->phrases(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::marker(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"marker"), ESkoarNoad::marker, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"marker -> Segno"];
    // marker -> Segno
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Segno", toker->burn(ESkoarToke::Segno));
        --deep;;
        return noad;
    }

    desires = &desirables[L"marker -> Fine"];
    // marker -> Fine
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Fine", toker->burn(ESkoarToke::Fine));
        --deep;;
        return noad;
    }

    desires = &desirables[L"marker -> coda"];
    // marker -> coda
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->coda(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"marker -> Volta"];
    // marker -> Volta
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Volta", toker->burn(ESkoarToke::Volta));
        --deep;;
        return noad;
    }

    desires = &desirables[L"marker -> Bars"];
    // marker -> Bars
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_Bars", toker->burn(ESkoarToke::Bars));
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::expr_prime(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"expr_prime"), ESkoarNoad::expr_prime, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"expr_prime -> assignment expr_prime"];
    // expr_prime -> assignment expr_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->assignment(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"expr_prime -> math expr_prime"];
    // expr_prime -> math expr_prime
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->math(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"expr_prime -> boolean"];
    // expr_prime -> boolean
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->boolean(noad));
        --deep;;
        return noad;
    }

    desires = &desirables[L"expr_prime -> times"];
    // expr_prime -> times
    if (toker->sees(desires) != nullptr) {
        noad->add_noad(this->times(noad));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoad* SkoarParser::cond_if(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"cond_if"), ESkoarNoad::cond_if, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"cond_if -> optional_voice expr CondIf if_body cond_else"];
    // cond_if -> optional_voice expr CondIf if_body cond_else
    if (toker->sees(desires) != nullptr) {
        this->optional_voice(noad);
        noad->add_noad(this->expr(noad));
        noad->add_toke(L"Toke_CondIf", toker->burn(ESkoarToke::CondIf));
        noad->add_noad(this->if_body(noad));
        this->cond_else(noad);
        --deep;;
        return noad;
    }

    // Error State
    this->fail();
    return nullptr;
}

SkoarNoad* SkoarParser::optional_al_coda(SkoarNoad* parent) {
    SkoarNoad* noad = new SkoarNoad(wstring(L"optional_al_coda"), ESkoarNoad::optional_al_coda, parent);;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 100) {
        this->fail_too_deep();
    }

    desires = &desirables[L"optional_al_coda -> AlCoda"];
    // optional_al_coda -> AlCoda
    if (toker->sees(desires) != nullptr) {
        noad->add_toke(L"Toke_AlCoda", toker->burn(ESkoarToke::AlCoda));
        --deep;;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

