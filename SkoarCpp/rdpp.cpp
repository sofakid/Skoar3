// =====================================================================================================================
// rdpp.cpp - Generated by Code_Parser_Cpp - Create Recursive Descent Predictive Parser on 2017-03-25 21:12:36 for C++14
// =====================================================================================================================
#include "rdpp.hpp"
#include "exception.hpp"
#include "lex.hpp"
#include "noad.hpp"

void SkoarParser::fail(SkoarNoadPtr noad) {
    toker->dump();
    throw SkoarParseException(L"Fail", noad);
}

void SkoarParser::fail_too_deep(SkoarNoadPtr noad) {
    toker->dump();
    throw SkoarParseException(L"Parse tree too deep!", noad);
}

void SkoarParser::toker_fail(SkoarError& e, SkoarNoadPtr noad) {
    toker->dump();
    throw SkoarParseException(e.wwhat(), noad);
}

 SkoarParser::SkoarParser(SkoarToker * tokr) {

    deep = 0;
    toker = tokr;
    
}

 SkoarStats::SkoarStats() {
    tokeFreq[ESkoarToke::AUGen] = 0.0f;
    tokeFreq[ESkoarToke::AUGenWithArgs] = 0.0f;
    tokeFreq[ESkoarToke::AlCoda] = 0.0f;
    tokeFreq[ESkoarToke::AlFine] = 0.0f;
    tokeFreq[ESkoarToke::AlSegno] = 0.0f;
    tokeFreq[ESkoarToke::AssOp] = 0.0f;
    tokeFreq[ESkoarToke::Bars] = 0.0f;
    tokeFreq[ESkoarToke::BooleanOp] = 0.0f;
    tokeFreq[ESkoarToke::Carrot] = 0.0f;
    tokeFreq[ESkoarToke::Cat] = 0.0f;
    tokeFreq[ESkoarToke::Choard] = 0.0f;
    tokeFreq[ESkoarToke::Coda] = 0.0f;
    tokeFreq[ESkoarToke::Comment] = 0.0f;
    tokeFreq[ESkoarToke::CondE] = 0.0f;
    tokeFreq[ESkoarToke::CondIf] = 0.0f;
    tokeFreq[ESkoarToke::CondS] = 0.0f;
    tokeFreq[ESkoarToke::Crotchets] = 0.0f;
    tokeFreq[ESkoarToke::DUGen] = 0.0f;
    tokeFreq[ESkoarToke::DUGenWithArgs] = 0.0f;
    tokeFreq[ESkoarToke::DaCapo] = 0.0f;
    tokeFreq[ESkoarToke::DalSegno] = 0.0f;
    tokeFreq[ESkoarToke::Deref] = 0.0f;
    tokeFreq[ESkoarToke::Duration] = 0.0f;
    tokeFreq[ESkoarToke::DynFP] = 0.0f;
    tokeFreq[ESkoarToke::DynForte] = 0.0f;
    tokeFreq[ESkoarToke::DynPiano] = 0.0f;
    tokeFreq[ESkoarToke::DynSFZ] = 0.0f;
    tokeFreq[ESkoarToke::Eighths] = 0.0f;
    tokeFreq[ESkoarToke::ExactBeat] = 0.0f;
    tokeFreq[ESkoarToke::ExactRest] = 0.0f;
    tokeFreq[ESkoarToke::Fairy] = 0.0f;
    tokeFreq[ESkoarToke::False] = 0.0f;
    tokeFreq[ESkoarToke::Fine] = 0.0f;
    tokeFreq[ESkoarToke::Float] = 0.0f;
    tokeFreq[ESkoarToke::Freq] = 0.0f;
    tokeFreq[ESkoarToke::HashLevel] = 0.0f;
    tokeFreq[ESkoarToke::Int] = 0.0f;
    tokeFreq[ESkoarToke::KUGen] = 0.0f;
    tokeFreq[ESkoarToke::KUGenWithArgs] = 0.0f;
    tokeFreq[ESkoarToke::LWing] = 0.0f;
    tokeFreq[ESkoarToke::ListE] = 0.0f;
    tokeFreq[ESkoarToke::ListS] = 0.0f;
    tokeFreq[ESkoarToke::ListSep] = 0.0f;
    tokeFreq[ESkoarToke::Loco] = 0.0f;
    tokeFreq[ESkoarToke::LoopE] = 0.0f;
    tokeFreq[ESkoarToke::LoopS] = 0.0f;
    tokeFreq[ESkoarToke::LoopSep] = 0.0f;
    tokeFreq[ESkoarToke::Lute] = 0.0f;
    tokeFreq[ESkoarToke::LuteWithArgs] = 0.0f;
    tokeFreq[ESkoarToke::MathOp] = 0.0f;
    tokeFreq[ESkoarToke::MeditationE] = 0.0f;
    tokeFreq[ESkoarToke::MeditationS] = 0.0f;
    tokeFreq[ESkoarToke::MsgName] = 0.0f;
    tokeFreq[ESkoarToke::MsgNameWithArgs] = 0.0f;
    tokeFreq[ESkoarToke::MsgOp] = 0.0f;
    tokeFreq[ESkoarToke::NamedNoat] = 0.0f;
    tokeFreq[ESkoarToke::Newline] = 0.0f;
    tokeFreq[ESkoarToke::Nosey] = 0.0f;
    tokeFreq[ESkoarToke::OctaveShift] = 0.0f;
    tokeFreq[ESkoarToke::OttavaA] = 0.0f;
    tokeFreq[ESkoarToke::OttavaB] = 0.0f;
    tokeFreq[ESkoarToke::Quarters] = 0.0f;
    tokeFreq[ESkoarToke::Quavers] = 0.0f;
    tokeFreq[ESkoarToke::QuindicesimaA] = 0.0f;
    tokeFreq[ESkoarToke::QuindicesimaB] = 0.0f;
    tokeFreq[ESkoarToke::RWing] = 0.0f;
    tokeFreq[ESkoarToke::Segno] = 0.0f;
    tokeFreq[ESkoarToke::Semicolon] = 0.0f;
    tokeFreq[ESkoarToke::SkoarpionEnd] = 0.0f;
    tokeFreq[ESkoarToke::SkoarpionSep] = 0.0f;
    tokeFreq[ESkoarToke::SkoarpionStart] = 0.0f;
    tokeFreq[ESkoarToke::SkoarpionStartWithSig] = 0.0f;
    tokeFreq[ESkoarToke::String] = 0.0f;
    tokeFreq[ESkoarToke::Symbol] = 0.0f;
    tokeFreq[ESkoarToke::SymbolColon] = 0.0f;
    tokeFreq[ESkoarToke::SymbolName] = 0.0f;
    tokeFreq[ESkoarToke::Times] = 0.0f;
    tokeFreq[ESkoarToke::True] = 0.0f;
    tokeFreq[ESkoarToke::Tuplet] = 0.0f;
    tokeFreq[ESkoarToke::Voice] = 0.0f;

    desirables = new list<ESkoarToke::Kind>[146];

    // branches
    desirables[0] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::Voice, ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen,
                      ESkoarToke::DalSegno, ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS,
                      ESkoarToke::Lute, ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String,
                      ESkoarToke::DynPiano, ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS,
                      ESkoarToke::Duration, ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs,
                      ESkoarToke::Deref, ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::SymbolColon,
                      ESkoarToke::OttavaB, ESkoarToke::Comment, ESkoarToke::Fairy, ESkoarToke::Coda,
                      ESkoarToke::Freq, ESkoarToke::Newline, ESkoarToke::Tuplet, ESkoarToke::Quarters,
                      ESkoarToke::Carrot, ESkoarToke::Bars, ESkoarToke::Crotchets, ESkoarToke::LWing,
                      ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA,
                      ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::Eighths, ESkoarToke::DaCapo,
                      ESkoarToke::NamedNoat};

    // skoar
    desirables[1] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::Voice, ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen,
                      ESkoarToke::DalSegno, ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS,
                      ESkoarToke::Lute, ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String,
                      ESkoarToke::DynPiano, ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS,
                      ESkoarToke::Duration, ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs,
                      ESkoarToke::Deref, ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::SymbolColon,
                      ESkoarToke::OttavaB, ESkoarToke::Comment, ESkoarToke::Fairy, ESkoarToke::Coda,
                      ESkoarToke::Freq, ESkoarToke::Newline, ESkoarToke::Tuplet, ESkoarToke::Quarters,
                      ESkoarToke::Carrot, ESkoarToke::Bars, ESkoarToke::Crotchets, ESkoarToke::LWing,
                      ESkoarToke::Eof, ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int,
                      ESkoarToke::OttavaA, ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::Eighths,
                      ESkoarToke::DaCapo, ESkoarToke::NamedNoat};

    // branch
    desirables[2] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::Voice, ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen,
                      ESkoarToke::DalSegno, ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS,
                      ESkoarToke::Lute, ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String,
                      ESkoarToke::DynPiano, ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS,
                      ESkoarToke::Duration, ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs,
                      ESkoarToke::Deref, ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::SymbolColon,
                      ESkoarToke::OttavaB, ESkoarToke::Comment, ESkoarToke::Fairy, ESkoarToke::Coda,
                      ESkoarToke::Freq, ESkoarToke::Newline, ESkoarToke::Tuplet, ESkoarToke::Quarters,
                      ESkoarToke::Carrot, ESkoarToke::Bars, ESkoarToke::Crotchets, ESkoarToke::LWing,
                      ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA,
                      ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::Eighths, ESkoarToke::DaCapo,
                      ESkoarToke::NamedNoat};

    // opt_voiced_phrases
    desirables[3] = {ESkoarToke::Voice};
    desirables[4] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA, ESkoarToke::DUGen,
                      ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen, ESkoarToke::DalSegno,
                      ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute,
                      ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano,
                      ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration,
                      ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref,
                      ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::MeditationE, ESkoarToke::SymbolColon,
                      ESkoarToke::OttavaB, ESkoarToke::SkoarpionEnd, ESkoarToke::Comment, ESkoarToke::Fairy,
                      ESkoarToke::Coda, ESkoarToke::Freq, ESkoarToke::Newline, ESkoarToke::Tuplet,
                      ESkoarToke::Quarters, ESkoarToke::Carrot, ESkoarToke::Bars, ESkoarToke::Crotchets,
                      ESkoarToke::LWing, ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int,
                      ESkoarToke::OttavaA, ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::Eighths,
                      ESkoarToke::DaCapo, ESkoarToke::NamedNoat};

    // phrases
    desirables[5] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA, ESkoarToke::DUGen,
                      ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen, ESkoarToke::DalSegno,
                      ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute,
                      ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano,
                      ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration,
                      ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref,
                      ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::SymbolColon, ESkoarToke::OttavaB,
                      ESkoarToke::Comment, ESkoarToke::Fairy, ESkoarToke::Coda, ESkoarToke::Freq,
                      ESkoarToke::Tuplet, ESkoarToke::Quarters, ESkoarToke::Carrot, ESkoarToke::Bars,
                      ESkoarToke::Crotchets, ESkoarToke::LWing, ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart,
                      ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS, ESkoarToke::AUGen,
                      ESkoarToke::Eighths, ESkoarToke::DaCapo, ESkoarToke::NamedNoat};

    // optional_voice
    desirables[6] = {ESkoarToke::Voice};

    // phrasey
    desirables[7] = {ESkoarToke::Comment};
    desirables[8] = {ESkoarToke::Segno, ESkoarToke::Fine, ESkoarToke::Coda, ESkoarToke::Bars};
    desirables[9] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq,
                      ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel,
                      ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS,
                      ESkoarToke::AUGen, ESkoarToke::NamedNoat};
    desirables[10] = {ESkoarToke::DaCapo, ESkoarToke::DalSegno};
    desirables[11] = {ESkoarToke::ExactRest, ESkoarToke::ExactBeat, ESkoarToke::Quavers, ESkoarToke::Eighths,
                      ESkoarToke::Crotchets, ESkoarToke::Quarters};

    // marker
    desirables[12] = {ESkoarToke::Segno};
    desirables[13] = {ESkoarToke::Fine};
    desirables[14] = {ESkoarToke::Coda};
    desirables[15] = {ESkoarToke::Bars};

    // expr
    desirables[16] = {ESkoarToke::SymbolColon};
    desirables[17] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq, ESkoarToke::Tuplet,
                      ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart,
                      ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS, ESkoarToke::AUGen,
                      ESkoarToke::NamedNoat};

    // dal_goto
    desirables[18] = {ESkoarToke::DaCapo};
    desirables[19] = {ESkoarToke::DalSegno};

    // beat
    desirables[20] = {ESkoarToke::Crotchets, ESkoarToke::Quavers, ESkoarToke::Quarters, ESkoarToke::Eighths};
    desirables[21] = {ESkoarToke::ExactBeat};
    desirables[22] = {ESkoarToke::ExactRest};

    // skrp_sig
    desirables[23] = {ESkoarToke::SymbolName};
    desirables[24] = {ESkoarToke::ListS};

    // skrp_suffix
    desirables[25] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::Voice, ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen,
                      ESkoarToke::DalSegno, ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS,
                      ESkoarToke::Lute, ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String,
                      ESkoarToke::DynPiano, ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS,
                      ESkoarToke::Duration, ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs,
                      ESkoarToke::Deref, ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::SymbolColon,
                      ESkoarToke::OttavaB, ESkoarToke::SkoarpionEnd, ESkoarToke::Comment, ESkoarToke::Fairy,
                      ESkoarToke::Coda, ESkoarToke::Freq, ESkoarToke::Newline, ESkoarToke::Tuplet,
                      ESkoarToke::Quarters, ESkoarToke::Carrot, ESkoarToke::Bars, ESkoarToke::Crotchets,
                      ESkoarToke::LWing, ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int,
                      ESkoarToke::OttavaA, ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::Eighths,
                      ESkoarToke::DaCapo, ESkoarToke::NamedNoat};

    // skoarpion
    desirables[26] = {ESkoarToke::SkoarpionStartWithSig};
    desirables[27] = {ESkoarToke::SkoarpionStart};

    // skrp_sig_prime
    desirables[28] = {ESkoarToke::SkoarpionSep};
    desirables[29] = {ESkoarToke::ListS};

    // arg_listy
    desirables[30] = {ESkoarToke::ListS};

    // skrp_lines
    desirables[31] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::Voice, ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen,
                      ESkoarToke::DalSegno, ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS,
                      ESkoarToke::Lute, ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String,
                      ESkoarToke::DynPiano, ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS,
                      ESkoarToke::Duration, ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs,
                      ESkoarToke::Deref, ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::MeditationE,
                      ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::SkoarpionEnd, ESkoarToke::Comment,
                      ESkoarToke::Fairy, ESkoarToke::Coda, ESkoarToke::Freq, ESkoarToke::Newline,
                      ESkoarToke::Tuplet, ESkoarToke::Quarters, ESkoarToke::Carrot, ESkoarToke::Bars,
                      ESkoarToke::Crotchets, ESkoarToke::LWing, ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart,
                      ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS, ESkoarToke::AUGen,
                      ESkoarToke::Eighths, ESkoarToke::DaCapo, ESkoarToke::NamedNoat};

    // skrp_moar_lines
    desirables[32] = {ESkoarToke::Newline};

    // listy_suffix
    desirables[33] = {ESkoarToke::Newline};
    desirables[34] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq,
                      ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel,
                      ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS,
                      ESkoarToke::AUGen, ESkoarToke::NamedNoat};
    desirables[35] = {ESkoarToke::ListE};

    // listy
    desirables[36] = {ESkoarToke::ListS};

    // listy_entries
    desirables[37] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq,
                      ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel,
                      ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS,
                      ESkoarToke::AUGen, ESkoarToke::NamedNoat};

    // moar_listy_entries
    desirables[38] = {ESkoarToke::ListSep};
    desirables[39] = {ESkoarToke::Newline};
    desirables[40] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq,
                      ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel,
                      ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS,
                      ESkoarToke::AUGen, ESkoarToke::NamedNoat};

    // arg_listy_suffix
    desirables[41] = {ESkoarToke::Newline};
    desirables[42] = {ESkoarToke::SymbolName, ESkoarToke::SymbolColon};
    desirables[43] = {ESkoarToke::ListE};

    // arg_listy_entries
    desirables[44] = {ESkoarToke::SymbolName, ESkoarToke::SymbolColon};

    // arg_expr
    desirables[45] = {ESkoarToke::SymbolName};
    desirables[46] = {ESkoarToke::SymbolColon};

    // moar_arg_listy_entries
    desirables[47] = {ESkoarToke::ListSep};
    desirables[48] = {ESkoarToke::Newline};
    desirables[49] = {ESkoarToke::SymbolName, ESkoarToke::SymbolColon};

    // coda
    desirables[50] = {ESkoarToke::Coda};

    // optional_al_coda
    desirables[51] = {ESkoarToke::AlCoda};

    // al_x
    desirables[52] = {ESkoarToke::AlCoda};
    desirables[53] = {ESkoarToke::AlSegno};
    desirables[54] = {ESkoarToke::AlFine};

    // regular_beat
    desirables[55] = {ESkoarToke::Crotchets};
    desirables[56] = {ESkoarToke::Quavers};
    desirables[57] = {ESkoarToke::Quarters};
    desirables[58] = {ESkoarToke::Eighths};

    // exact_beat
    desirables[59] = {ESkoarToke::ExactBeat};

    // exact_rest
    desirables[60] = {ESkoarToke::ExactRest};

    // dynamic
    desirables[61] = {ESkoarToke::DynPiano};
    desirables[62] = {ESkoarToke::DynForte};
    desirables[63] = {ESkoarToke::DynSFZ};
    desirables[64] = {ESkoarToke::DynFP};

    // musical_keyword
    desirables[65] = {ESkoarToke::DynForte, ESkoarToke::DynSFZ, ESkoarToke::DynPiano, ESkoarToke::DynFP};
    desirables[66] = {ESkoarToke::OctaveShift, ESkoarToke::OttavaA, ESkoarToke::Loco, ESkoarToke::OttavaB,
                      ESkoarToke::QuindicesimaB, ESkoarToke::QuindicesimaA};
    desirables[67] = {ESkoarToke::Carrot};

    // ottavas
    desirables[68] = {ESkoarToke::OctaveShift};
    desirables[69] = {ESkoarToke::OttavaA};
    desirables[70] = {ESkoarToke::OttavaB};
    desirables[71] = {ESkoarToke::QuindicesimaA};
    desirables[72] = {ESkoarToke::QuindicesimaB};
    desirables[73] = {ESkoarToke::Loco};

    // musical_keyword_misc
    desirables[74] = {ESkoarToke::Carrot};

    // cthulhu
    desirables[75] = {ESkoarToke::LWing};

    // nouny
    desirables[76] = {ESkoarToke::LWing};
    desirables[77] = {ESkoarToke::MeditationS};
    desirables[78] = {ESkoarToke::CondS};
    desirables[79] = {ESkoarToke::LoopS};
    desirables[80] = {ESkoarToke::LuteWithArgs, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs, ESkoarToke::Fairy,
                      ESkoarToke::Symbol, ESkoarToke::Freq, ESkoarToke::Tuplet, ESkoarToke::DUGen,
                      ESkoarToke::KUGen, ESkoarToke::Float, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::String, ESkoarToke::HashLevel, ESkoarToke::True, ESkoarToke::Duration,
                      ESkoarToke::Int, ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs,
                      ESkoarToke::AUGen, ESkoarToke::NamedNoat};
    desirables[81] = {ESkoarToke::Carrot, ESkoarToke::OctaveShift, ESkoarToke::DynSFZ, ESkoarToke::Loco,
                      ESkoarToke::DynFP, ESkoarToke::OttavaB, ESkoarToke::QuindicesimaB, ESkoarToke::DynPiano,
                      ESkoarToke::DynForte, ESkoarToke::OttavaA, ESkoarToke::QuindicesimaA};
    desirables[82] = {ESkoarToke::ListS};
    desirables[83] = {ESkoarToke::Deref};
    desirables[84] = {ESkoarToke::SkoarpionStartWithSig, ESkoarToke::SkoarpionStart};

    // meditation
    desirables[85] = {ESkoarToke::MeditationS};

    // conditional
    desirables[86] = {ESkoarToke::CondS};

    // loop
    desirables[87] = {ESkoarToke::LoopS};

    // nouny_literal
    desirables[88] = {ESkoarToke::Duration};
    desirables[89] = {ESkoarToke::DUGen, ESkoarToke::KUGen, ESkoarToke::AUGenWithArgs, ESkoarToke::AUGen,
                      ESkoarToke::DUGenWithArgs, ESkoarToke::KUGenWithArgs};
    desirables[90] = {ESkoarToke::Tuplet};
    desirables[91] = {ESkoarToke::Freq};
    desirables[92] = {ESkoarToke::Int};
    desirables[93] = {ESkoarToke::Float};
    desirables[94] = {ESkoarToke::String};
    desirables[95] = {ESkoarToke::Choard};
    desirables[96] = {ESkoarToke::NamedNoat};
    desirables[97] = {ESkoarToke::Symbol};
    desirables[98] = {ESkoarToke::Fairy};
    desirables[99] = {ESkoarToke::HashLevel};
    desirables[100] = {ESkoarToke::False};
    desirables[101] = {ESkoarToke::True};
    desirables[102] = {ESkoarToke::Cat};
    desirables[103] = {ESkoarToke::LuteWithArgs, ESkoarToke::Lute};

    // deref
    desirables[104] = {ESkoarToke::Deref};

    // ugen
    desirables[105] = {ESkoarToke::KUGenWithArgs, ESkoarToke::AUGenWithArgs, ESkoarToke::DUGenWithArgs};
    desirables[106] = {ESkoarToke::KUGen, ESkoarToke::DUGen, ESkoarToke::AUGen};

    // lute
    desirables[107] = {ESkoarToke::Lute};
    desirables[108] = {ESkoarToke::LuteWithArgs};

    // deref_prime
    desirables[109] = {ESkoarToke::MsgNameWithArgs};
    desirables[110] = {ESkoarToke::MsgName};

    // msgable
    desirables[111] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq, ESkoarToke::Tuplet,
                      ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart,
                      ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS, ESkoarToke::AUGen,
                      ESkoarToke::NamedNoat};

    // expr_prime
    desirables[112] = {ESkoarToke::AssOp};
    desirables[113] = {ESkoarToke::MathOp};
    desirables[114] = {ESkoarToke::BooleanOp};
    desirables[115] = {ESkoarToke::Times};

    // assignment
    desirables[116] = {ESkoarToke::AssOp};

    // math
    desirables[117] = {ESkoarToke::MathOp};

    // boolean
    desirables[118] = {ESkoarToke::BooleanOp};

    // times
    desirables[119] = {ESkoarToke::Times};

    // boolean_expr
    desirables[120] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq,
                      ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel,
                      ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS,
                      ESkoarToke::AUGen, ESkoarToke::NamedNoat};

    // settable
    desirables[121] = {ESkoarToke::Symbol};
    desirables[122] = {ESkoarToke::ListS};
    desirables[123] = {ESkoarToke::Quarters};
    desirables[124] = {ESkoarToke::Eighths};
    desirables[125] = {ESkoarToke::Fairy};

    // msg_chain_node
    desirables[126] = {ESkoarToke::MsgOp};

    // msg
    desirables[127] = {ESkoarToke::MsgNameWithArgs};
    desirables[128] = {ESkoarToke::MsgName};
    desirables[129] = {ESkoarToke::ListS};
    desirables[130] = {ESkoarToke::LoopS};

    // cthulhu_prime
    desirables[131] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::MeditationS, ESkoarToke::QuindicesimaA,
                      ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen, ESkoarToke::Float,
                      ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute, ESkoarToke::DUGenWithArgs,
                      ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano, ESkoarToke::DynForte,
                      ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration, ESkoarToke::Choard,
                      ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref, ESkoarToke::DynSFZ,
                      ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy, ESkoarToke::Freq,
                      ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing, ESkoarToke::HashLevel,
                      ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA, ESkoarToke::ListS,
                      ESkoarToke::AUGen, ESkoarToke::NamedNoat};
    desirables[132] = {ESkoarToke::Nosey};

    // cond_ifs
    desirables[133] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::Voice, ESkoarToke::MeditationS,
                      ESkoarToke::QuindicesimaA, ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen,
                      ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute,
                      ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano,
                      ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration,
                      ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref,
                      ESkoarToke::DynSFZ, ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy,
                      ESkoarToke::Freq, ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing,
                      ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA,
                      ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::NamedNoat};

    // cond_if
    desirables[134] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::KUGenWithArgs,
                      ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol, ESkoarToke::Voice, ESkoarToke::MeditationS,
                      ESkoarToke::QuindicesimaA, ESkoarToke::DUGen, ESkoarToke::OctaveShift, ESkoarToke::KUGen,
                      ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute,
                      ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano,
                      ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration,
                      ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref,
                      ESkoarToke::DynSFZ, ESkoarToke::SymbolColon, ESkoarToke::OttavaB, ESkoarToke::Fairy,
                      ESkoarToke::Freq, ESkoarToke::Tuplet, ESkoarToke::Carrot, ESkoarToke::LWing,
                      ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA,
                      ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::NamedNoat};

    // cond_ifs_suffix
    desirables[135] = {ESkoarToke::Newline};

    // if_body
    desirables[136] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA, ESkoarToke::DUGen,
                      ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::KUGen, ESkoarToke::DalSegno,
                      ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS, ESkoarToke::Lute,
                      ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String, ESkoarToke::DynPiano,
                      ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS, ESkoarToke::Duration,
                      ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs, ESkoarToke::Deref,
                      ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::SymbolColon, ESkoarToke::OttavaB,
                      ESkoarToke::CondE, ESkoarToke::Comment, ESkoarToke::Fairy, ESkoarToke::Coda,
                      ESkoarToke::Freq, ESkoarToke::Newline, ESkoarToke::Tuplet, ESkoarToke::Quarters,
                      ESkoarToke::Carrot, ESkoarToke::Bars, ESkoarToke::Crotchets, ESkoarToke::LWing,
                      ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA,
                      ESkoarToke::CondIf, ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::Eighths,
                      ESkoarToke::DaCapo, ESkoarToke::NamedNoat};

    // cond_else
    desirables[137] = {ESkoarToke::CondIf};

    // loop_body
    desirables[138] = {ESkoarToke::LuteWithArgs, ESkoarToke::Loco, ESkoarToke::Cat, ESkoarToke::ExactBeat,
                      ESkoarToke::Quavers, ESkoarToke::KUGenWithArgs, ESkoarToke::SkoarpionStartWithSig, ESkoarToke::Symbol,
                      ESkoarToke::MeditationS, ESkoarToke::Segno, ESkoarToke::QuindicesimaA, ESkoarToke::DUGen,
                      ESkoarToke::OctaveShift, ESkoarToke::Fine, ESkoarToke::LoopSep, ESkoarToke::KUGen,
                      ESkoarToke::DalSegno, ESkoarToke::Float, ESkoarToke::DynFP, ESkoarToke::LoopS,
                      ESkoarToke::Lute, ESkoarToke::DUGenWithArgs, ESkoarToke::QuindicesimaB, ESkoarToke::String,
                      ESkoarToke::DynPiano, ESkoarToke::DynForte, ESkoarToke::True, ESkoarToke::CondS,
                      ESkoarToke::Duration, ESkoarToke::Choard, ESkoarToke::False, ESkoarToke::AUGenWithArgs,
                      ESkoarToke::Deref, ESkoarToke::DynSFZ, ESkoarToke::ExactRest, ESkoarToke::SymbolColon,
                      ESkoarToke::OttavaB, ESkoarToke::Comment, ESkoarToke::Fairy, ESkoarToke::Coda,
                      ESkoarToke::LoopE, ESkoarToke::Freq, ESkoarToke::Tuplet, ESkoarToke::Quarters,
                      ESkoarToke::Carrot, ESkoarToke::Bars, ESkoarToke::Crotchets, ESkoarToke::LWing,
                      ESkoarToke::HashLevel, ESkoarToke::SkoarpionStart, ESkoarToke::Int, ESkoarToke::OttavaA,
                      ESkoarToke::ListS, ESkoarToke::AUGen, ESkoarToke::Eighths, ESkoarToke::DaCapo,
                      ESkoarToke::NamedNoat};

    // loop_condition
    desirables[139] = {ESkoarToke::LoopSep};

    // ugen_with_args
    desirables[140] = {ESkoarToke::AUGenWithArgs};
    desirables[141] = {ESkoarToke::KUGenWithArgs};
    desirables[142] = {ESkoarToke::DUGenWithArgs};

    // ugen_simple
    desirables[143] = {ESkoarToke::AUGen};
    desirables[144] = {ESkoarToke::KUGen};
    desirables[145] = {ESkoarToke::DUGen};
}


static SkoarStats* skoarStats = nullptr;

bool localCmp(const ESkoarToke::Kind &a, const ESkoarToke::Kind &b) {
    return skoarStats->tokeFreq[a] > skoarStats->tokeFreq[b]; 
}
    
void localSortDesirables() {
    for (int i = 0; i < 146; ++i) {
        skoarStats->desirables[i].sort(localCmp);    
    }
}



void SkoarParser::init() {
    skoarStats = new SkoarStats();
}

SkoarNoadPtr SkoarParser::branches(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // branches -> branch branches
    desires = &skoarStats->desirables[0];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->branch(noad));
        this->branches(noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::skoar(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::skoar>(wstring(L"skoar"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    try {
        // skoar -> branches
        desires = &skoarStats->desirables[1];
        if (toker->sees(desires) != nullptr) {
            SkoarNoadPtr toke_noad;
            this->branches(noad);
            --deep;
            return noad;
        }

        // Error State
        this->fail(noad);
        return nullptr;

    }
    catch (SkoarError &e) {
        this->toker_fail(e, noad);
    }
    return nullptr;
}

SkoarNoadPtr SkoarParser::branch(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::branch>(wstring(L"branch"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // branch -> opt_voiced_phrases Newline
    desires = &skoarStats->desirables[2];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->opt_voiced_phrases(noad));
        skoarStats->tokeFreq[ESkoarToke::Newline] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Newline"), noad, toker->burn(ESkoarToke::Newline));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::opt_voiced_phrases(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::opt_voiced_phrases>(wstring(L"opt_voiced_phrases"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // opt_voiced_phrases -> Voice phrases
    desires = &skoarStats->desirables[3];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Voice] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Voice"), noad, toker->burn(ESkoarToke::Voice));
        noad->add_noad(toke_noad);
        this->phrases(noad);
        --deep;
        return noad;
    }

    // opt_voiced_phrases -> phrases
    desires = &skoarStats->desirables[4];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->phrases(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::phrases(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // phrases -> phrasey phrases
    desires = &skoarStats->desirables[5];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->phrasey(noad);
        this->phrases(noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::optional_voice(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // optional_voice -> Voice
    desires = &skoarStats->desirables[6];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Voice] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Voice"), noad, toker->burn(ESkoarToke::Voice));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::phrasey(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // phrasey -> Comment
    desires = &skoarStats->desirables[7];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Comment] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Comment"), noad, toker->burn(ESkoarToke::Comment));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // phrasey -> marker
    desires = &skoarStats->desirables[8];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->marker(noad));
        --deep;
        return noad;
    }

    // phrasey -> expr
    desires = &skoarStats->desirables[9];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->expr(noad));
        --deep;
        return noad;
    }

    // phrasey -> dal_goto
    desires = &skoarStats->desirables[10];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->dal_goto(noad));
        --deep;
        return noad;
    }

    // phrasey -> beat
    desires = &skoarStats->desirables[11];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->beat(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::marker(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::marker>(wstring(L"marker"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // marker -> Segno
    desires = &skoarStats->desirables[12];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Segno] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Segno"), noad, toker->burn(ESkoarToke::Segno));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // marker -> Fine
    desires = &skoarStats->desirables[13];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Fine] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Fine"), noad, toker->burn(ESkoarToke::Fine));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // marker -> coda
    desires = &skoarStats->desirables[14];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->coda(noad));
        --deep;
        return noad;
    }

    // marker -> Bars
    desires = &skoarStats->desirables[15];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Bars] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Bars"), noad, toker->burn(ESkoarToke::Bars));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::expr(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::expr>(wstring(L"expr"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // expr -> SymbolColon expr
    desires = &skoarStats->desirables[16];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::SymbolColon] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SymbolColon"), noad, toker->burn(ESkoarToke::SymbolColon));
        noad->add_noad(toke_noad);
        noad->add_noad(this->expr(noad));
        --deep;
        return noad;
    }

    // expr -> msgable expr_prime
    desires = &skoarStats->desirables[17];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->msgable(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::dal_goto(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::dal_goto>(wstring(L"dal_goto"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // dal_goto -> DaCapo al_x
    desires = &skoarStats->desirables[18];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DaCapo] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DaCapo"), noad, toker->burn(ESkoarToke::DaCapo));
        noad->add_noad(toke_noad);
        noad->add_noad(this->al_x(noad));
        --deep;
        return noad;
    }

    // dal_goto -> DalSegno al_x
    desires = &skoarStats->desirables[19];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DalSegno] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DalSegno"), noad, toker->burn(ESkoarToke::DalSegno));
        noad->add_noad(toke_noad);
        noad->add_noad(this->al_x(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::beat(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::beat>(wstring(L"beat"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // beat -> regular_beat
    desires = &skoarStats->desirables[20];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->regular_beat(noad));
        --deep;
        return noad;
    }

    // beat -> exact_beat
    desires = &skoarStats->desirables[21];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->exact_beat(noad));
        --deep;
        return noad;
    }

    // beat -> exact_rest
    desires = &skoarStats->desirables[22];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->exact_rest(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::skrp_sig(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::skrp_sig>(wstring(L"skrp_sig"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // skrp_sig -> SymbolName skrp_sig_prime
    desires = &skoarStats->desirables[23];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::SymbolName] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SymbolName"), noad, toker->burn(ESkoarToke::SymbolName));
        noad->add_noad(toke_noad);
        this->skrp_sig_prime(noad);
        --deep;
        return noad;
    }

    // skrp_sig -> arg_listy SkoarpionSep
    desires = &skoarStats->desirables[24];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->arg_listy(noad));
        skoarStats->tokeFreq[ESkoarToke::SkoarpionSep] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SkoarpionSep"), noad, toker->burn(ESkoarToke::SkoarpionSep));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::skrp_suffix(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::skrp_suffix>(wstring(L"skrp_suffix"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // skrp_suffix -> skrp_lines SkoarpionEnd
    desires = &skoarStats->desirables[25];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->skrp_lines(noad);
        skoarStats->tokeFreq[ESkoarToke::SkoarpionEnd] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SkoarpionEnd"), noad, toker->burn(ESkoarToke::SkoarpionEnd));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::skoarpion(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::skoarpion>(wstring(L"skoarpion"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // skoarpion -> SkoarpionStartWithSig skrp_sig skrp_suffix
    desires = &skoarStats->desirables[26];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::SkoarpionStartWithSig] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SkoarpionStartWithSig"), noad, toker->burn(ESkoarToke::SkoarpionStartWithSig));
        noad->add_noad(toke_noad);
        noad->add_noad(this->skrp_sig(noad));
        noad->add_noad(this->skrp_suffix(noad));
        --deep;
        return noad;
    }

    // skoarpion -> SkoarpionStart skrp_suffix
    desires = &skoarStats->desirables[27];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::SkoarpionStart] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SkoarpionStart"), noad, toker->burn(ESkoarToke::SkoarpionStart));
        noad->add_noad(toke_noad);
        noad->add_noad(this->skrp_suffix(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::skrp_sig_prime(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // skrp_sig_prime -> SkoarpionSep
    desires = &skoarStats->desirables[28];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::SkoarpionSep] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SkoarpionSep"), noad, toker->burn(ESkoarToke::SkoarpionSep));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // skrp_sig_prime -> arg_listy SkoarpionSep
    desires = &skoarStats->desirables[29];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->arg_listy(noad));
        skoarStats->tokeFreq[ESkoarToke::SkoarpionSep] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SkoarpionSep"), noad, toker->burn(ESkoarToke::SkoarpionSep));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::arg_listy(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::arg_listy>(wstring(L"arg_listy"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // arg_listy -> ListS arg_listy_suffix
    desires = &skoarStats->desirables[30];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ListS] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListS"), noad, toker->burn(ESkoarToke::ListS));
        noad->add_noad(toke_noad);
        this->arg_listy_suffix(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::skrp_lines(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // skrp_lines -> opt_voiced_phrases skrp_moar_lines
    desires = &skoarStats->desirables[31];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->opt_voiced_phrases(noad));
        this->skrp_moar_lines(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::skrp_moar_lines(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // skrp_moar_lines -> Newline skrp_lines
    desires = &skoarStats->desirables[32];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Newline] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Newline"), noad, toker->burn(ESkoarToke::Newline));
        noad->add_noad(toke_noad);
        this->skrp_lines(noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::listy_suffix(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // listy_suffix -> Newline listy_entries ListE
    desires = &skoarStats->desirables[33];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Newline] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Newline"), noad, toker->burn(ESkoarToke::Newline));
        noad->add_noad(toke_noad);
        this->listy_entries(noad);
        skoarStats->tokeFreq[ESkoarToke::ListE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListE"), noad, toker->burn(ESkoarToke::ListE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // listy_suffix -> listy_entries ListE
    desires = &skoarStats->desirables[34];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->listy_entries(noad);
        skoarStats->tokeFreq[ESkoarToke::ListE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListE"), noad, toker->burn(ESkoarToke::ListE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // listy_suffix -> ListE
    desires = &skoarStats->desirables[35];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ListE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListE"), noad, toker->burn(ESkoarToke::ListE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::listy(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::listy>(wstring(L"listy"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // listy -> ListS listy_suffix
    desires = &skoarStats->desirables[36];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ListS] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListS"), noad, toker->burn(ESkoarToke::ListS));
        noad->add_noad(toke_noad);
        this->listy_suffix(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::listy_entries(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // listy_entries -> expr moar_listy_entries
    desires = &skoarStats->desirables[37];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->expr(noad));
        this->moar_listy_entries(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::moar_listy_entries(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // moar_listy_entries -> ListSep moar_listy_entries
    desires = &skoarStats->desirables[38];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ListSep] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListSep"), noad, toker->burn(ESkoarToke::ListSep));
        noad->add_noad(toke_noad);
        this->moar_listy_entries(noad);
        --deep;
        return noad;
    }

    // moar_listy_entries -> Newline moar_listy_entries
    desires = &skoarStats->desirables[39];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Newline] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Newline"), noad, toker->burn(ESkoarToke::Newline));
        noad->add_noad(toke_noad);
        this->moar_listy_entries(noad);
        --deep;
        return noad;
    }

    // moar_listy_entries -> listy_entries
    desires = &skoarStats->desirables[40];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->listy_entries(noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::arg_listy_suffix(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // arg_listy_suffix -> Newline arg_listy_entries ListE
    desires = &skoarStats->desirables[41];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Newline] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Newline"), noad, toker->burn(ESkoarToke::Newline));
        noad->add_noad(toke_noad);
        this->arg_listy_entries(noad);
        skoarStats->tokeFreq[ESkoarToke::ListE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListE"), noad, toker->burn(ESkoarToke::ListE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // arg_listy_suffix -> arg_listy_entries ListE
    desires = &skoarStats->desirables[42];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->arg_listy_entries(noad);
        skoarStats->tokeFreq[ESkoarToke::ListE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListE"), noad, toker->burn(ESkoarToke::ListE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // arg_listy_suffix -> ListE
    desires = &skoarStats->desirables[43];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ListE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListE"), noad, toker->burn(ESkoarToke::ListE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::arg_listy_entries(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // arg_listy_entries -> arg_expr moar_arg_listy_entries
    desires = &skoarStats->desirables[44];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->arg_expr(noad));
        this->moar_arg_listy_entries(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::arg_expr(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::arg_expr>(wstring(L"arg_expr"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // arg_expr -> SymbolName
    desires = &skoarStats->desirables[45];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::SymbolName] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SymbolName"), noad, toker->burn(ESkoarToke::SymbolName));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // arg_expr -> SymbolColon expr
    desires = &skoarStats->desirables[46];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::SymbolColon] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_SymbolColon"), noad, toker->burn(ESkoarToke::SymbolColon));
        noad->add_noad(toke_noad);
        noad->add_noad(this->expr(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::moar_arg_listy_entries(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // moar_arg_listy_entries -> ListSep moar_arg_listy_entries
    desires = &skoarStats->desirables[47];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ListSep] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ListSep"), noad, toker->burn(ESkoarToke::ListSep));
        noad->add_noad(toke_noad);
        this->moar_arg_listy_entries(noad);
        --deep;
        return noad;
    }

    // moar_arg_listy_entries -> Newline moar_arg_listy_entries
    desires = &skoarStats->desirables[48];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Newline] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Newline"), noad, toker->burn(ESkoarToke::Newline));
        noad->add_noad(toke_noad);
        this->moar_arg_listy_entries(noad);
        --deep;
        return noad;
    }

    // moar_arg_listy_entries -> arg_listy_entries
    desires = &skoarStats->desirables[49];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->arg_listy_entries(noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::coda(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::coda>(wstring(L"coda"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // coda -> Coda optional_al_coda
    desires = &skoarStats->desirables[50];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Coda] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Coda"), noad, toker->burn(ESkoarToke::Coda));
        noad->add_noad(toke_noad);
        noad->add_noad(this->optional_al_coda(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::optional_al_coda(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::optional_al_coda>(wstring(L"optional_al_coda"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // optional_al_coda -> AlCoda
    desires = &skoarStats->desirables[51];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::AlCoda] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_AlCoda"), noad, toker->burn(ESkoarToke::AlCoda));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::al_x(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::al_x>(wstring(L"al_x"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // al_x -> AlCoda
    desires = &skoarStats->desirables[52];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::AlCoda] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_AlCoda"), noad, toker->burn(ESkoarToke::AlCoda));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // al_x -> AlSegno
    desires = &skoarStats->desirables[53];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::AlSegno] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_AlSegno"), noad, toker->burn(ESkoarToke::AlSegno));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // al_x -> AlFine
    desires = &skoarStats->desirables[54];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::AlFine] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_AlFine"), noad, toker->burn(ESkoarToke::AlFine));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::regular_beat(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::regular_beat>(wstring(L"regular_beat"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // regular_beat -> Crotchets
    desires = &skoarStats->desirables[55];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Crotchets] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Crotchets"), noad, toker->burn(ESkoarToke::Crotchets));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // regular_beat -> Quavers
    desires = &skoarStats->desirables[56];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Quavers] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Quavers"), noad, toker->burn(ESkoarToke::Quavers));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // regular_beat -> Quarters
    desires = &skoarStats->desirables[57];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Quarters] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Quarters"), noad, toker->burn(ESkoarToke::Quarters));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // regular_beat -> Eighths
    desires = &skoarStats->desirables[58];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Eighths] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Eighths"), noad, toker->burn(ESkoarToke::Eighths));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::exact_beat(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::exact_beat>(wstring(L"exact_beat"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // exact_beat -> ExactBeat expr Quarters
    desires = &skoarStats->desirables[59];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ExactBeat] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ExactBeat"), noad, toker->burn(ESkoarToke::ExactBeat));
        noad->add_noad(toke_noad);
        noad->add_noad(this->expr(noad));
        skoarStats->tokeFreq[ESkoarToke::Quarters] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Quarters"), noad, toker->burn(ESkoarToke::Quarters));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::exact_rest(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::exact_rest>(wstring(L"exact_rest"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // exact_rest -> ExactRest expr Crotchets
    desires = &skoarStats->desirables[60];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::ExactRest] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_ExactRest"), noad, toker->burn(ESkoarToke::ExactRest));
        noad->add_noad(toke_noad);
        noad->add_noad(this->expr(noad));
        skoarStats->tokeFreq[ESkoarToke::Crotchets] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Crotchets"), noad, toker->burn(ESkoarToke::Crotchets));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::dynamic(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::dynamic>(wstring(L"dynamic"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // dynamic -> DynPiano
    desires = &skoarStats->desirables[61];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DynPiano] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DynPiano"), noad, toker->burn(ESkoarToke::DynPiano));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // dynamic -> DynForte
    desires = &skoarStats->desirables[62];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DynForte] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DynForte"), noad, toker->burn(ESkoarToke::DynForte));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // dynamic -> DynSFZ
    desires = &skoarStats->desirables[63];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DynSFZ] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DynSFZ"), noad, toker->burn(ESkoarToke::DynSFZ));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // dynamic -> DynFP
    desires = &skoarStats->desirables[64];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DynFP] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DynFP"), noad, toker->burn(ESkoarToke::DynFP));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::musical_keyword(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::musical_keyword>(wstring(L"musical_keyword"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // musical_keyword -> dynamic
    desires = &skoarStats->desirables[65];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->dynamic(noad));
        --deep;
        return noad;
    }

    // musical_keyword -> ottavas
    desires = &skoarStats->desirables[66];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->ottavas(noad));
        --deep;
        return noad;
    }

    // musical_keyword -> musical_keyword_misc
    desires = &skoarStats->desirables[67];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->musical_keyword_misc(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::ottavas(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::ottavas>(wstring(L"ottavas"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // ottavas -> OctaveShift
    desires = &skoarStats->desirables[68];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::OctaveShift] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_OctaveShift"), noad, toker->burn(ESkoarToke::OctaveShift));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // ottavas -> OttavaA
    desires = &skoarStats->desirables[69];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::OttavaA] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_OttavaA"), noad, toker->burn(ESkoarToke::OttavaA));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // ottavas -> OttavaB
    desires = &skoarStats->desirables[70];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::OttavaB] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_OttavaB"), noad, toker->burn(ESkoarToke::OttavaB));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // ottavas -> QuindicesimaA
    desires = &skoarStats->desirables[71];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::QuindicesimaA] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_QuindicesimaA"), noad, toker->burn(ESkoarToke::QuindicesimaA));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // ottavas -> QuindicesimaB
    desires = &skoarStats->desirables[72];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::QuindicesimaB] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_QuindicesimaB"), noad, toker->burn(ESkoarToke::QuindicesimaB));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // ottavas -> Loco
    desires = &skoarStats->desirables[73];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Loco] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Loco"), noad, toker->burn(ESkoarToke::Loco));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::musical_keyword_misc(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::musical_keyword_misc>(wstring(L"musical_keyword_misc"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // musical_keyword_misc -> Carrot
    desires = &skoarStats->desirables[74];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Carrot] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Carrot"), noad, toker->burn(ESkoarToke::Carrot));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::cthulhu(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::cthulhu>(wstring(L"cthulhu"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // cthulhu -> LWing Semicolon cthulhu_prime
    desires = &skoarStats->desirables[75];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::LWing] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_LWing"), noad, toker->burn(ESkoarToke::LWing));
        noad->add_noad(toke_noad);
        skoarStats->tokeFreq[ESkoarToke::Semicolon] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Semicolon"), noad, toker->burn(ESkoarToke::Semicolon));
        noad->add_noad(toke_noad);
        this->cthulhu_prime(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::nouny(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::nouny>(wstring(L"nouny"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // nouny -> cthulhu
    desires = &skoarStats->desirables[76];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->cthulhu(noad));
        --deep;
        return noad;
    }

    // nouny -> meditation
    desires = &skoarStats->desirables[77];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->meditation(noad));
        --deep;
        return noad;
    }

    // nouny -> conditional
    desires = &skoarStats->desirables[78];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->conditional(noad));
        --deep;
        return noad;
    }

    // nouny -> loop
    desires = &skoarStats->desirables[79];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->loop(noad));
        --deep;
        return noad;
    }

    // nouny -> nouny_literal
    desires = &skoarStats->desirables[80];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->nouny_literal(noad);
        --deep;
        return noad;
    }

    // nouny -> musical_keyword
    desires = &skoarStats->desirables[81];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->musical_keyword(noad));
        --deep;
        return noad;
    }

    // nouny -> listy
    desires = &skoarStats->desirables[82];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->listy(noad));
        --deep;
        return noad;
    }

    // nouny -> deref
    desires = &skoarStats->desirables[83];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->deref(noad));
        --deep;
        return noad;
    }

    // nouny -> skoarpion
    desires = &skoarStats->desirables[84];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->skoarpion(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::meditation(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::meditation>(wstring(L"meditation"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // meditation -> MeditationS skrp_lines MeditationE
    desires = &skoarStats->desirables[85];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::MeditationS] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MeditationS"), noad, toker->burn(ESkoarToke::MeditationS));
        noad->add_noad(toke_noad);
        this->skrp_lines(noad);
        skoarStats->tokeFreq[ESkoarToke::MeditationE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MeditationE"), noad, toker->burn(ESkoarToke::MeditationE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::conditional(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::conditional>(wstring(L"conditional"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // conditional -> CondS cond_ifs CondE
    desires = &skoarStats->desirables[86];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::CondS] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_CondS"), noad, toker->burn(ESkoarToke::CondS));
        noad->add_noad(toke_noad);
        this->cond_ifs(noad);
        skoarStats->tokeFreq[ESkoarToke::CondE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_CondE"), noad, toker->burn(ESkoarToke::CondE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::loop(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::loop>(wstring(L"loop"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // loop -> LoopS loop_body loop_condition LoopE
    desires = &skoarStats->desirables[87];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::LoopS] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_LoopS"), noad, toker->burn(ESkoarToke::LoopS));
        noad->add_noad(toke_noad);
        noad->add_noad(this->loop_body(noad));
        noad->add_noad(this->loop_condition(noad));
        skoarStats->tokeFreq[ESkoarToke::LoopE] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_LoopE"), noad, toker->burn(ESkoarToke::LoopE));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::nouny_literal(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // nouny_literal -> Duration
    desires = &skoarStats->desirables[88];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Duration] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Duration"), noad, toker->burn(ESkoarToke::Duration));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> ugen
    desires = &skoarStats->desirables[89];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->ugen(noad));
        --deep;
        return noad;
    }

    // nouny_literal -> Tuplet
    desires = &skoarStats->desirables[90];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Tuplet] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Tuplet"), noad, toker->burn(ESkoarToke::Tuplet));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> Freq
    desires = &skoarStats->desirables[91];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Freq] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Freq"), noad, toker->burn(ESkoarToke::Freq));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> Int
    desires = &skoarStats->desirables[92];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Int] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Int"), noad, toker->burn(ESkoarToke::Int));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> Float
    desires = &skoarStats->desirables[93];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Float] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Float"), noad, toker->burn(ESkoarToke::Float));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> String
    desires = &skoarStats->desirables[94];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::String] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_String"), noad, toker->burn(ESkoarToke::String));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> Choard
    desires = &skoarStats->desirables[95];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Choard] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Choard"), noad, toker->burn(ESkoarToke::Choard));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> NamedNoat
    desires = &skoarStats->desirables[96];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::NamedNoat] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_NamedNoat"), noad, toker->burn(ESkoarToke::NamedNoat));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> Symbol
    desires = &skoarStats->desirables[97];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Symbol] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Symbol"), noad, toker->burn(ESkoarToke::Symbol));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> Fairy
    desires = &skoarStats->desirables[98];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Fairy] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Fairy"), noad, toker->burn(ESkoarToke::Fairy));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> HashLevel
    desires = &skoarStats->desirables[99];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::HashLevel] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_HashLevel"), noad, toker->burn(ESkoarToke::HashLevel));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> False
    desires = &skoarStats->desirables[100];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::False] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_False"), noad, toker->burn(ESkoarToke::False));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> True
    desires = &skoarStats->desirables[101];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::True] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_True"), noad, toker->burn(ESkoarToke::True));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> Cat
    desires = &skoarStats->desirables[102];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Cat] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Cat"), noad, toker->burn(ESkoarToke::Cat));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // nouny_literal -> lute
    desires = &skoarStats->desirables[103];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->lute(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::deref(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::deref>(wstring(L"deref"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // deref -> Deref deref_prime
    desires = &skoarStats->desirables[104];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Deref] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Deref"), noad, toker->burn(ESkoarToke::Deref));
        noad->add_noad(toke_noad);
        this->deref_prime(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::ugen(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::ugen>(wstring(L"ugen"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // ugen -> ugen_with_args
    desires = &skoarStats->desirables[105];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->ugen_with_args(noad));
        --deep;
        return noad;
    }

    // ugen -> ugen_simple
    desires = &skoarStats->desirables[106];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->ugen_simple(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::lute(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::lute>(wstring(L"lute"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // lute -> Lute
    desires = &skoarStats->desirables[107];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Lute] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Lute"), noad, toker->burn(ESkoarToke::Lute));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // lute -> LuteWithArgs listy_suffix
    desires = &skoarStats->desirables[108];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::LuteWithArgs] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_LuteWithArgs"), noad, toker->burn(ESkoarToke::LuteWithArgs));
        noad->add_noad(toke_noad);
        this->listy_suffix(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::deref_prime(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // deref_prime -> MsgNameWithArgs listy_suffix
    desires = &skoarStats->desirables[109];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::MsgNameWithArgs] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MsgNameWithArgs"), noad, toker->burn(ESkoarToke::MsgNameWithArgs));
        noad->add_noad(toke_noad);
        this->listy_suffix(noad);
        --deep;
        return noad;
    }

    // deref_prime -> MsgName
    desires = &skoarStats->desirables[110];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::MsgName] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MsgName"), noad, toker->burn(ESkoarToke::MsgName));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::msgable(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::msgable>(wstring(L"msgable"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // msgable -> nouny msg_chain_node
    desires = &skoarStats->desirables[111];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->nouny(noad));
        this->msg_chain_node(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::expr_prime(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::expr_prime>(wstring(L"expr_prime"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // expr_prime -> assignment expr_prime
    desires = &skoarStats->desirables[112];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->assignment(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;
        return noad;
    }

    // expr_prime -> math expr_prime
    desires = &skoarStats->desirables[113];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->math(noad));
        noad->add_noad(this->expr_prime(noad));
        --deep;
        return noad;
    }

    // expr_prime -> boolean
    desires = &skoarStats->desirables[114];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->boolean(noad));
        --deep;
        return noad;
    }

    // expr_prime -> times
    desires = &skoarStats->desirables[115];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->times(noad));
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::assignment(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::assignment>(wstring(L"assignment"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // assignment -> AssOp settable
    desires = &skoarStats->desirables[116];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::AssOp] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_AssOp"), noad, toker->burn(ESkoarToke::AssOp));
        noad->add_noad(toke_noad);
        this->settable(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::math(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::math>(wstring(L"math"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // math -> MathOp msgable
    desires = &skoarStats->desirables[117];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::MathOp] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MathOp"), noad, toker->burn(ESkoarToke::MathOp));
        noad->add_noad(toke_noad);
        noad->add_noad(this->msgable(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::boolean(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::boolean>(wstring(L"boolean"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // boolean -> BooleanOp expr
    desires = &skoarStats->desirables[118];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::BooleanOp] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_BooleanOp"), noad, toker->burn(ESkoarToke::BooleanOp));
        noad->add_noad(toke_noad);
        noad->add_noad(this->expr(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::times(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::times>(wstring(L"times"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // times -> Times
    desires = &skoarStats->desirables[119];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Times] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Times"), noad, toker->burn(ESkoarToke::Times));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::boolean_expr(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::boolean_expr>(wstring(L"boolean_expr"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // boolean_expr -> expr
    desires = &skoarStats->desirables[120];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->expr(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::settable(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // settable -> Symbol
    desires = &skoarStats->desirables[121];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Symbol] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Symbol"), noad, toker->burn(ESkoarToke::Symbol));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // settable -> listy
    desires = &skoarStats->desirables[122];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->listy(noad));
        --deep;
        return noad;
    }

    // settable -> Quarters
    desires = &skoarStats->desirables[123];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Quarters] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Quarters"), noad, toker->burn(ESkoarToke::Quarters));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // settable -> Eighths
    desires = &skoarStats->desirables[124];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Eighths] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Eighths"), noad, toker->burn(ESkoarToke::Eighths));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // settable -> Fairy
    desires = &skoarStats->desirables[125];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Fairy] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Fairy"), noad, toker->burn(ESkoarToke::Fairy));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::msg_chain_node(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // msg_chain_node -> MsgOp msg msg_chain_node
    desires = &skoarStats->desirables[126];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::MsgOp] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MsgOp"), noad, toker->burn(ESkoarToke::MsgOp));
        noad->add_noad(toke_noad);
        noad->add_noad(this->msg(noad));
        this->msg_chain_node(noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::msg(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::msg>(wstring(L"msg"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // msg -> MsgNameWithArgs listy_suffix
    desires = &skoarStats->desirables[127];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::MsgNameWithArgs] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MsgNameWithArgs"), noad, toker->burn(ESkoarToke::MsgNameWithArgs));
        noad->add_noad(toke_noad);
        this->listy_suffix(noad);
        --deep;
        return noad;
    }

    // msg -> MsgName
    desires = &skoarStats->desirables[128];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::MsgName] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_MsgName"), noad, toker->burn(ESkoarToke::MsgName));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // msg -> listy
    desires = &skoarStats->desirables[129];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->listy(noad));
        --deep;
        return noad;
    }

    // msg -> loop
    desires = &skoarStats->desirables[130];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->loop(noad));
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::cthulhu_prime(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // cthulhu_prime -> boolean_expr Semicolon RWing
    desires = &skoarStats->desirables[131];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->boolean_expr(noad));
        skoarStats->tokeFreq[ESkoarToke::Semicolon] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Semicolon"), noad, toker->burn(ESkoarToke::Semicolon));
        noad->add_noad(toke_noad);
        skoarStats->tokeFreq[ESkoarToke::RWing] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_RWing"), noad, toker->burn(ESkoarToke::RWing));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // cthulhu_prime -> Nosey Semicolon RWing
    desires = &skoarStats->desirables[132];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Nosey] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Nosey"), noad, toker->burn(ESkoarToke::Nosey));
        noad->add_noad(toke_noad);
        skoarStats->tokeFreq[ESkoarToke::Semicolon] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Semicolon"), noad, toker->burn(ESkoarToke::Semicolon));
        noad->add_noad(toke_noad);
        skoarStats->tokeFreq[ESkoarToke::RWing] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_RWing"), noad, toker->burn(ESkoarToke::RWing));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::cond_ifs(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // cond_ifs -> cond_if cond_ifs_suffix
    desires = &skoarStats->desirables[133];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        noad->add_noad(this->cond_if(noad));
        this->cond_ifs_suffix(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::cond_if(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::cond_if>(wstring(L"cond_if"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // cond_if -> optional_voice boolean_expr CondIf if_body cond_else
    desires = &skoarStats->desirables[134];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->optional_voice(noad);
        noad->add_noad(this->boolean_expr(noad));
        skoarStats->tokeFreq[ESkoarToke::CondIf] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_CondIf"), noad, toker->burn(ESkoarToke::CondIf));
        noad->add_noad(toke_noad);
        noad->add_noad(this->if_body(noad));
        this->cond_else(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::cond_ifs_suffix(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // cond_ifs_suffix -> Newline cond_ifs
    desires = &skoarStats->desirables[135];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::Newline] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_Newline"), noad, toker->burn(ESkoarToke::Newline));
        noad->add_noad(toke_noad);
        this->cond_ifs(noad);
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::if_body(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::if_body>(wstring(L"if_body"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // if_body -> phrases
    desires = &skoarStats->desirables[136];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->phrases(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::cond_else(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = parent;
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // cond_else -> CondIf if_body
    desires = &skoarStats->desirables[137];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::CondIf] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_CondIf"), noad, toker->burn(ESkoarToke::CondIf));
        noad->add_noad(toke_noad);
        noad->add_noad(this->if_body(noad));
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::loop_body(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::loop_body>(wstring(L"loop_body"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // loop_body -> phrases
    desires = &skoarStats->desirables[138];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        this->phrases(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::loop_condition(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::loop_condition>(wstring(L"loop_condition"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // loop_condition -> LoopSep boolean_expr
    desires = &skoarStats->desirables[139];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::LoopSep] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_LoopSep"), noad, toker->burn(ESkoarToke::LoopSep));
        noad->add_noad(toke_noad);
        noad->add_noad(this->boolean_expr(noad));
        --deep;
        return noad;
    }

    // <e>
    --deep;
    return noad;
}

SkoarNoadPtr SkoarParser::ugen_with_args(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::ugen_with_args>(wstring(L"ugen_with_args"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // ugen_with_args -> AUGenWithArgs listy_suffix
    desires = &skoarStats->desirables[140];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::AUGenWithArgs] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_AUGenWithArgs"), noad, toker->burn(ESkoarToke::AUGenWithArgs));
        noad->add_noad(toke_noad);
        this->listy_suffix(noad);
        --deep;
        return noad;
    }

    // ugen_with_args -> KUGenWithArgs listy_suffix
    desires = &skoarStats->desirables[141];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::KUGenWithArgs] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_KUGenWithArgs"), noad, toker->burn(ESkoarToke::KUGenWithArgs));
        noad->add_noad(toke_noad);
        this->listy_suffix(noad);
        --deep;
        return noad;
    }

    // ugen_with_args -> DUGenWithArgs listy_suffix
    desires = &skoarStats->desirables[142];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DUGenWithArgs] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DUGenWithArgs"), noad, toker->burn(ESkoarToke::DUGenWithArgs));
        noad->add_noad(toke_noad);
        this->listy_suffix(noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}

SkoarNoadPtr SkoarParser::ugen_simple(SkoarNoadPtr parent) {
    SkoarNoadPtr noad = SkoarNoad::New<ESkoarNoad::ugen_simple>(wstring(L"ugen_simple"), parent);
    list<ESkoarToke::Kind>* desires = nullptr;

    if (++deep > 1000) {
        this->fail_too_deep(parent);
    }

    // ugen_simple -> AUGen
    desires = &skoarStats->desirables[143];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::AUGen] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_AUGen"), noad, toker->burn(ESkoarToke::AUGen));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // ugen_simple -> KUGen
    desires = &skoarStats->desirables[144];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::KUGen] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_KUGen"), noad, toker->burn(ESkoarToke::KUGen));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // ugen_simple -> DUGen
    desires = &skoarStats->desirables[145];
    if (toker->sees(desires) != nullptr) {
        SkoarNoadPtr toke_noad;
        skoarStats->tokeFreq[ESkoarToke::DUGen] += 0.1f;
        toke_noad = SkoarNoad::New(wstring(L"Toke_DUGen"), noad, toker->burn(ESkoarToke::DUGen));
        noad->add_noad(toke_noad);
        --deep;
        return noad;
    }

    // Error State
    this->fail(noad);
    return nullptr;
}


void SkoarParser::sortDesirables() {
    localSortDesirables();
}

