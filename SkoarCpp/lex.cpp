// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2017-12-05 11:27:38 for C++14
// ======================================================================
#include "lex.hpp"
#include "exception.hpp"
#include "memories.hpp"

static wsmatch matches;
// ------------------
// Abstract SkoarToke
// ------------------
 SkoarToke::SkoarToke() {
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
}

 SkoarToke::SkoarToke(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
}

 SkoarToke::~SkoarToke() {
}

// how many characters to burn from the buffer
size_t SkoarToke::burn() {
    return size;
}

// --------------
// Eof is special
// --------------
 Toke_Eof::Toke_Eof() {
    kind = ESkoarToke::Eof;

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Eof");
#endif
}

 Toke_Eof::~Toke_Eof() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Eof");
#endif
}

size_t Toke_Eof::burn(wstring * buf, size_t offs) {
    if (buf->size() > offs) {
        throw SkoarError(L"Tried to burn Eof when there's more input.");
    }

    return 0;
}

SkoarToke* Toke_Eof::match_toke(wstring * buf, size_t offs) {
    if (buf->size() == offs) {
        return new Toke_Eof();
    }

    return nullptr;
}

// ---------------------
// Whitespace is special
// ---------------------
const wregex Toke_Whitespace::rgx = wregex(L"[ \\t]*", regex_constants::optimize);

size_t Toke_Whitespace::burn(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Whitespace::rgx, regex_constants::match_continuous);
    if (!found) {
        return 0;
    }

    return matches[0].length();
}

// --------------
// Everyday Tokes
// --------------
const std::wregex Toke_AUGen::rgx = wregex(L"a[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)", regex_constants::optimize);
 Toke_AUGen::Toke_AUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AUGen>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"AUGen");
#endif
}

 Toke_AUGen::~Toke_AUGen() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"AUGen");
#endif
}

SkoarToke* Toke_AUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AUGen(s, offs, s.length());
}

const std::wregex Toke_AUGenWithArgs::rgx = wregex(L"a[A-Z][a-zA-Z0-9_]*<", regex_constants::optimize);
 Toke_AUGenWithArgs::Toke_AUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AUGenWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"AUGenWithArgs");
#endif
}

 Toke_AUGenWithArgs::~Toke_AUGenWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"AUGenWithArgs");
#endif
}

SkoarToke* Toke_AUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_AlCoda::rgx = wregex(L"al [cC]oda(\\s*:\\s*[a-zA-Z0-9_]+)?", regex_constants::optimize);
 Toke_AlCoda::Toke_AlCoda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlCoda;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AlCoda>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"AlCoda");
#endif
}

 Toke_AlCoda::~Toke_AlCoda() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"AlCoda");
#endif
}

SkoarToke* Toke_AlCoda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlCoda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlCoda(s, offs, s.length());
}

const std::wregex Toke_Bars::rgx = wregex(L":?\\|+(?![>]):?", regex_constants::optimize);
 Toke_Bars::Toke_Bars(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Bars;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Bars>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Bars");
#endif
}

 Toke_Bars::~Toke_Bars() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Bars");
#endif
}

SkoarToke* Toke_Bars::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Bars::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Bars(s, offs, s.length());
}

const std::wregex Toke_BooleanAnd::rgx = wregex(L"and", regex_constants::optimize);
 Toke_BooleanAnd::Toke_BooleanAnd(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BooleanAnd;
    this->style = SkoarStyles::Toke::style<ESkoarToke::BooleanAnd>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"BooleanAnd");
#endif
}

 Toke_BooleanAnd::~Toke_BooleanAnd() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"BooleanAnd");
#endif
}

SkoarToke* Toke_BooleanAnd::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanAnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_BooleanAnd(s, offs, s.length());
}

const std::wregex Toke_BooleanOr::rgx = wregex(L"or", regex_constants::optimize);
 Toke_BooleanOr::Toke_BooleanOr(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BooleanOr;
    this->style = SkoarStyles::Toke::style<ESkoarToke::BooleanOr>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"BooleanOr");
#endif
}

 Toke_BooleanOr::~Toke_BooleanOr() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"BooleanOr");
#endif
}

SkoarToke* Toke_BooleanOr::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanOr::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_BooleanOr(s, offs, s.length());
}

const std::wregex Toke_BracketE::rgx = wregex(L"_\\)", regex_constants::optimize);
 Toke_BracketE::Toke_BracketE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BracketE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::BracketE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"BracketE");
#endif
}

 Toke_BracketE::~Toke_BracketE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"BracketE");
#endif
}

SkoarToke* Toke_BracketE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BracketE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_BracketE(s, offs, s.length());
}

const std::wregex Toke_BracketS::rgx = wregex(L"_\\(", regex_constants::optimize);
 Toke_BracketS::Toke_BracketS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BracketS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::BracketS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"BracketS");
#endif
}

 Toke_BracketS::~Toke_BracketS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"BracketS");
#endif
}

SkoarToke* Toke_BracketS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BracketS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_BracketS(s, offs, s.length());
}

const std::wregex Toke_Carrot::rgx = wregex(L"\\^(?!\\^[(])", regex_constants::optimize);
 Toke_Carrot::Toke_Carrot(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Carrot;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Carrot>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Carrot");
#endif
}

 Toke_Carrot::~Toke_Carrot() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Carrot");
#endif
}

SkoarToke* Toke_Carrot::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Carrot::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Carrot(s, offs, s.length());
}

const std::wregex Toke_Cat::rgx = wregex(L"=\\^\\.\\^=", regex_constants::optimize);
 Toke_Cat::Toke_Cat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Cat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Cat>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Cat");
#endif
}

 Toke_Cat::~Toke_Cat() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Cat");
#endif
}

SkoarToke* Toke_Cat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Cat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Cat(s, offs, s.length());
}

const std::wregex Toke_Choard::rgx = wregex(L"~*[ABCDEFG](?![.ce-hj-ln-rt-zA-LN-Z]|a[l ])(#|b)?([Mm0-9]|sus|dim|aug|dom)*~*", regex_constants::optimize);
 Toke_Choard::Toke_Choard(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Choard;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Choard>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Choard");
#endif
}

 Toke_Choard::~Toke_Choard() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Choard");
#endif
}

SkoarToke* Toke_Choard::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Choard::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Choard(s, offs, s.length());
}

const std::wregex Toke_CmpEqNeq::rgx = wregex(L"==|!=", regex_constants::optimize);
 Toke_CmpEqNeq::Toke_CmpEqNeq(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CmpEqNeq;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CmpEqNeq>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"CmpEqNeq");
#endif
}

 Toke_CmpEqNeq::~Toke_CmpEqNeq() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"CmpEqNeq");
#endif
}

SkoarToke* Toke_CmpEqNeq::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CmpEqNeq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CmpEqNeq(s, offs, s.length());
}

const std::wregex Toke_CmpGtLt::rgx = wregex(L"<=|>=|_<|_>", regex_constants::optimize);
 Toke_CmpGtLt::Toke_CmpGtLt(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CmpGtLt;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CmpGtLt>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"CmpGtLt");
#endif
}

 Toke_CmpGtLt::~Toke_CmpGtLt() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"CmpGtLt");
#endif
}

SkoarToke* Toke_CmpGtLt::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CmpGtLt::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CmpGtLt(s, offs, s.length());
}

const std::wregex Toke_Coda::rgx = wregex(L"\\([+]\\)(\\s*:\\s*[a-zA-Z0-9_]+)?", regex_constants::optimize);
 Toke_Coda::Toke_Coda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Coda;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Coda>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Coda");
#endif
}

 Toke_Coda::~Toke_Coda() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Coda");
#endif
}

SkoarToke* Toke_Coda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Coda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Coda(s, offs, s.length());
}

const std::wregex Toke_Comment::rgx = wregex(L";.*", regex_constants::optimize);
 Toke_Comment::Toke_Comment(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Comment;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Comment>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Comment");
#endif
}

 Toke_Comment::~Toke_Comment() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Comment");
#endif
}

SkoarToke* Toke_Comment::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Comment::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Comment(s, offs, s.length());
}

const std::wregex Toke_CondE::rgx = wregex(L"[?][}]", regex_constants::optimize);
 Toke_CondE::Toke_CondE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"CondE");
#endif
}

 Toke_CondE::~Toke_CondE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"CondE");
#endif
}

SkoarToke* Toke_CondE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondE(s, offs, s.length());
}

const std::wregex Toke_CondIf::rgx = wregex(L"[?][?](?![}])", regex_constants::optimize);
 Toke_CondIf::Toke_CondIf(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondIf;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondIf>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"CondIf");
#endif
}

 Toke_CondIf::~Toke_CondIf() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"CondIf");
#endif
}

SkoarToke* Toke_CondIf::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondIf::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondIf(s, offs, s.length());
}

const std::wregex Toke_CondS::rgx = wregex(L"[{][?]", regex_constants::optimize);
 Toke_CondS::Toke_CondS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"CondS");
#endif
}

 Toke_CondS::~Toke_CondS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"CondS");
#endif
}

SkoarToke* Toke_CondS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondS(s, offs, s.length());
}

const std::wregex Toke_Crotchets::rgx = wregex(L"[}]+\\.?", regex_constants::optimize);
 Toke_Crotchets::Toke_Crotchets(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Crotchets;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Crotchets>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Crotchets");
#endif
}

 Toke_Crotchets::~Toke_Crotchets() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Crotchets");
#endif
}

SkoarToke* Toke_Crotchets::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crotchets::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Crotchets(s, offs, s.length());
}

const std::wregex Toke_DUGen::rgx = wregex(L"d[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)", regex_constants::optimize);
 Toke_DUGen::Toke_DUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DUGen>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"DUGen");
#endif
}

 Toke_DUGen::~Toke_DUGen() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"DUGen");
#endif
}

SkoarToke* Toke_DUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DUGen(s, offs, s.length());
}

const std::wregex Toke_DUGenWithArgs::rgx = wregex(L"d[A-Z][a-zA-Z0-9_]*<", regex_constants::optimize);
 Toke_DUGenWithArgs::Toke_DUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DUGenWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"DUGenWithArgs");
#endif
}

 Toke_DUGenWithArgs::~Toke_DUGenWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"DUGenWithArgs");
#endif
}

SkoarToke* Toke_DUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_Deref::rgx = wregex(L"!(?![!}]|=)", regex_constants::optimize);
 Toke_Deref::Toke_Deref(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Deref;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Deref>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Deref");
#endif
}

 Toke_Deref::~Toke_Deref() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Deref");
#endif
}

SkoarToke* Toke_Deref::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Deref::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Deref(s, offs, s.length());
}

const std::wregex Toke_Duration::rgx = wregex(L"[0-9]+:[0-9]+(\\.[0-9]+)?", regex_constants::optimize);
 Toke_Duration::Toke_Duration(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Duration;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Duration>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Duration");
#endif
}

 Toke_Duration::~Toke_Duration() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Duration");
#endif
}

SkoarToke* Toke_Duration::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Duration::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Duration(s, offs, s.length());
}

const std::wregex Toke_Eighths::rgx = wregex(L"\\.?\\]+(?:__?)?\\.?", regex_constants::optimize);
 Toke_Eighths::Toke_Eighths(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Eighths;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Eighths>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Eighths");
#endif
}

 Toke_Eighths::~Toke_Eighths() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Eighths");
#endif
}

SkoarToke* Toke_Eighths::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Eighths::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Eighths(s, offs, s.length());
}

const std::wregex Toke_ExactBeat::rgx = wregex(L"[(](?![+])", regex_constants::optimize);
 Toke_ExactBeat::Toke_ExactBeat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExactBeat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExactBeat>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"ExactBeat");
#endif
}

 Toke_ExactBeat::~Toke_ExactBeat() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"ExactBeat");
#endif
}

SkoarToke* Toke_ExactBeat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExactBeat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExactBeat(s, offs, s.length());
}

const std::wregex Toke_ExactRest::rgx = wregex(L"[{](?![=?:!])", regex_constants::optimize);
 Toke_ExactRest::Toke_ExactRest(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExactRest;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExactRest>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"ExactRest");
#endif
}

 Toke_ExactRest::~Toke_ExactRest() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"ExactRest");
#endif
}

SkoarToke* Toke_ExactRest::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExactRest::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExactRest(s, offs, s.length());
}

const std::wregex Toke_ExpoartsE::rgx = wregex(L"\\]", regex_constants::optimize);
 Toke_ExpoartsE::Toke_ExpoartsE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExpoartsE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExpoartsE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"ExpoartsE");
#endif
}

 Toke_ExpoartsE::~Toke_ExpoartsE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"ExpoartsE");
#endif
}

SkoarToke* Toke_ExpoartsE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExpoartsE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExpoartsE(s, offs, s.length());
}

const std::wregex Toke_ExpoartsS::rgx = wregex(L"\\[", regex_constants::optimize);
 Toke_ExpoartsS::Toke_ExpoartsS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExpoartsS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExpoartsS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"ExpoartsS");
#endif
}

 Toke_ExpoartsS::~Toke_ExpoartsS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"ExpoartsS");
#endif
}

SkoarToke* Toke_ExpoartsS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExpoartsS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExpoartsS(s, offs, s.length());
}

const std::wregex Toke_Fairy::rgx = wregex(L"[$]", regex_constants::optimize);
 Toke_Fairy::Toke_Fairy(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fairy;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Fairy>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Fairy");
#endif
}

 Toke_Fairy::~Toke_Fairy() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Fairy");
#endif
}

SkoarToke* Toke_Fairy::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fairy::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Fairy(s, offs, s.length());
}

const std::wregex Toke_False::rgx = wregex(L"no|false", regex_constants::optimize);
 Toke_False::Toke_False(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::False;
    this->style = SkoarStyles::Toke::style<ESkoarToke::False>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"False");
#endif
}

 Toke_False::~Toke_False() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"False");
#endif
}

SkoarToke* Toke_False::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_False::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_False(s, offs, s.length());
}

const std::wregex Toke_Float::rgx = wregex(L"(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz|:[0-9])", regex_constants::optimize);
 Toke_Float::Toke_Float(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Float;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Float>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Float");
#endif
}

 Toke_Float::~Toke_Float() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Float");
#endif
}

SkoarToke* Toke_Float::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Float::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Float(s, offs, s.length());
}

const std::wregex Toke_Freq::rgx = wregex(L"(0|[1-9][0-9]*)(\\.[0-9]+)?Hz", regex_constants::optimize);
 Toke_Freq::Toke_Freq(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Freq;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Freq>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Freq");
#endif
}

 Toke_Freq::~Toke_Freq() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Freq");
#endif
}

SkoarToke* Toke_Freq::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Freq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Freq(s, offs, s.length());
}

const std::wregex Toke_HashLevel::rgx = wregex(L"\\[#*[ ]*\\]", regex_constants::optimize);
 Toke_HashLevel::Toke_HashLevel(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::HashLevel;
    this->style = SkoarStyles::Toke::style<ESkoarToke::HashLevel>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"HashLevel");
#endif
}

 Toke_HashLevel::~Toke_HashLevel() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"HashLevel");
#endif
}

SkoarToke* Toke_HashLevel::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_HashLevel::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_HashLevel(s, offs, s.length());
}

const std::wregex Toke_Int::rgx = wregex(L"(-)?(0|[1-9][0-9]*)(?![0-9]*Hz|[0-9]*\\.[0-9]|:[0-9])", regex_constants::optimize);
 Toke_Int::Toke_Int(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Int;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Int>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Int");
#endif
}

 Toke_Int::~Toke_Int() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Int");
#endif
}

SkoarToke* Toke_Int::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Int::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Int(s, offs, s.length());
}

const std::wregex Toke_KUGen::rgx = wregex(L"c[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)", regex_constants::optimize);
 Toke_KUGen::Toke_KUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::KUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::KUGen>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"KUGen");
#endif
}

 Toke_KUGen::~Toke_KUGen() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"KUGen");
#endif
}

SkoarToke* Toke_KUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_KUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_KUGen(s, offs, s.length());
}

const std::wregex Toke_KUGenWithArgs::rgx = wregex(L"c[A-Z][a-zA-Z0-9_]*<", regex_constants::optimize);
 Toke_KUGenWithArgs::Toke_KUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::KUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::KUGenWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"KUGenWithArgs");
#endif
}

 Toke_KUGenWithArgs::~Toke_KUGenWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"KUGenWithArgs");
#endif
}

SkoarToke* Toke_KUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_KUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_KUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_LWing::rgx = wregex(L"\\^\\^[(]", regex_constants::optimize);
 Toke_LWing::Toke_LWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LWing;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LWing>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"LWing");
#endif
}

 Toke_LWing::~Toke_LWing() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"LWing");
#endif
}

SkoarToke* Toke_LWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LWing(s, offs, s.length());
}

const std::wregex Toke_ListE::rgx = wregex(L">(?![=])", regex_constants::optimize);
 Toke_ListE::Toke_ListE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"ListE");
#endif
}

 Toke_ListE::~Toke_ListE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"ListE");
#endif
}

SkoarToke* Toke_ListE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListE(s, offs, s.length());
}

const std::wregex Toke_ListS::rgx = wregex(L"<(?![=?])|<(?=[=]\\^\\.)", regex_constants::optimize);
 Toke_ListS::Toke_ListS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"ListS");
#endif
}

 Toke_ListS::~Toke_ListS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"ListS");
#endif
}

SkoarToke* Toke_ListS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListS(s, offs, s.length());
}

const std::wregex Toke_ListSep::rgx = wregex(L",", regex_constants::optimize);
 Toke_ListSep::Toke_ListSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListSep>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"ListSep");
#endif
}

 Toke_ListSep::~Toke_ListSep() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"ListSep");
#endif
}

SkoarToke* Toke_ListSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListSep(s, offs, s.length());
}

const std::wregex Toke_LoopE::rgx = wregex(L":[}]", regex_constants::optimize);
 Toke_LoopE::Toke_LoopE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"LoopE");
#endif
}

 Toke_LoopE::~Toke_LoopE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"LoopE");
#endif
}

SkoarToke* Toke_LoopE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopE(s, offs, s.length());
}

const std::wregex Toke_LoopS::rgx = wregex(L"[{]:", regex_constants::optimize);
 Toke_LoopS::Toke_LoopS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"LoopS");
#endif
}

 Toke_LoopS::~Toke_LoopS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"LoopS");
#endif
}

SkoarToke* Toke_LoopS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopS(s, offs, s.length());
}

const std::wregex Toke_LoopSep::rgx = wregex(L"::(?![|])", regex_constants::optimize);
 Toke_LoopSep::Toke_LoopSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopSep>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"LoopSep");
#endif
}

 Toke_LoopSep::~Toke_LoopSep() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"LoopSep");
#endif
}

SkoarToke* Toke_LoopSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopSep(s, offs, s.length());
}

const std::wregex Toke_Lute::rgx = wregex(L"&(?!<)", regex_constants::optimize);
 Toke_Lute::Toke_Lute(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Lute;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Lute>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Lute");
#endif
}

 Toke_Lute::~Toke_Lute() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Lute");
#endif
}

SkoarToke* Toke_Lute::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Lute::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Lute(s, offs, s.length());
}

const std::wregex Toke_LuteWithArgs::rgx = wregex(L"&<", regex_constants::optimize);
 Toke_LuteWithArgs::Toke_LuteWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LuteWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LuteWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"LuteWithArgs");
#endif
}

 Toke_LuteWithArgs::~Toke_LuteWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"LuteWithArgs");
#endif
}

SkoarToke* Toke_LuteWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LuteWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LuteWithArgs(s, offs, s.length());
}

const std::wregex Toke_MathOpAddSub::rgx = wregex(L"[+\\-](?!>)", regex_constants::optimize);
 Toke_MathOpAddSub::Toke_MathOpAddSub(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MathOpAddSub;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MathOpAddSub>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"MathOpAddSub");
#endif
}

 Toke_MathOpAddSub::~Toke_MathOpAddSub() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"MathOpAddSub");
#endif
}

SkoarToke* Toke_MathOpAddSub::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOpAddSub::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MathOpAddSub(s, offs, s.length());
}

const std::wregex Toke_MathOpMulDivMod::rgx = wregex(L"[*/%](?!>)", regex_constants::optimize);
 Toke_MathOpMulDivMod::Toke_MathOpMulDivMod(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MathOpMulDivMod;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MathOpMulDivMod>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"MathOpMulDivMod");
#endif
}

 Toke_MathOpMulDivMod::~Toke_MathOpMulDivMod() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"MathOpMulDivMod");
#endif
}

SkoarToke* Toke_MathOpMulDivMod::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOpMulDivMod::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MathOpMulDivMod(s, offs, s.length());
}

const std::wregex Toke_MeditationE::rgx = wregex(L"=[}]", regex_constants::optimize);
 Toke_MeditationE::Toke_MeditationE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MeditationE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MeditationE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"MeditationE");
#endif
}

 Toke_MeditationE::~Toke_MeditationE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"MeditationE");
#endif
}

SkoarToke* Toke_MeditationE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MeditationE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MeditationE(s, offs, s.length());
}

const std::wregex Toke_MeditationS::rgx = wregex(L"[{]=", regex_constants::optimize);
 Toke_MeditationS::Toke_MeditationS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MeditationS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MeditationS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"MeditationS");
#endif
}

 Toke_MeditationS::~Toke_MeditationS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"MeditationS");
#endif
}

SkoarToke* Toke_MeditationS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MeditationS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MeditationS(s, offs, s.length());
}

const std::wregex Toke_MsgName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*(?!<)", regex_constants::optimize);
 Toke_MsgName::Toke_MsgName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgName;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgName>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"MsgName");
#endif
}

 Toke_MsgName::~Toke_MsgName() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"MsgName");
#endif
}

SkoarToke* Toke_MsgName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgName(s, offs, s.length());
}

const std::wregex Toke_MsgNameWithArgs::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*<", regex_constants::optimize);
 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgNameWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgNameWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"MsgNameWithArgs");
#endif
}

 Toke_MsgNameWithArgs::~Toke_MsgNameWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"MsgNameWithArgs");
#endif
}

SkoarToke* Toke_MsgNameWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgNameWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgNameWithArgs(s, offs, s.length());
}

const std::wregex Toke_MsgOp::rgx = wregex(L"\\.(?![)\\]])", regex_constants::optimize);
 Toke_MsgOp::Toke_MsgOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgOp>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"MsgOp");
#endif
}

 Toke_MsgOp::~Toke_MsgOp() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"MsgOp");
#endif
}

SkoarToke* Toke_MsgOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgOp(s, offs, s.length());
}

const std::wregex Toke_NamedNoat::rgx = wregex(L"(?:_?)(?:[a-g](?![ac-zA-Z_]))(#|b)?(?![ \\t]*:(?![}:|]))", regex_constants::optimize);
 Toke_NamedNoat::Toke_NamedNoat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::NamedNoat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::NamedNoat>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"NamedNoat");
#endif
}

 Toke_NamedNoat::~Toke_NamedNoat() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"NamedNoat");
#endif
}

SkoarToke* Toke_NamedNoat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_NamedNoat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_NamedNoat(s, offs, s.length());
}

const std::wregex Toke_Newline::rgx = wregex(L"[ \\t]*[\\n\\r][\\n\\r \\t]*", regex_constants::optimize);
 Toke_Newline::Toke_Newline(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Newline;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Newline>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Newline");
#endif
}

 Toke_Newline::~Toke_Newline() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Newline");
#endif
}

SkoarToke* Toke_Newline::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Newline::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Newline(s, offs, s.length());
}

const std::wregex Toke_Nosey::rgx = wregex(L",", regex_constants::optimize);
 Toke_Nosey::Toke_Nosey(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Nosey;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Nosey>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Nosey");
#endif
}

 Toke_Nosey::~Toke_Nosey() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Nosey");
#endif
}

SkoarToke* Toke_Nosey::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Nosey::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Nosey(s, offs, s.length());
}

const std::wregex Toke_OctaveShift::rgx = wregex(L"~+o|o~+", regex_constants::optimize);
 Toke_OctaveShift::Toke_OctaveShift(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OctaveShift;
    this->style = SkoarStyles::Toke::style<ESkoarToke::OctaveShift>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"OctaveShift");
#endif
}

 Toke_OctaveShift::~Toke_OctaveShift() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"OctaveShift");
#endif
}

SkoarToke* Toke_OctaveShift::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OctaveShift::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OctaveShift(s, offs, s.length());
}

const std::wregex Toke_Quarters::rgx = wregex(L"\\.?[)]+(?:__?)?\\.?", regex_constants::optimize);
 Toke_Quarters::Toke_Quarters(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quarters;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Quarters>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Quarters");
#endif
}

 Toke_Quarters::~Toke_Quarters() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Quarters");
#endif
}

SkoarToke* Toke_Quarters::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quarters::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quarters(s, offs, s.length());
}

const std::wregex Toke_Quavers::rgx = wregex(L"o+/\\.?", regex_constants::optimize);
 Toke_Quavers::Toke_Quavers(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quavers;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Quavers>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Quavers");
#endif
}

 Toke_Quavers::~Toke_Quavers() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Quavers");
#endif
}

SkoarToke* Toke_Quavers::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quavers::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quavers(s, offs, s.length());
}

const std::wregex Toke_RWing::rgx = wregex(L"[)]\\^\\^", regex_constants::optimize);
 Toke_RWing::Toke_RWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::RWing;
    this->style = SkoarStyles::Toke::style<ESkoarToke::RWing>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"RWing");
#endif
}

 Toke_RWing::~Toke_RWing() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"RWing");
#endif
}

SkoarToke* Toke_RWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_RWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_RWing(s, offs, s.length());
}

const std::wregex Toke_Semicolon::rgx = wregex(L";", regex_constants::optimize);
 Toke_Semicolon::Toke_Semicolon(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Semicolon;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Semicolon>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Semicolon");
#endif
}

 Toke_Semicolon::~Toke_Semicolon() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Semicolon");
#endif
}

SkoarToke* Toke_Semicolon::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Semicolon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Semicolon(s, offs, s.length());
}

const std::wregex Toke_SkoarpionArgs::rgx = wregex(L"!!", regex_constants::optimize);
 Toke_SkoarpionArgs::Toke_SkoarpionArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"SkoarpionArgs");
#endif
}

 Toke_SkoarpionArgs::~Toke_SkoarpionArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"SkoarpionArgs");
#endif
}

SkoarToke* Toke_SkoarpionArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionArgs(s, offs, s.length());
}

const std::wregex Toke_SkoarpionEnd::rgx = wregex(L"![}]", regex_constants::optimize);
 Toke_SkoarpionEnd::Toke_SkoarpionEnd(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionEnd;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionEnd>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"SkoarpionEnd");
#endif
}

 Toke_SkoarpionEnd::~Toke_SkoarpionEnd() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"SkoarpionEnd");
#endif
}

SkoarToke* Toke_SkoarpionEnd::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionEnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionEnd(s, offs, s.length());
}

const std::wregex Toke_SkoarpionStart::rgx = wregex(L"[{]!", regex_constants::optimize);
 Toke_SkoarpionStart::Toke_SkoarpionStart(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionStart;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionStart>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"SkoarpionStart");
#endif
}

 Toke_SkoarpionStart::~Toke_SkoarpionStart() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"SkoarpionStart");
#endif
}

SkoarToke* Toke_SkoarpionStart::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStart::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionStart(s, offs, s.length());
}

const std::wregex Toke_String::rgx = wregex(L"'[^']*'", regex_constants::optimize);
 Toke_String::Toke_String(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::String;
    this->style = SkoarStyles::Toke::style<ESkoarToke::String>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"String");
#endif
}

 Toke_String::~Toke_String() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"String");
#endif
}

SkoarToke* Toke_String::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_String::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_String(s, offs, s.length());
}

const std::wregex Toke_Symbol::rgx = wregex(L"@[a-zA-Z0-9_][a-zA-Z0-9_]*", regex_constants::optimize);
 Toke_Symbol::Toke_Symbol(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Symbol;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Symbol>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Symbol");
#endif
}

 Toke_Symbol::~Toke_Symbol() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Symbol");
#endif
}

SkoarToke* Toke_Symbol::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Symbol::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Symbol(s, offs, s.length());
}

const std::wregex Toke_SymbolColon::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*[ \\t]*:(?![:|}])", regex_constants::optimize);
 Toke_SymbolColon::Toke_SymbolColon(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolColon;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SymbolColon>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"SymbolColon");
#endif
}

 Toke_SymbolColon::~Toke_SymbolColon() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"SymbolColon");
#endif
}

SkoarToke* Toke_SymbolColon::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolColon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SymbolColon(s, offs, s.length());
}

const std::wregex Toke_SymbolName::rgx = wregex(L"[a-zA-Z0-9_][a-zA-Z0-9_]*(?![[a-zA-Z0-9_fi \\t]*:)", regex_constants::optimize);
 Toke_SymbolName::Toke_SymbolName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolName;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SymbolName>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"SymbolName");
#endif
}

 Toke_SymbolName::~Toke_SymbolName() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"SymbolName");
#endif
}

SkoarToke* Toke_SymbolName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SymbolName(s, offs, s.length());
}

const std::wregex Toke_Times::rgx = wregex(L"[Tt]imes", regex_constants::optimize);
 Toke_Times::Toke_Times(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Times;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Times>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Times");
#endif
}

 Toke_Times::~Toke_Times() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Times");
#endif
}

SkoarToke* Toke_Times::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Times::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Times(s, offs, s.length());
}

const std::wregex Toke_True::rgx = wregex(L"yes|true", regex_constants::optimize);
 Toke_True::Toke_True(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::True;
    this->style = SkoarStyles::Toke::style<ESkoarToke::True>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"True");
#endif
}

 Toke_True::~Toke_True() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"True");
#endif
}

SkoarToke* Toke_True::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_True::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_True(s, offs, s.length());
}

const std::wregex Toke_Tuplet::rgx = wregex(L"/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?", regex_constants::optimize);
 Toke_Tuplet::Toke_Tuplet(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Tuplet;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Tuplet>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Tuplet");
#endif
}

 Toke_Tuplet::~Toke_Tuplet() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Tuplet");
#endif
}

SkoarToke* Toke_Tuplet::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Tuplet::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Tuplet(s, offs, s.length());
}

const std::wregex Toke_Voice::rgx = wregex(L"\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)", regex_constants::optimize);
 Toke_Voice::Toke_Voice(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Voice;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Voice>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().allocToke(L"Voice");
#endif
}

 Toke_Voice::~Toke_Voice() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories::o().deallocToke(L"Voice");
#endif
}

SkoarToke* Toke_Voice::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Voice::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Voice(s, offs, s.length());
}


   
SkoarDispensary::SkoarDispensary() :
   table({
        { ESkoarToke::AUGen, 
            [](wstring *buf, size_t offs) {
                return Toke_AUGen::match_toke(buf, offs);
            }
        },
        { ESkoarToke::AUGenWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_AUGenWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::AlCoda, 
            [](wstring *buf, size_t offs) {
                return Toke_AlCoda::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Bars, 
            [](wstring *buf, size_t offs) {
                return Toke_Bars::match_toke(buf, offs);
            }
        },
        { ESkoarToke::BooleanAnd, 
            [](wstring *buf, size_t offs) {
                return Toke_BooleanAnd::match_toke(buf, offs);
            }
        },
        { ESkoarToke::BooleanOr, 
            [](wstring *buf, size_t offs) {
                return Toke_BooleanOr::match_toke(buf, offs);
            }
        },
        { ESkoarToke::BracketE, 
            [](wstring *buf, size_t offs) {
                return Toke_BracketE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::BracketS, 
            [](wstring *buf, size_t offs) {
                return Toke_BracketS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Carrot, 
            [](wstring *buf, size_t offs) {
                return Toke_Carrot::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Cat, 
            [](wstring *buf, size_t offs) {
                return Toke_Cat::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Choard, 
            [](wstring *buf, size_t offs) {
                return Toke_Choard::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CmpEqNeq, 
            [](wstring *buf, size_t offs) {
                return Toke_CmpEqNeq::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CmpGtLt, 
            [](wstring *buf, size_t offs) {
                return Toke_CmpGtLt::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Coda, 
            [](wstring *buf, size_t offs) {
                return Toke_Coda::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Comment, 
            [](wstring *buf, size_t offs) {
                return Toke_Comment::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CondE, 
            [](wstring *buf, size_t offs) {
                return Toke_CondE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CondIf, 
            [](wstring *buf, size_t offs) {
                return Toke_CondIf::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CondS, 
            [](wstring *buf, size_t offs) {
                return Toke_CondS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Crotchets, 
            [](wstring *buf, size_t offs) {
                return Toke_Crotchets::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DUGen, 
            [](wstring *buf, size_t offs) {
                return Toke_DUGen::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DUGenWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_DUGenWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Deref, 
            [](wstring *buf, size_t offs) {
                return Toke_Deref::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Duration, 
            [](wstring *buf, size_t offs) {
                return Toke_Duration::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Eighths, 
            [](wstring *buf, size_t offs) {
                return Toke_Eighths::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ExactBeat, 
            [](wstring *buf, size_t offs) {
                return Toke_ExactBeat::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ExactRest, 
            [](wstring *buf, size_t offs) {
                return Toke_ExactRest::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ExpoartsE, 
            [](wstring *buf, size_t offs) {
                return Toke_ExpoartsE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ExpoartsS, 
            [](wstring *buf, size_t offs) {
                return Toke_ExpoartsS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Fairy, 
            [](wstring *buf, size_t offs) {
                return Toke_Fairy::match_toke(buf, offs);
            }
        },
        { ESkoarToke::False, 
            [](wstring *buf, size_t offs) {
                return Toke_False::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Float, 
            [](wstring *buf, size_t offs) {
                return Toke_Float::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Freq, 
            [](wstring *buf, size_t offs) {
                return Toke_Freq::match_toke(buf, offs);
            }
        },
        { ESkoarToke::HashLevel, 
            [](wstring *buf, size_t offs) {
                return Toke_HashLevel::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Int, 
            [](wstring *buf, size_t offs) {
                return Toke_Int::match_toke(buf, offs);
            }
        },
        { ESkoarToke::KUGen, 
            [](wstring *buf, size_t offs) {
                return Toke_KUGen::match_toke(buf, offs);
            }
        },
        { ESkoarToke::KUGenWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_KUGenWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LWing, 
            [](wstring *buf, size_t offs) {
                return Toke_LWing::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ListE, 
            [](wstring *buf, size_t offs) {
                return Toke_ListE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ListS, 
            [](wstring *buf, size_t offs) {
                return Toke_ListS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ListSep, 
            [](wstring *buf, size_t offs) {
                return Toke_ListSep::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LoopE, 
            [](wstring *buf, size_t offs) {
                return Toke_LoopE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LoopS, 
            [](wstring *buf, size_t offs) {
                return Toke_LoopS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LoopSep, 
            [](wstring *buf, size_t offs) {
                return Toke_LoopSep::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Lute, 
            [](wstring *buf, size_t offs) {
                return Toke_Lute::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LuteWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_LuteWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MathOpAddSub, 
            [](wstring *buf, size_t offs) {
                return Toke_MathOpAddSub::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MathOpMulDivMod, 
            [](wstring *buf, size_t offs) {
                return Toke_MathOpMulDivMod::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MeditationE, 
            [](wstring *buf, size_t offs) {
                return Toke_MeditationE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MeditationS, 
            [](wstring *buf, size_t offs) {
                return Toke_MeditationS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MsgName, 
            [](wstring *buf, size_t offs) {
                return Toke_MsgName::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MsgNameWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_MsgNameWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MsgOp, 
            [](wstring *buf, size_t offs) {
                return Toke_MsgOp::match_toke(buf, offs);
            }
        },
        { ESkoarToke::NamedNoat, 
            [](wstring *buf, size_t offs) {
                return Toke_NamedNoat::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Newline, 
            [](wstring *buf, size_t offs) {
                return Toke_Newline::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Nosey, 
            [](wstring *buf, size_t offs) {
                return Toke_Nosey::match_toke(buf, offs);
            }
        },
        { ESkoarToke::OctaveShift, 
            [](wstring *buf, size_t offs) {
                return Toke_OctaveShift::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Quarters, 
            [](wstring *buf, size_t offs) {
                return Toke_Quarters::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Quavers, 
            [](wstring *buf, size_t offs) {
                return Toke_Quavers::match_toke(buf, offs);
            }
        },
        { ESkoarToke::RWing, 
            [](wstring *buf, size_t offs) {
                return Toke_RWing::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Semicolon, 
            [](wstring *buf, size_t offs) {
                return Toke_Semicolon::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SkoarpionArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_SkoarpionArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SkoarpionEnd, 
            [](wstring *buf, size_t offs) {
                return Toke_SkoarpionEnd::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SkoarpionStart, 
            [](wstring *buf, size_t offs) {
                return Toke_SkoarpionStart::match_toke(buf, offs);
            }
        },
        { ESkoarToke::String, 
            [](wstring *buf, size_t offs) {
                return Toke_String::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Symbol, 
            [](wstring *buf, size_t offs) {
                return Toke_Symbol::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SymbolColon, 
            [](wstring *buf, size_t offs) {
                return Toke_SymbolColon::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SymbolName, 
            [](wstring *buf, size_t offs) {
                return Toke_SymbolName::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Times, 
            [](wstring *buf, size_t offs) {
                return Toke_Times::match_toke(buf, offs);
            }
        },
        { ESkoarToke::True, 
            [](wstring *buf, size_t offs) {
                return Toke_True::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Tuplet, 
            [](wstring *buf, size_t offs) {
                return Toke_Tuplet::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Voice, 
            [](wstring *buf, size_t offs) {
                return Toke_Voice::match_toke(buf, offs);
            }
        }
   })
{
}

SkoarToke* SkoarDispensary::match_toke(ESkoarToke::Kind want, wstring *buf, size_t offs) {
    auto f = table[want];
    if (f) 
        return f(buf, offs);
    return nullptr;
}
