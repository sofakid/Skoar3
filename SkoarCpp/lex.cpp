// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2015-08-03 14:35:26 for C++14
// ======================================================================
#include "lex.hpp"
#include "exception.hpp"
// ------------------
// Abstract SkoarToke
// ------------------
SkoarToke * SkoarToke::aninstance = nullptr;
SkoarToke * SkoarToke::instance() {
    if (aninstance == nullptr) {;
        aninstance = new SkoarToke();;
    };
    return aninstance;;
}

 SkoarToke::SkoarToke() {
}

 SkoarToke::SkoarToke(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

// how many characters to burn from the buffer
size_t SkoarToke::burn() {
    return size;
}

// we override and return nullptr for no match, new toke otherwise
SkoarToke* SkoarToke::match_toke(wstring * buf, size_t offs) {
    return nullptr;
}

// --------------
// EOF is special
// --------------
 Toke_EOF::Toke_EOF() {
    this->lexeme = nullptr;
    this->size = 0;
}

Toke_EOF * Toke_EOF::aninstance = nullptr;
Toke_EOF * Toke_EOF::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_EOF();;
    };
    return aninstance;;
}

size_t Toke_EOF::burn(wstring * buf, size_t offs) {
    if (buf->size() > offs) {
        throw new SkoarError(L"Tried to burn EOF when there's more input.");
    }

    return 0;
}

SkoarToke* Toke_EOF::match_toke(wstring * buf, size_t offs) {
    if (buf->size() == offs) {
        return new Toke_EOF();
    }

    return nullptr;
}

// ---------------------
// Whitespace is special
// ---------------------
 Toke_Whitespace::Toke_Whitespace() {
    this->lexeme = nullptr;
    this->size = 0;
}

Toke_Whitespace * Toke_Whitespace::aninstance = nullptr;
Toke_Whitespace * Toke_Whitespace::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Whitespace();;
    };
    return aninstance;;
}

const wregex Toke_Whitespace::rgx = wregex(L"[ \\t]+");

size_t Toke_Whitespace::burn(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Whitespace::rgx, regex_constants::match_continuous);
    if (!found) {
        return 0;
    }

    return matches[0].length();
}

// --------------
// Everyday Tokes
// --------------
const std::wregex Toke_SkoarpionSep::rgx = wregex(L"!!");
Toke_SkoarpionSep * Toke_SkoarpionSep::aninstance = nullptr;
Toke_SkoarpionSep * Toke_SkoarpionSep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SkoarpionSep();;
    };
    return aninstance;;
}

 Toke_SkoarpionSep::Toke_SkoarpionSep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SkoarpionSep::Toke_SkoarpionSep(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SkoarpionSep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SkoarpionSep(s,s->length());
}

const std::wregex Toke_DynForte::rgx = wregex(L"mf(orte)?|f+orte|ff+");
Toke_DynForte * Toke_DynForte::aninstance = nullptr;
Toke_DynForte * Toke_DynForte::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynForte();;
    };
    return aninstance;;
}

 Toke_DynForte::Toke_DynForte() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynForte::Toke_DynForte(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynForte::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynForte::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynForte(s,s->length());
}

const std::wregex Toke_DynFP::rgx = wregex(L"fp");
Toke_DynFP * Toke_DynFP::aninstance = nullptr;
Toke_DynFP * Toke_DynFP::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynFP();;
    };
    return aninstance;;
}

 Toke_DynFP::Toke_DynFP() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynFP::Toke_DynFP(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynFP::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynFP::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynFP(s,s->length());
}

const std::wregex Toke_SymbolName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*");
Toke_SymbolName * Toke_SymbolName::aninstance = nullptr;
Toke_SymbolName * Toke_SymbolName::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SymbolName();;
    };
    return aninstance;;
}

 Toke_SymbolName::Toke_SymbolName() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SymbolName::Toke_SymbolName(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SymbolName::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SymbolName(s,s->length());
}

const std::wregex Toke_ListE::rgx = wregex(L">");
Toke_ListE * Toke_ListE::aninstance = nullptr;
Toke_ListE * Toke_ListE::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_ListE();;
    };
    return aninstance;;
}

 Toke_ListE::Toke_ListE() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_ListE::Toke_ListE(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_ListE::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_ListE(s,s->length());
}

const std::wregex Toke_Newline::rgx = wregex(L"[\\n\\r\\f][\\n\\r\\f \\t]*");
Toke_Newline * Toke_Newline::aninstance = nullptr;
Toke_Newline * Toke_Newline::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Newline();;
    };
    return aninstance;;
}

 Toke_Newline::Toke_Newline() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Newline::Toke_Newline(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Newline::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Newline::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Newline(s,s->length());
}

const std::wregex Toke_CondS::rgx = wregex(L"[{][?][\\n]*");
Toke_CondS * Toke_CondS::aninstance = nullptr;
Toke_CondS * Toke_CondS::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_CondS();;
    };
    return aninstance;;
}

 Toke_CondS::Toke_CondS() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_CondS::Toke_CondS(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_CondS::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_CondS(s,s->length());
}

const std::wregex Toke_MsgNameWithArgs::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*<");
Toke_MsgNameWithArgs * Toke_MsgNameWithArgs::aninstance = nullptr;
Toke_MsgNameWithArgs * Toke_MsgNameWithArgs::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MsgNameWithArgs();;
    };
    return aninstance;;
}

 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MsgNameWithArgs::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgNameWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MsgNameWithArgs(s,s->length());
}

const std::wregex Toke_ListS::rgx = wregex(L"<(?![=?])");
Toke_ListS * Toke_ListS::aninstance = nullptr;
Toke_ListS * Toke_ListS::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_ListS();;
    };
    return aninstance;;
}

 Toke_ListS::Toke_ListS() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_ListS::Toke_ListS(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_ListS::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_ListS(s,s->length());
}

const std::wregex Toke_PedalDown::rgx = wregex(L"Ped\\.?");
Toke_PedalDown * Toke_PedalDown::aninstance = nullptr;
Toke_PedalDown * Toke_PedalDown::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_PedalDown();;
    };
    return aninstance;;
}

 Toke_PedalDown::Toke_PedalDown() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_PedalDown::Toke_PedalDown(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_PedalDown::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalDown::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_PedalDown(s,s->length());
}

const std::wregex Toke_Nosey::rgx = wregex(L",");
Toke_Nosey * Toke_Nosey::aninstance = nullptr;
Toke_Nosey * Toke_Nosey::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Nosey();;
    };
    return aninstance;;
}

 Toke_Nosey::Toke_Nosey() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Nosey::Toke_Nosey(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Nosey::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Nosey::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Nosey(s,s->length());
}

const std::wregex Toke_LoopS::rgx = wregex(L"[{]:[\\n]*");
Toke_LoopS * Toke_LoopS::aninstance = nullptr;
Toke_LoopS * Toke_LoopS::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LoopS();;
    };
    return aninstance;;
}

 Toke_LoopS::Toke_LoopS() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LoopS::Toke_LoopS(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LoopS::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LoopS(s,s->length());
}

const std::wregex Toke_Carrot::rgx = wregex(L"\\^(?!\\^[(])");
Toke_Carrot * Toke_Carrot::aninstance = nullptr;
Toke_Carrot * Toke_Carrot::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Carrot();;
    };
    return aninstance;;
}

 Toke_Carrot::Toke_Carrot() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Carrot::Toke_Carrot(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Carrot::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Carrot::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Carrot(s,s->length());
}

const std::wregex Toke_Crotchets::rgx = wregex(L"[}]+\\.?");
Toke_Crotchets * Toke_Crotchets::aninstance = nullptr;
Toke_Crotchets * Toke_Crotchets::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Crotchets();;
    };
    return aninstance;;
}

 Toke_Crotchets::Toke_Crotchets() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Crotchets::Toke_Crotchets(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Crotchets::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crotchets::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Crotchets(s,s->length());
}

const std::wregex Toke_Loco::rgx = wregex(L"loco");
Toke_Loco * Toke_Loco::aninstance = nullptr;
Toke_Loco * Toke_Loco::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Loco();;
    };
    return aninstance;;
}

 Toke_Loco::Toke_Loco() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Loco::Toke_Loco(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Loco::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Loco::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Loco(s,s->length());
}

const std::wregex Toke_AssOp::rgx = wregex(L"=>|[+]>|->");
Toke_AssOp * Toke_AssOp::aninstance = nullptr;
Toke_AssOp * Toke_AssOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AssOp();;
    };
    return aninstance;;
}

 Toke_AssOp::Toke_AssOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AssOp::Toke_AssOp(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AssOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AssOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AssOp(s,s->length());
}

const std::wregex Toke_AlCoda::rgx = wregex(L"al(la)? coda");
Toke_AlCoda * Toke_AlCoda::aninstance = nullptr;
Toke_AlCoda * Toke_AlCoda::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AlCoda();;
    };
    return aninstance;;
}

 Toke_AlCoda::Toke_AlCoda() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AlCoda::Toke_AlCoda(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AlCoda::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlCoda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AlCoda(s,s->length());
}

const std::wregex Toke_Symbol::rgx = wregex(L"[\\\\@][a-zA-Z_][a-zA-Z0-9_]*");
Toke_Symbol * Toke_Symbol::aninstance = nullptr;
Toke_Symbol * Toke_Symbol::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Symbol();;
    };
    return aninstance;;
}

 Toke_Symbol::Toke_Symbol() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Symbol::Toke_Symbol(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Symbol::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Symbol::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Symbol(s,s->length());
}

const std::wregex Toke_Caesura::rgx = wregex(L"//");
Toke_Caesura * Toke_Caesura::aninstance = nullptr;
Toke_Caesura * Toke_Caesura::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Caesura();;
    };
    return aninstance;;
}

 Toke_Caesura::Toke_Caesura() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Caesura::Toke_Caesura(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Caesura::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Caesura::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Caesura(s,s->length());
}

const std::wregex Toke_String::rgx = wregex(L"'[^']*'");
Toke_String * Toke_String::aninstance = nullptr;
Toke_String * Toke_String::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_String();;
    };
    return aninstance;;
}

 Toke_String::Toke_String() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_String::Toke_String(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_String::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_String::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_String(s,s->length());
}

const std::wregex Toke_ListSep::rgx = wregex(L",");
Toke_ListSep * Toke_ListSep::aninstance = nullptr;
Toke_ListSep * Toke_ListSep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_ListSep();;
    };
    return aninstance;;
}

 Toke_ListSep::Toke_ListSep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_ListSep::Toke_ListSep(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_ListSep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_ListSep(s,s->length());
}

const std::wregex Toke_OttavaB::rgx = wregex(L"8vb|ottava (bassa|sotto)");
Toke_OttavaB * Toke_OttavaB::aninstance = nullptr;
Toke_OttavaB * Toke_OttavaB::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_OttavaB();;
    };
    return aninstance;;
}

 Toke_OttavaB::Toke_OttavaB() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_OttavaB::Toke_OttavaB(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_OttavaB::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_OttavaB(s,s->length());
}

const std::wregex Toke_MsgName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*(?!<)");
Toke_MsgName * Toke_MsgName::aninstance = nullptr;
Toke_MsgName * Toke_MsgName::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MsgName();;
    };
    return aninstance;;
}

 Toke_MsgName::Toke_MsgName() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MsgName::Toke_MsgName(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MsgName::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MsgName(s,s->length());
}

const std::wregex Toke_Int::rgx = wregex(L"(-)?(0|[1-9][0-9]*)(?!Hz|[mv][ab]|\\.[0-9]|/)");
Toke_Int * Toke_Int::aninstance = nullptr;
Toke_Int * Toke_Int::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Int();;
    };
    return aninstance;;
}

 Toke_Int::Toke_Int() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Int::Toke_Int(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Int::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Int::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Int(s,s->length());
}

const std::wregex Toke_MathOp::rgx = wregex(L"[+x\\-](?!>)");
Toke_MathOp * Toke_MathOp::aninstance = nullptr;
Toke_MathOp * Toke_MathOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MathOp();;
    };
    return aninstance;;
}

 Toke_MathOp::Toke_MathOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MathOp::Toke_MathOp(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MathOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MathOp(s,s->length());
}

const std::wregex Toke_LoopE::rgx = wregex(L":[}]");
Toke_LoopE * Toke_LoopE::aninstance = nullptr;
Toke_LoopE * Toke_LoopE::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LoopE();;
    };
    return aninstance;;
}

 Toke_LoopE::Toke_LoopE() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LoopE::Toke_LoopE(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LoopE::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LoopE(s,s->length());
}

const std::wregex Toke_NamedNoat::rgx = wregex(L"(?:_?)(?:[a-eg]|f(?![ac-zA-Z_]))(#*|b*)");
Toke_NamedNoat * Toke_NamedNoat::aninstance = nullptr;
Toke_NamedNoat * Toke_NamedNoat::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_NamedNoat();;
    };
    return aninstance;;
}

 Toke_NamedNoat::Toke_NamedNoat() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_NamedNoat::Toke_NamedNoat(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_NamedNoat::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_NamedNoat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_NamedNoat(s,s->length());
}

const std::wregex Toke_DaCapo::rgx = wregex(L"D\\.C\\.|Da Capo");
Toke_DaCapo * Toke_DaCapo::aninstance = nullptr;
Toke_DaCapo * Toke_DaCapo::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DaCapo();;
    };
    return aninstance;;
}

 Toke_DaCapo::Toke_DaCapo() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DaCapo::Toke_DaCapo(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DaCapo::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DaCapo::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DaCapo(s,s->length());
}

const std::wregex Toke_Choard::rgx = wregex(L"(D(?![a.])|[ABCEFG])([Mm0-9]|sus|dim)*");
Toke_Choard * Toke_Choard::aninstance = nullptr;
Toke_Choard * Toke_Choard::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Choard();;
    };
    return aninstance;;
}

 Toke_Choard::Toke_Choard() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Choard::Toke_Choard(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Choard::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Choard::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Choard(s,s->length());
}

const std::wregex Toke_Semicolon::rgx = wregex(L";");
Toke_Semicolon * Toke_Semicolon::aninstance = nullptr;
Toke_Semicolon * Toke_Semicolon::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Semicolon();;
    };
    return aninstance;;
}

 Toke_Semicolon::Toke_Semicolon() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Semicolon::Toke_Semicolon(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Semicolon::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Semicolon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Semicolon(s,s->length());
}

const std::wregex Toke_Portamento::rgx = wregex(L"port\\.?");
Toke_Portamento * Toke_Portamento::aninstance = nullptr;
Toke_Portamento * Toke_Portamento::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Portamento();;
    };
    return aninstance;;
}

 Toke_Portamento::Toke_Portamento() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Portamento::Toke_Portamento(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Portamento::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Portamento::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Portamento(s,s->length());
}

const std::wregex Toke_Meter::rgx = wregex(L"[1-9][0-9]*/[1-9][0-9]*");
Toke_Meter * Toke_Meter::aninstance = nullptr;
Toke_Meter * Toke_Meter::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Meter();;
    };
    return aninstance;;
}

 Toke_Meter::Toke_Meter() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Meter::Toke_Meter(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Meter::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Meter::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Meter(s,s->length());
}

const std::wregex Toke_Quarters::rgx = wregex(L"\\.?[)]+(?:__?)?\\.?");
Toke_Quarters * Toke_Quarters::aninstance = nullptr;
Toke_Quarters * Toke_Quarters::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Quarters();;
    };
    return aninstance;;
}

 Toke_Quarters::Toke_Quarters() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Quarters::Toke_Quarters(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Quarters::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quarters::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Quarters(s,s->length());
}

const std::wregex Toke_Bars::rgx = wregex(L":?\\|+:?");
Toke_Bars * Toke_Bars::aninstance = nullptr;
Toke_Bars * Toke_Bars::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Bars();;
    };
    return aninstance;;
}

 Toke_Bars::Toke_Bars() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Bars::Toke_Bars(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Bars::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Bars::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Bars(s,s->length());
}

const std::wregex Toke_Rep::rgx = wregex(L"%+");
Toke_Rep * Toke_Rep::aninstance = nullptr;
Toke_Rep * Toke_Rep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Rep();;
    };
    return aninstance;;
}

 Toke_Rep::Toke_Rep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Rep::Toke_Rep(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Rep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Rep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Rep(s,s->length());
}

const std::wregex Toke_LWing::rgx = wregex(L"\\^\\^[(]");
Toke_LWing * Toke_LWing::aninstance = nullptr;
Toke_LWing * Toke_LWing::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LWing();;
    };
    return aninstance;;
}

 Toke_LWing::Toke_LWing() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LWing::Toke_LWing(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LWing::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LWing(s,s->length());
}

const std::wregex Toke_Volta::rgx = wregex(L"\\[\\d+\\.\\]");
Toke_Volta * Toke_Volta::aninstance = nullptr;
Toke_Volta * Toke_Volta::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Volta();;
    };
    return aninstance;;
}

 Toke_Volta::Toke_Volta() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Volta::Toke_Volta(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Volta::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Volta::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Volta(s,s->length());
}

const std::wregex Toke_AlSegno::rgx = wregex(L"al segno");
Toke_AlSegno * Toke_AlSegno::aninstance = nullptr;
Toke_AlSegno * Toke_AlSegno::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AlSegno();;
    };
    return aninstance;;
}

 Toke_AlSegno::Toke_AlSegno() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AlSegno::Toke_AlSegno(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AlSegno::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AlSegno(s,s->length());
}

const std::wregex Toke_BooleanOp::rgx = wregex(L"==|!=|<(?!=)|<=|>(?!=)|>=|and|or|xor");
Toke_BooleanOp * Toke_BooleanOp::aninstance = nullptr;
Toke_BooleanOp * Toke_BooleanOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_BooleanOp();;
    };
    return aninstance;;
}

 Toke_BooleanOp::Toke_BooleanOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_BooleanOp::Toke_BooleanOp(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_BooleanOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_BooleanOp(s,s->length());
}

const std::wregex Toke_DynSFZ::rgx = wregex(L"sfz");
Toke_DynSFZ * Toke_DynSFZ::aninstance = nullptr;
Toke_DynSFZ * Toke_DynSFZ::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynSFZ();;
    };
    return aninstance;;
}

 Toke_DynSFZ::Toke_DynSFZ() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynSFZ::Toke_DynSFZ(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynSFZ::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynSFZ::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynSFZ(s,s->length());
}

const std::wregex Toke_DalSegno::rgx = wregex(L"D\\.S\\.|Dal Segno");
Toke_DalSegno * Toke_DalSegno::aninstance = nullptr;
Toke_DalSegno * Toke_DalSegno::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DalSegno();;
    };
    return aninstance;;
}

 Toke_DalSegno::Toke_DalSegno() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DalSegno::Toke_DalSegno(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DalSegno::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DalSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DalSegno(s,s->length());
}

const std::wregex Toke_Quavers::rgx = wregex(L"o+/\\.?");
Toke_Quavers * Toke_Quavers::aninstance = nullptr;
Toke_Quavers * Toke_Quavers::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Quavers();;
    };
    return aninstance;;
}

 Toke_Quavers::Toke_Quavers() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Quavers::Toke_Quavers(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Quavers::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quavers::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Quavers(s,s->length());
}

const std::wregex Toke_Comment::rgx = wregex(L"<[?](.|[\\n\\r\\f])*?[?]>");
Toke_Comment * Toke_Comment::aninstance = nullptr;
Toke_Comment * Toke_Comment::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Comment();;
    };
    return aninstance;;
}

 Toke_Comment::Toke_Comment() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Comment::Toke_Comment(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Comment::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Comment::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Comment(s,s->length());
}

const std::wregex Toke_CondIf::rgx = wregex(L"[?][?](?![}])");
Toke_CondIf * Toke_CondIf::aninstance = nullptr;
Toke_CondIf * Toke_CondIf::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_CondIf();;
    };
    return aninstance;;
}

 Toke_CondIf::Toke_CondIf() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_CondIf::Toke_CondIf(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_CondIf::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondIf::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_CondIf(s,s->length());
}

const std::wregex Toke_MsgOp::rgx = wregex(L"\\.(?![)\\]])");
Toke_MsgOp * Toke_MsgOp::aninstance = nullptr;
Toke_MsgOp * Toke_MsgOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MsgOp();;
    };
    return aninstance;;
}

 Toke_MsgOp::Toke_MsgOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MsgOp::Toke_MsgOp(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MsgOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MsgOp(s,s->length());
}

const std::wregex Toke_PedalUp::rgx = wregex(L"[*](?!>)");
Toke_PedalUp * Toke_PedalUp::aninstance = nullptr;
Toke_PedalUp * Toke_PedalUp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_PedalUp();;
    };
    return aninstance;;
}

 Toke_PedalUp::Toke_PedalUp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_PedalUp::Toke_PedalUp(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_PedalUp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalUp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_PedalUp(s,s->length());
}

const std::wregex Toke_Tuplet::rgx = wregex(L"/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?");
Toke_Tuplet * Toke_Tuplet::aninstance = nullptr;
Toke_Tuplet * Toke_Tuplet::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Tuplet();;
    };
    return aninstance;;
}

 Toke_Tuplet::Toke_Tuplet() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Tuplet::Toke_Tuplet(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Tuplet::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Tuplet::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Tuplet(s,s->length());
}

const std::wregex Toke_Deref::rgx = wregex(L"!(?![!}]|=)");
Toke_Deref * Toke_Deref::aninstance = nullptr;
Toke_Deref * Toke_Deref::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Deref();;
    };
    return aninstance;;
}

 Toke_Deref::Toke_Deref() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Deref::Toke_Deref(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Deref::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Deref::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Deref(s,s->length());
}

const std::wregex Toke_Coda::rgx = wregex(L"\\([+]\\)");
Toke_Coda * Toke_Coda::aninstance = nullptr;
Toke_Coda * Toke_Coda::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Coda();;
    };
    return aninstance;;
}

 Toke_Coda::Toke_Coda() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Coda::Toke_Coda(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Coda::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Coda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Coda(s,s->length());
}

const std::wregex Toke_Slash::rgx = wregex(L"/(?![/0-9])");
Toke_Slash * Toke_Slash::aninstance = nullptr;
Toke_Slash * Toke_Slash::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Slash();;
    };
    return aninstance;;
}

 Toke_Slash::Toke_Slash() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Slash::Toke_Slash(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Slash::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Slash::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Slash(s,s->length());
}

const std::wregex Toke_Voice::rgx = wregex(L"\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)");
Toke_Voice * Toke_Voice::aninstance = nullptr;
Toke_Voice * Toke_Voice::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Voice();;
    };
    return aninstance;;
}

 Toke_Voice::Toke_Voice() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Voice::Toke_Voice(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Voice::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Voice::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Voice(s,s->length());
}

const std::wregex Toke_SkoarpionEnd::rgx = wregex(L"![}]");
Toke_SkoarpionEnd * Toke_SkoarpionEnd::aninstance = nullptr;
Toke_SkoarpionEnd * Toke_SkoarpionEnd::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SkoarpionEnd();;
    };
    return aninstance;;
}

 Toke_SkoarpionEnd::Toke_SkoarpionEnd() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SkoarpionEnd::Toke_SkoarpionEnd(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SkoarpionEnd::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionEnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SkoarpionEnd(s,s->length());
}

const std::wregex Toke_Eighths::rgx = wregex(L"\\.?\\]+(?:__?)?\\.?");
Toke_Eighths * Toke_Eighths::aninstance = nullptr;
Toke_Eighths * Toke_Eighths::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Eighths();;
    };
    return aninstance;;
}

 Toke_Eighths::Toke_Eighths() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Eighths::Toke_Eighths(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Eighths::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Eighths::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Eighths(s,s->length());
}

const std::wregex Toke_SkoarpionStart::rgx = wregex(L"[{]!");
Toke_SkoarpionStart * Toke_SkoarpionStart::aninstance = nullptr;
Toke_SkoarpionStart * Toke_SkoarpionStart::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SkoarpionStart();;
    };
    return aninstance;;
}

 Toke_SkoarpionStart::Toke_SkoarpionStart() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SkoarpionStart::Toke_SkoarpionStart(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SkoarpionStart::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStart::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SkoarpionStart(s,s->length());
}

const std::wregex Toke_AlFine::rgx = wregex(L"al fine");
Toke_AlFine * Toke_AlFine::aninstance = nullptr;
Toke_AlFine * Toke_AlFine::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AlFine();;
    };
    return aninstance;;
}

 Toke_AlFine::Toke_AlFine() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AlFine::Toke_AlFine(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AlFine::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlFine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AlFine(s,s->length());
}

const std::wregex Toke_CondE::rgx = wregex(L"[?][}]");
Toke_CondE * Toke_CondE::aninstance = nullptr;
Toke_CondE * Toke_CondE::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_CondE();;
    };
    return aninstance;;
}

 Toke_CondE::Toke_CondE() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_CondE::Toke_CondE(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_CondE::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_CondE(s,s->length());
}

const std::wregex Toke_Fairy::rgx = wregex(L"[$]");
Toke_Fairy * Toke_Fairy::aninstance = nullptr;
Toke_Fairy * Toke_Fairy::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Fairy();;
    };
    return aninstance;;
}

 Toke_Fairy::Toke_Fairy() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Fairy::Toke_Fairy(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Fairy::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fairy::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Fairy(s,s->length());
}

const std::wregex Toke_RWing::rgx = wregex(L"[)]\\^\\^");
Toke_RWing * Toke_RWing::aninstance = nullptr;
Toke_RWing * Toke_RWing::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_RWing();;
    };
    return aninstance;;
}

 Toke_RWing::Toke_RWing() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_RWing::Toke_RWing(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_RWing::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_RWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_RWing(s,s->length());
}

const std::wregex Toke_LoopSep::rgx = wregex(L"::[\\n]*(?![|])");
Toke_LoopSep * Toke_LoopSep::aninstance = nullptr;
Toke_LoopSep * Toke_LoopSep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LoopSep();;
    };
    return aninstance;;
}

 Toke_LoopSep::Toke_LoopSep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LoopSep::Toke_LoopSep(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LoopSep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LoopSep(s,s->length());
}

const std::wregex Toke_OttavaA::rgx = wregex(L"8va|ottava (alta|sopra)|all' ottava");
Toke_OttavaA * Toke_OttavaA::aninstance = nullptr;
Toke_OttavaA * Toke_OttavaA::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_OttavaA();;
    };
    return aninstance;;
}

 Toke_OttavaA::Toke_OttavaA() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_OttavaA::Toke_OttavaA(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_OttavaA::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_OttavaA(s,s->length());
}

const std::wregex Toke_QuindicesimaB::rgx = wregex(L"15mb");
Toke_QuindicesimaB * Toke_QuindicesimaB::aninstance = nullptr;
Toke_QuindicesimaB * Toke_QuindicesimaB::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_QuindicesimaB();;
    };
    return aninstance;;
}

 Toke_QuindicesimaB::Toke_QuindicesimaB() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_QuindicesimaB::Toke_QuindicesimaB(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_QuindicesimaB::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_QuindicesimaB(s,s->length());
}

const std::wregex Toke_Float::rgx = wregex(L"(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz)");
Toke_Float * Toke_Float::aninstance = nullptr;
Toke_Float * Toke_Float::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Float();;
    };
    return aninstance;;
}

 Toke_Float::Toke_Float() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Float::Toke_Float(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Float::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Float::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Float(s,s->length());
}

const std::wregex Toke_OctaveShift::rgx = wregex(L"~+o|o~+");
Toke_OctaveShift * Toke_OctaveShift::aninstance = nullptr;
Toke_OctaveShift * Toke_OctaveShift::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_OctaveShift();;
    };
    return aninstance;;
}

 Toke_OctaveShift::Toke_OctaveShift() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_OctaveShift::Toke_OctaveShift(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_OctaveShift::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OctaveShift::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_OctaveShift(s,s->length());
}

const std::wregex Toke_Fine::rgx = wregex(L"fine");
Toke_Fine * Toke_Fine::aninstance = nullptr;
Toke_Fine * Toke_Fine::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Fine();;
    };
    return aninstance;;
}

 Toke_Fine::Toke_Fine() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Fine::Toke_Fine(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Fine::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Fine(s,s->length());
}

const std::wregex Toke_Segno::rgx = wregex(L",segno`(?:_[a-zA-Z_][a-zA-Z0-9_]*`)*");
Toke_Segno * Toke_Segno::aninstance = nullptr;
Toke_Segno * Toke_Segno::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Segno();;
    };
    return aninstance;;
}

 Toke_Segno::Toke_Segno() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Segno::Toke_Segno(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Segno::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Segno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Segno(s,s->length());
}

const std::wregex Toke_Freq::rgx = wregex(L"(0|[1-9][0-9]*)(\\.[0-9]+)?Hz");
Toke_Freq * Toke_Freq::aninstance = nullptr;
Toke_Freq * Toke_Freq::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Freq();;
    };
    return aninstance;;
}

 Toke_Freq::Toke_Freq() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Freq::Toke_Freq(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Freq::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Freq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Freq(s,s->length());
}

const std::wregex Toke_DynPiano::rgx = wregex(L"(mp|p+)(iano)?");
Toke_DynPiano * Toke_DynPiano::aninstance = nullptr;
Toke_DynPiano * Toke_DynPiano::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynPiano();;
    };
    return aninstance;;
}

 Toke_DynPiano::Toke_DynPiano() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynPiano::Toke_DynPiano(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynPiano::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynPiano::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynPiano(s,s->length());
}

const std::wregex Toke_QuindicesimaA::rgx = wregex(L"15ma|alla quindicesima");
Toke_QuindicesimaA * Toke_QuindicesimaA::aninstance = nullptr;
Toke_QuindicesimaA * Toke_QuindicesimaA::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_QuindicesimaA();;
    };
    return aninstance;;
}

 Toke_QuindicesimaA::Toke_QuindicesimaA() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_QuindicesimaA::Toke_QuindicesimaA(wstring * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_QuindicesimaA::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_QuindicesimaA(s,s->length());
}

