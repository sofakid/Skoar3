// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2017-03-15 13:33:05 for C++14
// ======================================================================
#include "lex.hpp"
#include "exception.hpp"
#include "memories.hpp"

static wsmatch matches;
// ------------------
// Abstract SkoarToke
// ------------------
 SkoarToke::SkoarToke() {
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
}

 SkoarToke::SkoarToke(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
    ++SkoarMemories.Tokes;
}

 SkoarToke::~SkoarToke() {
    --SkoarMemories.Tokes;
}

// how many characters to burn from the buffer
size_t SkoarToke::burn() {
    return size;
}

// --------------
// Eof is special
// --------------
 Toke_Eof::Toke_Eof() {
    kind = ESkoarToke::Eof;
    ++SkoarMemories.Tokes;
}

 Toke_Eof::~Toke_Eof() {
    --SkoarMemories.Tokes;
}

size_t Toke_Eof::burn(wstring * buf, size_t offs) {
    if (buf->size() > offs) {
        throw SkoarError(L"Tried to burn Eof when there's more input.");
    }

    return 0;
}

SkoarToke* Toke_Eof::match_toke(wstring * buf, size_t offs) {
    if (buf->size() == offs) {
        return new Toke_Eof();
    }

    return nullptr;
}

// ---------------------
// Whitespace is special
// ---------------------
const wregex Toke_Whitespace::rgx = wregex(L"[ \\t]*");

size_t Toke_Whitespace::burn(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Whitespace::rgx, regex_constants::match_continuous);
    if (!found) {
        return 0;
    }

    return matches[0].length();
}

// --------------
// Everyday Tokes
// --------------
const std::wregex Toke_AUGen::rgx = wregex(L"a[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)");
 Toke_AUGen::Toke_AUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AUGen>();
    ++SkoarMemories.Tokes;
}

 Toke_AUGen::~Toke_AUGen() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AUGen(s, offs, s.length());
}

const std::wregex Toke_AUGenWithArgs::rgx = wregex(L"a[A-Z][a-zA-Z0-9_]*<");
 Toke_AUGenWithArgs::Toke_AUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AUGenWithArgs>();
    ++SkoarMemories.Tokes;
}

 Toke_AUGenWithArgs::~Toke_AUGenWithArgs() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_AlCoda::rgx = wregex(L"al(la)? coda");
 Toke_AlCoda::Toke_AlCoda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlCoda;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AlCoda>();
    ++SkoarMemories.Tokes;
}

 Toke_AlCoda::~Toke_AlCoda() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AlCoda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlCoda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlCoda(s, offs, s.length());
}

const std::wregex Toke_AlFine::rgx = wregex(L"al fine");
 Toke_AlFine::Toke_AlFine(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlFine;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AlFine>();
    ++SkoarMemories.Tokes;
}

 Toke_AlFine::~Toke_AlFine() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AlFine::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlFine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlFine(s, offs, s.length());
}

const std::wregex Toke_AlSegno::rgx = wregex(L"al segno");
 Toke_AlSegno::Toke_AlSegno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlSegno;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AlSegno>();
    ++SkoarMemories.Tokes;
}

 Toke_AlSegno::~Toke_AlSegno() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AlSegno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlSegno(s, offs, s.length());
}

const std::wregex Toke_AssOp::rgx = wregex(L"=>|[+]>|->|[*]>");
 Toke_AssOp::Toke_AssOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AssOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AssOp>();
    ++SkoarMemories.Tokes;
}

 Toke_AssOp::~Toke_AssOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AssOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AssOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AssOp(s, offs, s.length());
}

const std::wregex Toke_Bars::rgx = wregex(L":?\\|+:?");
 Toke_Bars::Toke_Bars(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Bars;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Bars>();
    ++SkoarMemories.Tokes;
}

 Toke_Bars::~Toke_Bars() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Bars::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Bars::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Bars(s, offs, s.length());
}

const std::wregex Toke_BooleanOp::rgx = wregex(L"==|!=|<=|>=|and|or|xor");
 Toke_BooleanOp::Toke_BooleanOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BooleanOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::BooleanOp>();
    ++SkoarMemories.Tokes;
}

 Toke_BooleanOp::~Toke_BooleanOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_BooleanOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_BooleanOp(s, offs, s.length());
}

const std::wregex Toke_Carrot::rgx = wregex(L"\\^(?!\\^[(])");
 Toke_Carrot::Toke_Carrot(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Carrot;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Carrot>();
    ++SkoarMemories.Tokes;
}

 Toke_Carrot::~Toke_Carrot() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Carrot::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Carrot::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Carrot(s, offs, s.length());
}

const std::wregex Toke_Cat::rgx = wregex(L"=\\^\\.\\^=");
 Toke_Cat::Toke_Cat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Cat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Cat>();
    ++SkoarMemories.Tokes;
}

 Toke_Cat::~Toke_Cat() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Cat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Cat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Cat(s, offs, s.length());
}

const std::wregex Toke_Choard::rgx = wregex(L"~*[ABCDEFG](?![.ce-ln-rt-zA-LN-Z]|a[l ])(#|b)?([Mm0-9]|sus|dim|aug|dom)*~*");
 Toke_Choard::Toke_Choard(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Choard;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Choard>();
    ++SkoarMemories.Tokes;
}

 Toke_Choard::~Toke_Choard() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Choard::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Choard::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Choard(s, offs, s.length());
}

const std::wregex Toke_Coda::rgx = wregex(L"\\([+]\\)(?:`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*)?");
 Toke_Coda::Toke_Coda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Coda;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Coda>();
    ++SkoarMemories.Tokes;
}

 Toke_Coda::~Toke_Coda() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Coda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Coda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Coda(s, offs, s.length());
}

const std::wregex Toke_Comment::rgx = wregex(L"<[?](.|[\\n\\r])*?[?]>");
 Toke_Comment::Toke_Comment(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Comment;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Comment>();
    ++SkoarMemories.Tokes;
}

 Toke_Comment::~Toke_Comment() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Comment::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Comment::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Comment(s, offs, s.length());
}

const std::wregex Toke_CondE::rgx = wregex(L"[?][}]");
 Toke_CondE::Toke_CondE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondE>();
    ++SkoarMemories.Tokes;
}

 Toke_CondE::~Toke_CondE() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_CondE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondE(s, offs, s.length());
}

const std::wregex Toke_CondIf::rgx = wregex(L"[?][?](?![}])");
 Toke_CondIf::Toke_CondIf(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondIf;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondIf>();
    ++SkoarMemories.Tokes;
}

 Toke_CondIf::~Toke_CondIf() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_CondIf::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondIf::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondIf(s, offs, s.length());
}

const std::wregex Toke_CondS::rgx = wregex(L"[{][?][\\n]*");
 Toke_CondS::Toke_CondS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondS>();
    ++SkoarMemories.Tokes;
}

 Toke_CondS::~Toke_CondS() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_CondS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondS(s, offs, s.length());
}

const std::wregex Toke_Crotchets::rgx = wregex(L"[}]+\\.?");
 Toke_Crotchets::Toke_Crotchets(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Crotchets;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Crotchets>();
    ++SkoarMemories.Tokes;
}

 Toke_Crotchets::~Toke_Crotchets() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Crotchets::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crotchets::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Crotchets(s, offs, s.length());
}

const std::wregex Toke_DUGen::rgx = wregex(L"d[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)");
 Toke_DUGen::Toke_DUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DUGen>();
    ++SkoarMemories.Tokes;
}

 Toke_DUGen::~Toke_DUGen() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DUGen(s, offs, s.length());
}

const std::wregex Toke_DUGenWithArgs::rgx = wregex(L"d[A-Z][a-zA-Z0-9_]*<");
 Toke_DUGenWithArgs::Toke_DUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DUGenWithArgs>();
    ++SkoarMemories.Tokes;
}

 Toke_DUGenWithArgs::~Toke_DUGenWithArgs() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_DaCapo::rgx = wregex(L"D\\.C\\.|Da Capo");
 Toke_DaCapo::Toke_DaCapo(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DaCapo;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DaCapo>();
    ++SkoarMemories.Tokes;
}

 Toke_DaCapo::~Toke_DaCapo() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DaCapo::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DaCapo::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DaCapo(s, offs, s.length());
}

const std::wregex Toke_DalSegno::rgx = wregex(L"D\\.S\\.|Dal Segno");
 Toke_DalSegno::Toke_DalSegno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DalSegno;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DalSegno>();
    ++SkoarMemories.Tokes;
}

 Toke_DalSegno::~Toke_DalSegno() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DalSegno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DalSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DalSegno(s, offs, s.length());
}

const std::wregex Toke_Deref::rgx = wregex(L"!(?![!}]|=)");
 Toke_Deref::Toke_Deref(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Deref;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Deref>();
    ++SkoarMemories.Tokes;
}

 Toke_Deref::~Toke_Deref() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Deref::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Deref::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Deref(s, offs, s.length());
}

const std::wregex Toke_Duration::rgx = wregex(L"[0-9]+:[0-9]+(\\.[0-9]+)?");
 Toke_Duration::Toke_Duration(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Duration;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Duration>();
    ++SkoarMemories.Tokes;
}

 Toke_Duration::~Toke_Duration() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Duration::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Duration::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Duration(s, offs, s.length());
}

const std::wregex Toke_DynFP::rgx = wregex(L"fp(?![a-oq-zA-Z0-9_])");
 Toke_DynFP::Toke_DynFP(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynFP;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynFP>();
    ++SkoarMemories.Tokes;
}

 Toke_DynFP::~Toke_DynFP() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynFP::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynFP::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynFP(s, offs, s.length());
}

const std::wregex Toke_DynForte::rgx = wregex(L"m(ezzo)?f(orte)?|f+orte|ff+(?![a-oq-zA-Z0-9_])");
 Toke_DynForte::Toke_DynForte(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynForte;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynForte>();
    ++SkoarMemories.Tokes;
}

 Toke_DynForte::~Toke_DynForte() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynForte::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynForte::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynForte(s, offs, s.length());
}

const std::wregex Toke_DynPiano::rgx = wregex(L"(m(ezzo)?p|p+)(iano)?(?![a-oq-zA-Z0-9_])");
 Toke_DynPiano::Toke_DynPiano(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynPiano;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynPiano>();
    ++SkoarMemories.Tokes;
}

 Toke_DynPiano::~Toke_DynPiano() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynPiano::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynPiano::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynPiano(s, offs, s.length());
}

const std::wregex Toke_DynSFZ::rgx = wregex(L"sfz(?![a-oq-zA-Z0-9_])");
 Toke_DynSFZ::Toke_DynSFZ(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynSFZ;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynSFZ>();
    ++SkoarMemories.Tokes;
}

 Toke_DynSFZ::~Toke_DynSFZ() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynSFZ::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynSFZ::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynSFZ(s, offs, s.length());
}

const std::wregex Toke_Eighths::rgx = wregex(L"\\.?\\]+(?:__?)?\\.?");
 Toke_Eighths::Toke_Eighths(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Eighths;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Eighths>();
    ++SkoarMemories.Tokes;
}

 Toke_Eighths::~Toke_Eighths() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Eighths::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Eighths::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Eighths(s, offs, s.length());
}

const std::wregex Toke_ExactBeat::rgx = wregex(L"[(](?![+])");
 Toke_ExactBeat::Toke_ExactBeat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExactBeat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExactBeat>();
    ++SkoarMemories.Tokes;
}

 Toke_ExactBeat::~Toke_ExactBeat() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ExactBeat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExactBeat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExactBeat(s, offs, s.length());
}

const std::wregex Toke_ExactRest::rgx = wregex(L"[{](?![=?:!])");
 Toke_ExactRest::Toke_ExactRest(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExactRest;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExactRest>();
    ++SkoarMemories.Tokes;
}

 Toke_ExactRest::~Toke_ExactRest() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ExactRest::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExactRest::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExactRest(s, offs, s.length());
}

const std::wregex Toke_Fairy::rgx = wregex(L"[$]");
 Toke_Fairy::Toke_Fairy(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fairy;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Fairy>();
    ++SkoarMemories.Tokes;
}

 Toke_Fairy::~Toke_Fairy() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Fairy::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fairy::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Fairy(s, offs, s.length());
}

const std::wregex Toke_False::rgx = wregex(L"no|false");
 Toke_False::Toke_False(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::False;
    this->style = SkoarStyles::Toke::style<ESkoarToke::False>();
    ++SkoarMemories.Tokes;
}

 Toke_False::~Toke_False() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_False::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_False::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_False(s, offs, s.length());
}

const std::wregex Toke_Fine::rgx = wregex(L"fine");
 Toke_Fine::Toke_Fine(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fine;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Fine>();
    ++SkoarMemories.Tokes;
}

 Toke_Fine::~Toke_Fine() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Fine::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Fine(s, offs, s.length());
}

const std::wregex Toke_Float::rgx = wregex(L"(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz|:[0-9])");
 Toke_Float::Toke_Float(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Float;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Float>();
    ++SkoarMemories.Tokes;
}

 Toke_Float::~Toke_Float() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Float::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Float::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Float(s, offs, s.length());
}

const std::wregex Toke_Freq::rgx = wregex(L"(0|[1-9][0-9]*)(\\.[0-9]+)?Hz");
 Toke_Freq::Toke_Freq(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Freq;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Freq>();
    ++SkoarMemories.Tokes;
}

 Toke_Freq::~Toke_Freq() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Freq::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Freq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Freq(s, offs, s.length());
}

const std::wregex Toke_HashLevel::rgx = wregex(L"\\[#*[ ]*\\]");
 Toke_HashLevel::Toke_HashLevel(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::HashLevel;
    this->style = SkoarStyles::Toke::style<ESkoarToke::HashLevel>();
    ++SkoarMemories.Tokes;
}

 Toke_HashLevel::~Toke_HashLevel() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_HashLevel::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_HashLevel::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_HashLevel(s, offs, s.length());
}

const std::wregex Toke_Int::rgx = wregex(L"(-)?(0|[1-9][0-9]*)(?![0-9]*Hz|[mv][ab]|\\.[0-9]|:[0-9])");
 Toke_Int::Toke_Int(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Int;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Int>();
    ++SkoarMemories.Tokes;
}

 Toke_Int::~Toke_Int() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Int::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Int::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Int(s, offs, s.length());
}

const std::wregex Toke_KUGen::rgx = wregex(L"k[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)");
 Toke_KUGen::Toke_KUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::KUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::KUGen>();
    ++SkoarMemories.Tokes;
}

 Toke_KUGen::~Toke_KUGen() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_KUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_KUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_KUGen(s, offs, s.length());
}

const std::wregex Toke_KUGenWithArgs::rgx = wregex(L"k[A-Z][a-zA-Z0-9_]*<");
 Toke_KUGenWithArgs::Toke_KUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::KUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::KUGenWithArgs>();
    ++SkoarMemories.Tokes;
}

 Toke_KUGenWithArgs::~Toke_KUGenWithArgs() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_KUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_KUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_KUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_LWing::rgx = wregex(L"\\^\\^[(]");
 Toke_LWing::Toke_LWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LWing;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LWing>();
    ++SkoarMemories.Tokes;
}

 Toke_LWing::~Toke_LWing() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LWing(s, offs, s.length());
}

const std::wregex Toke_ListE::rgx = wregex(L">(?![=])");
 Toke_ListE::Toke_ListE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListE>();
    ++SkoarMemories.Tokes;
}

 Toke_ListE::~Toke_ListE() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ListE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListE(s, offs, s.length());
}

const std::wregex Toke_ListS::rgx = wregex(L"<(?![=?])|<(?=[=]\\^\\.)");
 Toke_ListS::Toke_ListS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListS>();
    ++SkoarMemories.Tokes;
}

 Toke_ListS::~Toke_ListS() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ListS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListS(s, offs, s.length());
}

const std::wregex Toke_ListSep::rgx = wregex(L",");
 Toke_ListSep::Toke_ListSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListSep>();
    ++SkoarMemories.Tokes;
}

 Toke_ListSep::~Toke_ListSep() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ListSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListSep(s, offs, s.length());
}

const std::wregex Toke_Loco::rgx = wregex(L"loco");
 Toke_Loco::Toke_Loco(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Loco;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Loco>();
    ++SkoarMemories.Tokes;
}

 Toke_Loco::~Toke_Loco() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Loco::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Loco::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Loco(s, offs, s.length());
}

const std::wregex Toke_LoopE::rgx = wregex(L":[}]");
 Toke_LoopE::Toke_LoopE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopE>();
    ++SkoarMemories.Tokes;
}

 Toke_LoopE::~Toke_LoopE() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LoopE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopE(s, offs, s.length());
}

const std::wregex Toke_LoopS::rgx = wregex(L"[{]:[\\n]*");
 Toke_LoopS::Toke_LoopS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopS>();
    ++SkoarMemories.Tokes;
}

 Toke_LoopS::~Toke_LoopS() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LoopS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopS(s, offs, s.length());
}

const std::wregex Toke_LoopSep::rgx = wregex(L"::[\\n]*(?![|])");
 Toke_LoopSep::Toke_LoopSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopSep>();
    ++SkoarMemories.Tokes;
}

 Toke_LoopSep::~Toke_LoopSep() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LoopSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopSep(s, offs, s.length());
}

const std::wregex Toke_Lute::rgx = wregex(L"&(?!<)");
 Toke_Lute::Toke_Lute(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Lute;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Lute>();
    ++SkoarMemories.Tokes;
}

 Toke_Lute::~Toke_Lute() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Lute::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Lute::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Lute(s, offs, s.length());
}

const std::wregex Toke_LuteWithArgs::rgx = wregex(L"&<");
 Toke_LuteWithArgs::Toke_LuteWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LuteWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LuteWithArgs>();
    ++SkoarMemories.Tokes;
}

 Toke_LuteWithArgs::~Toke_LuteWithArgs() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LuteWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LuteWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LuteWithArgs(s, offs, s.length());
}

const std::wregex Toke_MathOp::rgx = wregex(L"[+*\\-/%](?!>)");
 Toke_MathOp::Toke_MathOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MathOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MathOp>();
    ++SkoarMemories.Tokes;
}

 Toke_MathOp::~Toke_MathOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MathOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MathOp(s, offs, s.length());
}

const std::wregex Toke_MeditationE::rgx = wregex(L"=[}]");
 Toke_MeditationE::Toke_MeditationE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MeditationE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MeditationE>();
    ++SkoarMemories.Tokes;
}

 Toke_MeditationE::~Toke_MeditationE() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MeditationE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MeditationE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MeditationE(s, offs, s.length());
}

const std::wregex Toke_MeditationS::rgx = wregex(L"[{]=[\\n]*");
 Toke_MeditationS::Toke_MeditationS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MeditationS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MeditationS>();
    ++SkoarMemories.Tokes;
}

 Toke_MeditationS::~Toke_MeditationS() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MeditationS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MeditationS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MeditationS(s, offs, s.length());
}

const std::wregex Toke_MsgName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*(?!<)");
 Toke_MsgName::Toke_MsgName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgName;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgName>();
    ++SkoarMemories.Tokes;
}

 Toke_MsgName::~Toke_MsgName() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MsgName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgName(s, offs, s.length());
}

const std::wregex Toke_MsgNameWithArgs::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*<");
 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgNameWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgNameWithArgs>();
    ++SkoarMemories.Tokes;
}

 Toke_MsgNameWithArgs::~Toke_MsgNameWithArgs() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MsgNameWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgNameWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgNameWithArgs(s, offs, s.length());
}

const std::wregex Toke_MsgOp::rgx = wregex(L"\\.(?![)\\]])");
 Toke_MsgOp::Toke_MsgOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgOp>();
    ++SkoarMemories.Tokes;
}

 Toke_MsgOp::~Toke_MsgOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MsgOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgOp(s, offs, s.length());
}

const std::wregex Toke_NamedNoat::rgx = wregex(L"(?:_?)(?:[a-g](?![ac-zA-Z_]))(#|b)?(?![ \\t]*:(?![}:|]))");
 Toke_NamedNoat::Toke_NamedNoat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::NamedNoat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::NamedNoat>();
    ++SkoarMemories.Tokes;
}

 Toke_NamedNoat::~Toke_NamedNoat() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_NamedNoat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_NamedNoat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_NamedNoat(s, offs, s.length());
}

const std::wregex Toke_Newline::rgx = wregex(L"[\\n\\r][\\n\\r \\t]*");
 Toke_Newline::Toke_Newline(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Newline;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Newline>();
    ++SkoarMemories.Tokes;
}

 Toke_Newline::~Toke_Newline() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Newline::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Newline::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Newline(s, offs, s.length());
}

const std::wregex Toke_Nosey::rgx = wregex(L",");
 Toke_Nosey::Toke_Nosey(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Nosey;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Nosey>();
    ++SkoarMemories.Tokes;
}

 Toke_Nosey::~Toke_Nosey() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Nosey::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Nosey::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Nosey(s, offs, s.length());
}

const std::wregex Toke_OctaveShift::rgx = wregex(L"~+o|o~+");
 Toke_OctaveShift::Toke_OctaveShift(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OctaveShift;
    this->style = SkoarStyles::Toke::style<ESkoarToke::OctaveShift>();
    ++SkoarMemories.Tokes;
}

 Toke_OctaveShift::~Toke_OctaveShift() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_OctaveShift::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OctaveShift::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OctaveShift(s, offs, s.length());
}

const std::wregex Toke_OttavaA::rgx = wregex(L"8va|ottava (alta|sopra)|all' ottava");
 Toke_OttavaA::Toke_OttavaA(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaA;
    this->style = SkoarStyles::Toke::style<ESkoarToke::OttavaA>();
    ++SkoarMemories.Tokes;
}

 Toke_OttavaA::~Toke_OttavaA() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_OttavaA::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OttavaA(s, offs, s.length());
}

const std::wregex Toke_OttavaB::rgx = wregex(L"8vb|ottava (bassa|sotto)");
 Toke_OttavaB::Toke_OttavaB(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaB;
    this->style = SkoarStyles::Toke::style<ESkoarToke::OttavaB>();
    ++SkoarMemories.Tokes;
}

 Toke_OttavaB::~Toke_OttavaB() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_OttavaB::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OttavaB(s, offs, s.length());
}

const std::wregex Toke_Quarters::rgx = wregex(L"\\.?[)]+(?:__?)?\\.?");
 Toke_Quarters::Toke_Quarters(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quarters;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Quarters>();
    ++SkoarMemories.Tokes;
}

 Toke_Quarters::~Toke_Quarters() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Quarters::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quarters::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quarters(s, offs, s.length());
}

const std::wregex Toke_Quavers::rgx = wregex(L"o+/\\.?");
 Toke_Quavers::Toke_Quavers(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quavers;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Quavers>();
    ++SkoarMemories.Tokes;
}

 Toke_Quavers::~Toke_Quavers() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Quavers::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quavers::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quavers(s, offs, s.length());
}

const std::wregex Toke_QuindicesimaA::rgx = wregex(L"15ma|alla quindicesima");
 Toke_QuindicesimaA::Toke_QuindicesimaA(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaA;
    this->style = SkoarStyles::Toke::style<ESkoarToke::QuindicesimaA>();
    ++SkoarMemories.Tokes;
}

 Toke_QuindicesimaA::~Toke_QuindicesimaA() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_QuindicesimaA::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_QuindicesimaA(s, offs, s.length());
}

const std::wregex Toke_QuindicesimaB::rgx = wregex(L"15mb");
 Toke_QuindicesimaB::Toke_QuindicesimaB(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaB;
    this->style = SkoarStyles::Toke::style<ESkoarToke::QuindicesimaB>();
    ++SkoarMemories.Tokes;
}

 Toke_QuindicesimaB::~Toke_QuindicesimaB() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_QuindicesimaB::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_QuindicesimaB(s, offs, s.length());
}

const std::wregex Toke_RWing::rgx = wregex(L"[)]\\^\\^");
 Toke_RWing::Toke_RWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::RWing;
    this->style = SkoarStyles::Toke::style<ESkoarToke::RWing>();
    ++SkoarMemories.Tokes;
}

 Toke_RWing::~Toke_RWing() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_RWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_RWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_RWing(s, offs, s.length());
}

const std::wregex Toke_Segno::rgx = wregex(L",[Ss](?:egno)?`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*");
 Toke_Segno::Toke_Segno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Segno;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Segno>();
    ++SkoarMemories.Tokes;
}

 Toke_Segno::~Toke_Segno() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Segno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Segno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Segno(s, offs, s.length());
}

const std::wregex Toke_Semicolon::rgx = wregex(L";");
 Toke_Semicolon::Toke_Semicolon(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Semicolon;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Semicolon>();
    ++SkoarMemories.Tokes;
}

 Toke_Semicolon::~Toke_Semicolon() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Semicolon::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Semicolon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Semicolon(s, offs, s.length());
}

const std::wregex Toke_SkoarpionEnd::rgx = wregex(L"![}]");
 Toke_SkoarpionEnd::Toke_SkoarpionEnd(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionEnd;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionEnd>();
    ++SkoarMemories.Tokes;
}

 Toke_SkoarpionEnd::~Toke_SkoarpionEnd() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SkoarpionEnd::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionEnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionEnd(s, offs, s.length());
}

const std::wregex Toke_SkoarpionSep::rgx = wregex(L"!!");
 Toke_SkoarpionSep::Toke_SkoarpionSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionSep>();
    ++SkoarMemories.Tokes;
}

 Toke_SkoarpionSep::~Toke_SkoarpionSep() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SkoarpionSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionSep(s, offs, s.length());
}

const std::wregex Toke_SkoarpionStart::rgx = wregex(L"[{]!(?=(.(?!!!))*![}])");
 Toke_SkoarpionStart::Toke_SkoarpionStart(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionStart;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionStart>();
    ++SkoarMemories.Tokes;
}

 Toke_SkoarpionStart::~Toke_SkoarpionStart() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SkoarpionStart::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStart::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionStart(s, offs, s.length());
}

const std::wregex Toke_SkoarpionStartWithSig::rgx = wregex(L"[{]!(?=(.(?!![}]))*!!)");
 Toke_SkoarpionStartWithSig::Toke_SkoarpionStartWithSig(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionStartWithSig;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionStartWithSig>();
    ++SkoarMemories.Tokes;
}

 Toke_SkoarpionStartWithSig::~Toke_SkoarpionStartWithSig() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SkoarpionStartWithSig::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStartWithSig::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionStartWithSig(s, offs, s.length());
}

const std::wregex Toke_String::rgx = wregex(L"'[^']*'");
 Toke_String::Toke_String(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::String;
    this->style = SkoarStyles::Toke::style<ESkoarToke::String>();
    ++SkoarMemories.Tokes;
}

 Toke_String::~Toke_String() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_String::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_String::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_String(s, offs, s.length());
}

const std::wregex Toke_Symbol::rgx = wregex(L"[\\\\@][a-zA-Z0-9_][a-zA-Z0-9_]*");
 Toke_Symbol::Toke_Symbol(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Symbol;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Symbol>();
    ++SkoarMemories.Tokes;
}

 Toke_Symbol::~Toke_Symbol() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Symbol::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Symbol::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Symbol(s, offs, s.length());
}

const std::wregex Toke_SymbolColon::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*[ \\t]*:(?![:|}])");
 Toke_SymbolColon::Toke_SymbolColon(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolColon;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SymbolColon>();
    ++SkoarMemories.Tokes;
}

 Toke_SymbolColon::~Toke_SymbolColon() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SymbolColon::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolColon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SymbolColon(s, offs, s.length());
}

const std::wregex Toke_SymbolName::rgx = wregex(L"[a-zA-Z0-9_][a-zA-Z0-9_]*(?![[a-zA-Z0-9_fi \\t]*:)");
 Toke_SymbolName::Toke_SymbolName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolName;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SymbolName>();
    ++SkoarMemories.Tokes;
}

 Toke_SymbolName::~Toke_SymbolName() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SymbolName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SymbolName(s, offs, s.length());
}

const std::wregex Toke_Times::rgx = wregex(L"[Tt]imes");
 Toke_Times::Toke_Times(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Times;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Times>();
    ++SkoarMemories.Tokes;
}

 Toke_Times::~Toke_Times() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Times::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Times::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Times(s, offs, s.length());
}

const std::wregex Toke_True::rgx = wregex(L"yes|true");
 Toke_True::Toke_True(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::True;
    this->style = SkoarStyles::Toke::style<ESkoarToke::True>();
    ++SkoarMemories.Tokes;
}

 Toke_True::~Toke_True() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_True::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_True::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_True(s, offs, s.length());
}

const std::wregex Toke_Tuplet::rgx = wregex(L"/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?");
 Toke_Tuplet::Toke_Tuplet(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Tuplet;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Tuplet>();
    ++SkoarMemories.Tokes;
}

 Toke_Tuplet::~Toke_Tuplet() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Tuplet::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Tuplet::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Tuplet(s, offs, s.length());
}

const std::wregex Toke_Voice::rgx = wregex(L"\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)");
 Toke_Voice::Toke_Voice(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Voice;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Voice>();
    ++SkoarMemories.Tokes;
}

 Toke_Voice::~Toke_Voice() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Voice::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Voice::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Voice(s, offs, s.length());
}


   
SkoarDispensary::SkoarDispensary() {
table[ESkoarToke::AUGen] = 
        [](wstring *buf, size_t offs) {
            return Toke_AUGen::match_toke(buf, offs);
        };
table[ESkoarToke::AUGenWithArgs] = 
        [](wstring *buf, size_t offs) {
            return Toke_AUGenWithArgs::match_toke(buf, offs);
        };
table[ESkoarToke::AlCoda] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlCoda::match_toke(buf, offs);
        };
table[ESkoarToke::AlFine] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlFine::match_toke(buf, offs);
        };
table[ESkoarToke::AlSegno] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlSegno::match_toke(buf, offs);
        };
table[ESkoarToke::AssOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_AssOp::match_toke(buf, offs);
        };
table[ESkoarToke::Bars] = 
        [](wstring *buf, size_t offs) {
            return Toke_Bars::match_toke(buf, offs);
        };
table[ESkoarToke::BooleanOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_BooleanOp::match_toke(buf, offs);
        };
table[ESkoarToke::Carrot] = 
        [](wstring *buf, size_t offs) {
            return Toke_Carrot::match_toke(buf, offs);
        };
table[ESkoarToke::Cat] = 
        [](wstring *buf, size_t offs) {
            return Toke_Cat::match_toke(buf, offs);
        };
table[ESkoarToke::Choard] = 
        [](wstring *buf, size_t offs) {
            return Toke_Choard::match_toke(buf, offs);
        };
table[ESkoarToke::Coda] = 
        [](wstring *buf, size_t offs) {
            return Toke_Coda::match_toke(buf, offs);
        };
table[ESkoarToke::Comment] = 
        [](wstring *buf, size_t offs) {
            return Toke_Comment::match_toke(buf, offs);
        };
table[ESkoarToke::CondE] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondE::match_toke(buf, offs);
        };
table[ESkoarToke::CondIf] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondIf::match_toke(buf, offs);
        };
table[ESkoarToke::CondS] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondS::match_toke(buf, offs);
        };
table[ESkoarToke::Crotchets] = 
        [](wstring *buf, size_t offs) {
            return Toke_Crotchets::match_toke(buf, offs);
        };
table[ESkoarToke::DUGen] = 
        [](wstring *buf, size_t offs) {
            return Toke_DUGen::match_toke(buf, offs);
        };
table[ESkoarToke::DUGenWithArgs] = 
        [](wstring *buf, size_t offs) {
            return Toke_DUGenWithArgs::match_toke(buf, offs);
        };
table[ESkoarToke::DaCapo] = 
        [](wstring *buf, size_t offs) {
            return Toke_DaCapo::match_toke(buf, offs);
        };
table[ESkoarToke::DalSegno] = 
        [](wstring *buf, size_t offs) {
            return Toke_DalSegno::match_toke(buf, offs);
        };
table[ESkoarToke::Deref] = 
        [](wstring *buf, size_t offs) {
            return Toke_Deref::match_toke(buf, offs);
        };
table[ESkoarToke::Duration] = 
        [](wstring *buf, size_t offs) {
            return Toke_Duration::match_toke(buf, offs);
        };
table[ESkoarToke::DynFP] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynFP::match_toke(buf, offs);
        };
table[ESkoarToke::DynForte] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynForte::match_toke(buf, offs);
        };
table[ESkoarToke::DynPiano] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynPiano::match_toke(buf, offs);
        };
table[ESkoarToke::DynSFZ] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynSFZ::match_toke(buf, offs);
        };
table[ESkoarToke::Eighths] = 
        [](wstring *buf, size_t offs) {
            return Toke_Eighths::match_toke(buf, offs);
        };
table[ESkoarToke::ExactBeat] = 
        [](wstring *buf, size_t offs) {
            return Toke_ExactBeat::match_toke(buf, offs);
        };
table[ESkoarToke::ExactRest] = 
        [](wstring *buf, size_t offs) {
            return Toke_ExactRest::match_toke(buf, offs);
        };
table[ESkoarToke::Fairy] = 
        [](wstring *buf, size_t offs) {
            return Toke_Fairy::match_toke(buf, offs);
        };
table[ESkoarToke::False] = 
        [](wstring *buf, size_t offs) {
            return Toke_False::match_toke(buf, offs);
        };
table[ESkoarToke::Fine] = 
        [](wstring *buf, size_t offs) {
            return Toke_Fine::match_toke(buf, offs);
        };
table[ESkoarToke::Float] = 
        [](wstring *buf, size_t offs) {
            return Toke_Float::match_toke(buf, offs);
        };
table[ESkoarToke::Freq] = 
        [](wstring *buf, size_t offs) {
            return Toke_Freq::match_toke(buf, offs);
        };
table[ESkoarToke::HashLevel] = 
        [](wstring *buf, size_t offs) {
            return Toke_HashLevel::match_toke(buf, offs);
        };
table[ESkoarToke::Int] = 
        [](wstring *buf, size_t offs) {
            return Toke_Int::match_toke(buf, offs);
        };
table[ESkoarToke::KUGen] = 
        [](wstring *buf, size_t offs) {
            return Toke_KUGen::match_toke(buf, offs);
        };
table[ESkoarToke::KUGenWithArgs] = 
        [](wstring *buf, size_t offs) {
            return Toke_KUGenWithArgs::match_toke(buf, offs);
        };
table[ESkoarToke::LWing] = 
        [](wstring *buf, size_t offs) {
            return Toke_LWing::match_toke(buf, offs);
        };
table[ESkoarToke::ListE] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListE::match_toke(buf, offs);
        };
table[ESkoarToke::ListS] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListS::match_toke(buf, offs);
        };
table[ESkoarToke::ListSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListSep::match_toke(buf, offs);
        };
table[ESkoarToke::Loco] = 
        [](wstring *buf, size_t offs) {
            return Toke_Loco::match_toke(buf, offs);
        };
table[ESkoarToke::LoopE] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopE::match_toke(buf, offs);
        };
table[ESkoarToke::LoopS] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopS::match_toke(buf, offs);
        };
table[ESkoarToke::LoopSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopSep::match_toke(buf, offs);
        };
table[ESkoarToke::Lute] = 
        [](wstring *buf, size_t offs) {
            return Toke_Lute::match_toke(buf, offs);
        };
table[ESkoarToke::LuteWithArgs] = 
        [](wstring *buf, size_t offs) {
            return Toke_LuteWithArgs::match_toke(buf, offs);
        };
table[ESkoarToke::MathOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_MathOp::match_toke(buf, offs);
        };
table[ESkoarToke::MeditationE] = 
        [](wstring *buf, size_t offs) {
            return Toke_MeditationE::match_toke(buf, offs);
        };
table[ESkoarToke::MeditationS] = 
        [](wstring *buf, size_t offs) {
            return Toke_MeditationS::match_toke(buf, offs);
        };
table[ESkoarToke::MsgName] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgName::match_toke(buf, offs);
        };
table[ESkoarToke::MsgNameWithArgs] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgNameWithArgs::match_toke(buf, offs);
        };
table[ESkoarToke::MsgOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgOp::match_toke(buf, offs);
        };
table[ESkoarToke::NamedNoat] = 
        [](wstring *buf, size_t offs) {
            return Toke_NamedNoat::match_toke(buf, offs);
        };
table[ESkoarToke::Newline] = 
        [](wstring *buf, size_t offs) {
            return Toke_Newline::match_toke(buf, offs);
        };
table[ESkoarToke::Nosey] = 
        [](wstring *buf, size_t offs) {
            return Toke_Nosey::match_toke(buf, offs);
        };
table[ESkoarToke::OctaveShift] = 
        [](wstring *buf, size_t offs) {
            return Toke_OctaveShift::match_toke(buf, offs);
        };
table[ESkoarToke::OttavaA] = 
        [](wstring *buf, size_t offs) {
            return Toke_OttavaA::match_toke(buf, offs);
        };
table[ESkoarToke::OttavaB] = 
        [](wstring *buf, size_t offs) {
            return Toke_OttavaB::match_toke(buf, offs);
        };
table[ESkoarToke::Quarters] = 
        [](wstring *buf, size_t offs) {
            return Toke_Quarters::match_toke(buf, offs);
        };
table[ESkoarToke::Quavers] = 
        [](wstring *buf, size_t offs) {
            return Toke_Quavers::match_toke(buf, offs);
        };
table[ESkoarToke::QuindicesimaA] = 
        [](wstring *buf, size_t offs) {
            return Toke_QuindicesimaA::match_toke(buf, offs);
        };
table[ESkoarToke::QuindicesimaB] = 
        [](wstring *buf, size_t offs) {
            return Toke_QuindicesimaB::match_toke(buf, offs);
        };
table[ESkoarToke::RWing] = 
        [](wstring *buf, size_t offs) {
            return Toke_RWing::match_toke(buf, offs);
        };
table[ESkoarToke::Segno] = 
        [](wstring *buf, size_t offs) {
            return Toke_Segno::match_toke(buf, offs);
        };
table[ESkoarToke::Semicolon] = 
        [](wstring *buf, size_t offs) {
            return Toke_Semicolon::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionEnd] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionEnd::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionSep::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionStart] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionStart::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionStartWithSig] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionStartWithSig::match_toke(buf, offs);
        };
table[ESkoarToke::String] = 
        [](wstring *buf, size_t offs) {
            return Toke_String::match_toke(buf, offs);
        };
table[ESkoarToke::Symbol] = 
        [](wstring *buf, size_t offs) {
            return Toke_Symbol::match_toke(buf, offs);
        };
table[ESkoarToke::SymbolColon] = 
        [](wstring *buf, size_t offs) {
            return Toke_SymbolColon::match_toke(buf, offs);
        };
table[ESkoarToke::SymbolName] = 
        [](wstring *buf, size_t offs) {
            return Toke_SymbolName::match_toke(buf, offs);
        };
table[ESkoarToke::Times] = 
        [](wstring *buf, size_t offs) {
            return Toke_Times::match_toke(buf, offs);
        };
table[ESkoarToke::True] = 
        [](wstring *buf, size_t offs) {
            return Toke_True::match_toke(buf, offs);
        };
table[ESkoarToke::Tuplet] = 
        [](wstring *buf, size_t offs) {
            return Toke_Tuplet::match_toke(buf, offs);
        };
table[ESkoarToke::Voice] = 
        [](wstring *buf, size_t offs) {
            return Toke_Voice::match_toke(buf, offs);
        };

}

SkoarToke* SkoarDispensary::match_toke(ESkoarToke::Kind want, wstring *buf, size_t offs) {
    auto f = table[want];
    if (f) 
        return f(buf, offs);
    return nullptr;
}
