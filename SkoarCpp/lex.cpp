// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2015-08-05 18:46:19 for C++14
// ======================================================================
#include "lex.hpp"
#include "exception.hpp"

// ------------------
// Abstract SkoarToke
// ------------------
 SkoarToke::SkoarToke() {
    kind = ESkoarToke::Unknown;
}

 SkoarToke::SkoarToke(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = n;
    this->size = n;
    kind = ESkoarToke::Unknown;
}

// how many characters to burn from the buffer
size_t SkoarToke::burn() {
    return size;
}

// --------------
// Eof is special
// --------------
 Toke_Eof::Toke_Eof() {
    kind = ESkoarToke::Eof;
}

size_t Toke_Eof::burn(wstring * buf, size_t offs) {
    if (buf->size() > offs) {
        throw new SkoarError(L"Tried to burn Eof when there's more input.");
    }

    return 0;
}

SkoarToke* Toke_Eof::match_toke(wstring * buf, size_t offs) {
    if (buf->size() == offs) {
        return new Toke_Eof();
    }

    return nullptr;
}

// ---------------------
// Whitespace is special
// ---------------------
const wregex Toke_Whitespace::rgx = wregex(L"[ \\t]+");

size_t Toke_Whitespace::burn(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Whitespace::rgx, regex_constants::match_continuous);
    if (!found) {
        return 0;
    }

    return matches[0].length();
}

// --------------
// Everyday Tokes
// --------------
const std::wregex Toke_Quarters::rgx = wregex(L"\\.?[)]+(?:__?)?\\.?");
 Toke_Quarters::Toke_Quarters(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quarters;
}

SkoarToke* Toke_Quarters::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quarters::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Quarters(s,offs,s->length());
}

const std::wregex Toke_LWing::rgx = wregex(L"\\^\\^[(]");
 Toke_LWing::Toke_LWing(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LWing;
}

SkoarToke* Toke_LWing::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LWing(s,offs,s->length());
}

const std::wregex Toke_AlSegno::rgx = wregex(L"al segno");
 Toke_AlSegno::Toke_AlSegno(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlSegno;
}

SkoarToke* Toke_AlSegno::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AlSegno(s,offs,s->length());
}

const std::wregex Toke_Float::rgx = wregex(L"(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz)");
 Toke_Float::Toke_Float(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Float;
}

SkoarToke* Toke_Float::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Float::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Float(s,offs,s->length());
}

const std::wregex Toke_Times::rgx = wregex(L"[Tt]imes");
 Toke_Times::Toke_Times(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Times;
}

SkoarToke* Toke_Times::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Times::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Times(s,offs,s->length());
}

const std::wregex Toke_DalSegno::rgx = wregex(L"D\\.S\\.|Dal Segno");
 Toke_DalSegno::Toke_DalSegno(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DalSegno;
}

SkoarToke* Toke_DalSegno::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DalSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DalSegno(s,offs,s->length());
}

const std::wregex Toke_Eighths::rgx = wregex(L"\\.?\\]+(?:__?)?\\.?");
 Toke_Eighths::Toke_Eighths(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Eighths;
}

SkoarToke* Toke_Eighths::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Eighths::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Eighths(s,offs,s->length());
}

const std::wregex Toke_OttavaA::rgx = wregex(L"8va|ottava (alta|sopra)|all' ottava");
 Toke_OttavaA::Toke_OttavaA(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaA;
}

SkoarToke* Toke_OttavaA::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_OttavaA(s,offs,s->length());
}

const std::wregex Toke_SymbolName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*");
 Toke_SymbolName::Toke_SymbolName(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolName;
}

SkoarToke* Toke_SymbolName::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SymbolName(s,offs,s->length());
}

const std::wregex Toke_OctaveShift::rgx = wregex(L"~+o|o~+");
 Toke_OctaveShift::Toke_OctaveShift(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OctaveShift;
}

SkoarToke* Toke_OctaveShift::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OctaveShift::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_OctaveShift(s,offs,s->length());
}

const std::wregex Toke_DynPiano::rgx = wregex(L"(m(ezzo)?p|p+)(iano)?");
 Toke_DynPiano::Toke_DynPiano(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynPiano;
}

SkoarToke* Toke_DynPiano::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynPiano::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynPiano(s,offs,s->length());
}

const std::wregex Toke_ListS::rgx = wregex(L"<(?![=?])");
 Toke_ListS::Toke_ListS(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListS;
}

SkoarToke* Toke_ListS::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_ListS(s,offs,s->length());
}

const std::wregex Toke_CondE::rgx = wregex(L"[?][}]");
 Toke_CondE::Toke_CondE(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondE;
}

SkoarToke* Toke_CondE::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_CondE(s,offs,s->length());
}

const std::wregex Toke_DaCapo::rgx = wregex(L"D\\.C\\.|Da Capo");
 Toke_DaCapo::Toke_DaCapo(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DaCapo;
}

SkoarToke* Toke_DaCapo::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DaCapo::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DaCapo(s,offs,s->length());
}

const std::wregex Toke_Loco::rgx = wregex(L"loco");
 Toke_Loco::Toke_Loco(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Loco;
}

SkoarToke* Toke_Loco::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Loco::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Loco(s,offs,s->length());
}

const std::wregex Toke_SkoarpionStart::rgx = wregex(L"[{]!");
 Toke_SkoarpionStart::Toke_SkoarpionStart(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionStart;
}

SkoarToke* Toke_SkoarpionStart::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStart::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SkoarpionStart(s,offs,s->length());
}

const std::wregex Toke_Choard::rgx = wregex(L"[ABCDEFG](?![ce-ln-rt-zA-LN-Z])(#|b)?([Mm0-9]|sus|dim|aug|dom|add)*");
 Toke_Choard::Toke_Choard(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Choard;
}

SkoarToke* Toke_Choard::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Choard::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Choard(s,offs,s->length());
}

const std::wregex Toke_Comment::rgx = wregex(L"<[?](.|[\\n\\r\\f])*?[?]>");
 Toke_Comment::Toke_Comment(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Comment;
}

SkoarToke* Toke_Comment::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Comment::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Comment(s,offs,s->length());
}

const std::wregex Toke_String::rgx = wregex(L"'[^']*'");
 Toke_String::Toke_String(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::String;
}

SkoarToke* Toke_String::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_String::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_String(s,offs,s->length());
}

const std::wregex Toke_Coda::rgx = wregex(L"\\([+]\\)(?:`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*)?");
 Toke_Coda::Toke_Coda(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Coda;
}

SkoarToke* Toke_Coda::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Coda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Coda(s,offs,s->length());
}

const std::wregex Toke_Tuplet::rgx = wregex(L"/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?");
 Toke_Tuplet::Toke_Tuplet(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Tuplet;
}

SkoarToke* Toke_Tuplet::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Tuplet::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Tuplet(s,offs,s->length());
}

const std::wregex Toke_PedalDown::rgx = wregex(L"Ped\\.?");
 Toke_PedalDown::Toke_PedalDown(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::PedalDown;
}

SkoarToke* Toke_PedalDown::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalDown::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_PedalDown(s,offs,s->length());
}

const std::wregex Toke_ListSep::rgx = wregex(L",");
 Toke_ListSep::Toke_ListSep(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListSep;
}

SkoarToke* Toke_ListSep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_ListSep(s,offs,s->length());
}

const std::wregex Toke_SkoarpionEnd::rgx = wregex(L"![}]");
 Toke_SkoarpionEnd::Toke_SkoarpionEnd(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionEnd;
}

SkoarToke* Toke_SkoarpionEnd::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionEnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SkoarpionEnd(s,offs,s->length());
}

const std::wregex Toke_MsgNameWithArgs::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*<");
 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgNameWithArgs;
}

SkoarToke* Toke_MsgNameWithArgs::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgNameWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MsgNameWithArgs(s,offs,s->length());
}

const std::wregex Toke_Quavers::rgx = wregex(L"o+/\\.?");
 Toke_Quavers::Toke_Quavers(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quavers;
}

SkoarToke* Toke_Quavers::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quavers::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Quavers(s,offs,s->length());
}

const std::wregex Toke_CondIf::rgx = wregex(L"[?][?](?![}])");
 Toke_CondIf::Toke_CondIf(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondIf;
}

SkoarToke* Toke_CondIf::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondIf::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_CondIf(s,offs,s->length());
}

const std::wregex Toke_ArgSpec::rgx = wregex(L"<[a-zA-Z]+(,[a-zA-Z]+)*>");
 Toke_ArgSpec::Toke_ArgSpec(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ArgSpec;
}

SkoarToke* Toke_ArgSpec::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ArgSpec::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_ArgSpec(s,offs,s->length());
}

const std::wregex Toke_Fairy::rgx = wregex(L"[$]");
 Toke_Fairy::Toke_Fairy(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fairy;
}

SkoarToke* Toke_Fairy::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fairy::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Fairy(s,offs,s->length());
}

const std::wregex Toke_MathOp::rgx = wregex(L"[+x\\-](?!>|or)");
 Toke_MathOp::Toke_MathOp(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MathOp;
}

SkoarToke* Toke_MathOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MathOp(s,offs,s->length());
}

const std::wregex Toke_DynFP::rgx = wregex(L"fp");
 Toke_DynFP::Toke_DynFP(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynFP;
}

SkoarToke* Toke_DynFP::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynFP::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynFP(s,offs,s->length());
}

const std::wregex Toke_Voice::rgx = wregex(L"\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)");
 Toke_Voice::Toke_Voice(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Voice;
}

SkoarToke* Toke_Voice::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Voice::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Voice(s,offs,s->length());
}

const std::wregex Toke_Carrot::rgx = wregex(L"\\^(?!\\^[(])");
 Toke_Carrot::Toke_Carrot(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Carrot;
}

SkoarToke* Toke_Carrot::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Carrot::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Carrot(s,offs,s->length());
}

const std::wregex Toke_False::rgx = wregex(L"no");
 Toke_False::Toke_False(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::False;
}

SkoarToke* Toke_False::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_False::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_False(s,offs,s->length());
}

const std::wregex Toke_CondS::rgx = wregex(L"[{][?][\\n]*");
 Toke_CondS::Toke_CondS(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondS;
}

SkoarToke* Toke_CondS::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_CondS(s,offs,s->length());
}

const std::wregex Toke_Slash::rgx = wregex(L"/(?![/0-9])");
 Toke_Slash::Toke_Slash(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Slash;
}

SkoarToke* Toke_Slash::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Slash::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Slash(s,offs,s->length());
}

const std::wregex Toke_HashLevel::rgx = wregex(L"\\[#*[ ]*\\]");
 Toke_HashLevel::Toke_HashLevel(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::HashLevel;
}

SkoarToke* Toke_HashLevel::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_HashLevel::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_HashLevel(s,offs,s->length());
}

const std::wregex Toke_OttavaB::rgx = wregex(L"8vb|ottava (bassa|sotto)");
 Toke_OttavaB::Toke_OttavaB(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaB;
}

SkoarToke* Toke_OttavaB::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_OttavaB(s,offs,s->length());
}

const std::wregex Toke_Symbol::rgx = wregex(L"[\\\\@][a-zA-Z_][a-zA-Z0-9_]*");
 Toke_Symbol::Toke_Symbol(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Symbol;
}

SkoarToke* Toke_Symbol::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Symbol::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Symbol(s,offs,s->length());
}

const std::wregex Toke_QuindicesimaB::rgx = wregex(L"15mb");
 Toke_QuindicesimaB::Toke_QuindicesimaB(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaB;
}

SkoarToke* Toke_QuindicesimaB::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_QuindicesimaB(s,offs,s->length());
}

const std::wregex Toke_MsgName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*(?!<)");
 Toke_MsgName::Toke_MsgName(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgName;
}

SkoarToke* Toke_MsgName::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MsgName(s,offs,s->length());
}

const std::wregex Toke_LoopE::rgx = wregex(L":[}]");
 Toke_LoopE::Toke_LoopE(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopE;
}

SkoarToke* Toke_LoopE::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LoopE(s,offs,s->length());
}

const std::wregex Toke_Bars::rgx = wregex(L":?\\|+:?");
 Toke_Bars::Toke_Bars(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Bars;
}

SkoarToke* Toke_Bars::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Bars::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Bars(s,offs,s->length());
}

const std::wregex Toke_Caesura::rgx = wregex(L"//");
 Toke_Caesura::Toke_Caesura(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Caesura;
}

SkoarToke* Toke_Caesura::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Caesura::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Caesura(s,offs,s->length());
}

const std::wregex Toke_Meter::rgx = wregex(L"[1-9][0-9]*/[1-9][0-9]*");
 Toke_Meter::Toke_Meter(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Meter;
}

SkoarToke* Toke_Meter::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Meter::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Meter(s,offs,s->length());
}

const std::wregex Toke_Nosey::rgx = wregex(L",");
 Toke_Nosey::Toke_Nosey(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Nosey;
}

SkoarToke* Toke_Nosey::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Nosey::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Nosey(s,offs,s->length());
}

const std::wregex Toke_DynForte::rgx = wregex(L"m(ezzo)?f(orte)?|f+orte|ff+");
 Toke_DynForte::Toke_DynForte(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynForte;
}

SkoarToke* Toke_DynForte::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynForte::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynForte(s,offs,s->length());
}

const std::wregex Toke_Rep::rgx = wregex(L"%+");
 Toke_Rep::Toke_Rep(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Rep;
}

SkoarToke* Toke_Rep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Rep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Rep(s,offs,s->length());
}

const std::wregex Toke_PedalUp::rgx = wregex(L"[*](?!>)");
 Toke_PedalUp::Toke_PedalUp(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::PedalUp;
}

SkoarToke* Toke_PedalUp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalUp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_PedalUp(s,offs,s->length());
}

const std::wregex Toke_QuindicesimaA::rgx = wregex(L"15ma|alla quindicesima");
 Toke_QuindicesimaA::Toke_QuindicesimaA(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaA;
}

SkoarToke* Toke_QuindicesimaA::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_QuindicesimaA(s,offs,s->length());
}

const std::wregex Toke_Fine::rgx = wregex(L"fine");
 Toke_Fine::Toke_Fine(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fine;
}

SkoarToke* Toke_Fine::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Fine(s,offs,s->length());
}

const std::wregex Toke_Semicolon::rgx = wregex(L";");
 Toke_Semicolon::Toke_Semicolon(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Semicolon;
}

SkoarToke* Toke_Semicolon::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Semicolon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Semicolon(s,offs,s->length());
}

const std::wregex Toke_AlFine::rgx = wregex(L"al fine");
 Toke_AlFine::Toke_AlFine(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlFine;
}

SkoarToke* Toke_AlFine::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlFine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AlFine(s,offs,s->length());
}

const std::wregex Toke_Segno::rgx = wregex(L",[Ss](?:egno)?`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*");
 Toke_Segno::Toke_Segno(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Segno;
}

SkoarToke* Toke_Segno::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Segno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Segno(s,offs,s->length());
}

const std::wregex Toke_SkoarpionSep::rgx = wregex(L"!!");
 Toke_SkoarpionSep::Toke_SkoarpionSep(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionSep;
}

SkoarToke* Toke_SkoarpionSep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_SkoarpionSep(s,offs,s->length());
}

const std::wregex Toke_LoopSep::rgx = wregex(L"::[\\n]*(?![|])");
 Toke_LoopSep::Toke_LoopSep(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopSep;
}

SkoarToke* Toke_LoopSep::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LoopSep(s,offs,s->length());
}

const std::wregex Toke_Deref::rgx = wregex(L"!(?![!}]|=)");
 Toke_Deref::Toke_Deref(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Deref;
}

SkoarToke* Toke_Deref::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Deref::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Deref(s,offs,s->length());
}

const std::wregex Toke_LoopS::rgx = wregex(L"[{]:[\\n]*");
 Toke_LoopS::Toke_LoopS(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopS;
}

SkoarToke* Toke_LoopS::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_LoopS(s,offs,s->length());
}

const std::wregex Toke_Newline::rgx = wregex(L"[\\n\\r\\f][\\n\\r\\f \\t]*");
 Toke_Newline::Toke_Newline(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Newline;
}

SkoarToke* Toke_Newline::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Newline::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Newline(s,offs,s->length());
}

const std::wregex Toke_Crotchets::rgx = wregex(L"[}]+\\.?");
 Toke_Crotchets::Toke_Crotchets(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Crotchets;
}

SkoarToke* Toke_Crotchets::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crotchets::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Crotchets(s,offs,s->length());
}

const std::wregex Toke_Int::rgx = wregex(L"(-)?(0|[1-9][0-9]*)(?![0-9]*Hz|[mv][ab]|\\.[0-9]|/)");
 Toke_Int::Toke_Int(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Int;
}

SkoarToke* Toke_Int::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Int::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Int(s,offs,s->length());
}

const std::wregex Toke_ListE::rgx = wregex(L">(?![=])");
 Toke_ListE::Toke_ListE(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListE;
}

SkoarToke* Toke_ListE::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_ListE(s,offs,s->length());
}

const std::wregex Toke_BooleanOp::rgx = wregex(L"==|!=|<=|>=|and|or|xor");
 Toke_BooleanOp::Toke_BooleanOp(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BooleanOp;
}

SkoarToke* Toke_BooleanOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_BooleanOp(s,offs,s->length());
}

const std::wregex Toke_DynSFZ::rgx = wregex(L"sfz");
 Toke_DynSFZ::Toke_DynSFZ(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynSFZ;
}

SkoarToke* Toke_DynSFZ::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynSFZ::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_DynSFZ(s,offs,s->length());
}

const std::wregex Toke_AlCoda::rgx = wregex(L"al(la)? coda");
 Toke_AlCoda::Toke_AlCoda(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlCoda;
}

SkoarToke* Toke_AlCoda::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlCoda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AlCoda(s,offs,s->length());
}

const std::wregex Toke_MsgOp::rgx = wregex(L"\\.(?![)\\]])");
 Toke_MsgOp::Toke_MsgOp(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgOp;
}

SkoarToke* Toke_MsgOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_MsgOp(s,offs,s->length());
}

const std::wregex Toke_True::rgx = wregex(L"yes");
 Toke_True::Toke_True(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::True;
}

SkoarToke* Toke_True::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_True::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_True(s,offs,s->length());
}

const std::wregex Toke_AssOp::rgx = wregex(L"=>|[+]>|->");
 Toke_AssOp::Toke_AssOp(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AssOp;
}

SkoarToke* Toke_AssOp::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AssOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_AssOp(s,offs,s->length());
}

const std::wregex Toke_Freq::rgx = wregex(L"(0|[1-9][0-9]*)(\\.[0-9]+)?Hz");
 Toke_Freq::Toke_Freq(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Freq;
}

SkoarToke* Toke_Freq::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Freq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Freq(s,offs,s->length());
}

const std::wregex Toke_Crap::rgx = wregex(L"crap");
 Toke_Crap::Toke_Crap(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Crap;
}

SkoarToke* Toke_Crap::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crap::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Crap(s,offs,s->length());
}

const std::wregex Toke_Volta::rgx = wregex(L"\\[\\d+\\.\\]");
 Toke_Volta::Toke_Volta(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Volta;
}

SkoarToke* Toke_Volta::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Volta::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Volta(s,offs,s->length());
}

const std::wregex Toke_Portamento::rgx = wregex(L"port\\.?");
 Toke_Portamento::Toke_Portamento(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Portamento;
}

SkoarToke* Toke_Portamento::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Portamento::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_Portamento(s,offs,s->length());
}

const std::wregex Toke_NamedNoat::rgx = wregex(L"(?:_?)(?:[a-g](?![ac-zA-Z_]))(#|b)?");
 Toke_NamedNoat::Toke_NamedNoat(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::NamedNoat;
}

SkoarToke* Toke_NamedNoat::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_NamedNoat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_NamedNoat(s,offs,s->length());
}

const std::wregex Toke_RWing::rgx = wregex(L"[)]\\^\\^");
 Toke_RWing::Toke_RWing(wstring * s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::RWing;
}

SkoarToke* Toke_RWing::match_toke(wstring * buf, size_t offs) {
    wsmatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_RWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    wstring *s = new wstring(matches[0]);
    return new Toke_RWing(s,offs,s->length());
}


   
SkoarDispensary::SkoarDispensary() {
table[ESkoarToke::Quarters] = 
        [](wstring *buf, size_t offs) {
            return Toke_Quarters::match_toke(buf, offs);
        };
table[ESkoarToke::LWing] = 
        [](wstring *buf, size_t offs) {
            return Toke_LWing::match_toke(buf, offs);
        };
table[ESkoarToke::AlSegno] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlSegno::match_toke(buf, offs);
        };
table[ESkoarToke::Float] = 
        [](wstring *buf, size_t offs) {
            return Toke_Float::match_toke(buf, offs);
        };
table[ESkoarToke::Times] = 
        [](wstring *buf, size_t offs) {
            return Toke_Times::match_toke(buf, offs);
        };
table[ESkoarToke::DalSegno] = 
        [](wstring *buf, size_t offs) {
            return Toke_DalSegno::match_toke(buf, offs);
        };
table[ESkoarToke::Eighths] = 
        [](wstring *buf, size_t offs) {
            return Toke_Eighths::match_toke(buf, offs);
        };
table[ESkoarToke::OttavaA] = 
        [](wstring *buf, size_t offs) {
            return Toke_OttavaA::match_toke(buf, offs);
        };
table[ESkoarToke::SymbolName] = 
        [](wstring *buf, size_t offs) {
            return Toke_SymbolName::match_toke(buf, offs);
        };
table[ESkoarToke::OctaveShift] = 
        [](wstring *buf, size_t offs) {
            return Toke_OctaveShift::match_toke(buf, offs);
        };
table[ESkoarToke::DynPiano] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynPiano::match_toke(buf, offs);
        };
table[ESkoarToke::ListS] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListS::match_toke(buf, offs);
        };
table[ESkoarToke::CondE] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondE::match_toke(buf, offs);
        };
table[ESkoarToke::DaCapo] = 
        [](wstring *buf, size_t offs) {
            return Toke_DaCapo::match_toke(buf, offs);
        };
table[ESkoarToke::Loco] = 
        [](wstring *buf, size_t offs) {
            return Toke_Loco::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionStart] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionStart::match_toke(buf, offs);
        };
table[ESkoarToke::Choard] = 
        [](wstring *buf, size_t offs) {
            return Toke_Choard::match_toke(buf, offs);
        };
table[ESkoarToke::Comment] = 
        [](wstring *buf, size_t offs) {
            return Toke_Comment::match_toke(buf, offs);
        };
table[ESkoarToke::String] = 
        [](wstring *buf, size_t offs) {
            return Toke_String::match_toke(buf, offs);
        };
table[ESkoarToke::Coda] = 
        [](wstring *buf, size_t offs) {
            return Toke_Coda::match_toke(buf, offs);
        };
table[ESkoarToke::Tuplet] = 
        [](wstring *buf, size_t offs) {
            return Toke_Tuplet::match_toke(buf, offs);
        };
table[ESkoarToke::PedalDown] = 
        [](wstring *buf, size_t offs) {
            return Toke_PedalDown::match_toke(buf, offs);
        };
table[ESkoarToke::ListSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListSep::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionEnd] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionEnd::match_toke(buf, offs);
        };
table[ESkoarToke::MsgNameWithArgs] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgNameWithArgs::match_toke(buf, offs);
        };
table[ESkoarToke::Quavers] = 
        [](wstring *buf, size_t offs) {
            return Toke_Quavers::match_toke(buf, offs);
        };
table[ESkoarToke::CondIf] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondIf::match_toke(buf, offs);
        };
table[ESkoarToke::ArgSpec] = 
        [](wstring *buf, size_t offs) {
            return Toke_ArgSpec::match_toke(buf, offs);
        };
table[ESkoarToke::Fairy] = 
        [](wstring *buf, size_t offs) {
            return Toke_Fairy::match_toke(buf, offs);
        };
table[ESkoarToke::MathOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_MathOp::match_toke(buf, offs);
        };
table[ESkoarToke::DynFP] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynFP::match_toke(buf, offs);
        };
table[ESkoarToke::Voice] = 
        [](wstring *buf, size_t offs) {
            return Toke_Voice::match_toke(buf, offs);
        };
table[ESkoarToke::Carrot] = 
        [](wstring *buf, size_t offs) {
            return Toke_Carrot::match_toke(buf, offs);
        };
table[ESkoarToke::False] = 
        [](wstring *buf, size_t offs) {
            return Toke_False::match_toke(buf, offs);
        };
table[ESkoarToke::CondS] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondS::match_toke(buf, offs);
        };
table[ESkoarToke::Slash] = 
        [](wstring *buf, size_t offs) {
            return Toke_Slash::match_toke(buf, offs);
        };
table[ESkoarToke::HashLevel] = 
        [](wstring *buf, size_t offs) {
            return Toke_HashLevel::match_toke(buf, offs);
        };
table[ESkoarToke::OttavaB] = 
        [](wstring *buf, size_t offs) {
            return Toke_OttavaB::match_toke(buf, offs);
        };
table[ESkoarToke::Symbol] = 
        [](wstring *buf, size_t offs) {
            return Toke_Symbol::match_toke(buf, offs);
        };
table[ESkoarToke::QuindicesimaB] = 
        [](wstring *buf, size_t offs) {
            return Toke_QuindicesimaB::match_toke(buf, offs);
        };
table[ESkoarToke::MsgName] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgName::match_toke(buf, offs);
        };
table[ESkoarToke::LoopE] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopE::match_toke(buf, offs);
        };
table[ESkoarToke::Bars] = 
        [](wstring *buf, size_t offs) {
            return Toke_Bars::match_toke(buf, offs);
        };
table[ESkoarToke::Caesura] = 
        [](wstring *buf, size_t offs) {
            return Toke_Caesura::match_toke(buf, offs);
        };
table[ESkoarToke::Meter] = 
        [](wstring *buf, size_t offs) {
            return Toke_Meter::match_toke(buf, offs);
        };
table[ESkoarToke::Nosey] = 
        [](wstring *buf, size_t offs) {
            return Toke_Nosey::match_toke(buf, offs);
        };
table[ESkoarToke::DynForte] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynForte::match_toke(buf, offs);
        };
table[ESkoarToke::Rep] = 
        [](wstring *buf, size_t offs) {
            return Toke_Rep::match_toke(buf, offs);
        };
table[ESkoarToke::PedalUp] = 
        [](wstring *buf, size_t offs) {
            return Toke_PedalUp::match_toke(buf, offs);
        };
table[ESkoarToke::QuindicesimaA] = 
        [](wstring *buf, size_t offs) {
            return Toke_QuindicesimaA::match_toke(buf, offs);
        };
table[ESkoarToke::Fine] = 
        [](wstring *buf, size_t offs) {
            return Toke_Fine::match_toke(buf, offs);
        };
table[ESkoarToke::Semicolon] = 
        [](wstring *buf, size_t offs) {
            return Toke_Semicolon::match_toke(buf, offs);
        };
table[ESkoarToke::AlFine] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlFine::match_toke(buf, offs);
        };
table[ESkoarToke::Segno] = 
        [](wstring *buf, size_t offs) {
            return Toke_Segno::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionSep::match_toke(buf, offs);
        };
table[ESkoarToke::LoopSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopSep::match_toke(buf, offs);
        };
table[ESkoarToke::Deref] = 
        [](wstring *buf, size_t offs) {
            return Toke_Deref::match_toke(buf, offs);
        };
table[ESkoarToke::LoopS] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopS::match_toke(buf, offs);
        };
table[ESkoarToke::Newline] = 
        [](wstring *buf, size_t offs) {
            return Toke_Newline::match_toke(buf, offs);
        };
table[ESkoarToke::Crotchets] = 
        [](wstring *buf, size_t offs) {
            return Toke_Crotchets::match_toke(buf, offs);
        };
table[ESkoarToke::Int] = 
        [](wstring *buf, size_t offs) {
            return Toke_Int::match_toke(buf, offs);
        };
table[ESkoarToke::ListE] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListE::match_toke(buf, offs);
        };
table[ESkoarToke::BooleanOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_BooleanOp::match_toke(buf, offs);
        };
table[ESkoarToke::DynSFZ] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynSFZ::match_toke(buf, offs);
        };
table[ESkoarToke::AlCoda] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlCoda::match_toke(buf, offs);
        };
table[ESkoarToke::MsgOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgOp::match_toke(buf, offs);
        };
table[ESkoarToke::True] = 
        [](wstring *buf, size_t offs) {
            return Toke_True::match_toke(buf, offs);
        };
table[ESkoarToke::AssOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_AssOp::match_toke(buf, offs);
        };
table[ESkoarToke::Freq] = 
        [](wstring *buf, size_t offs) {
            return Toke_Freq::match_toke(buf, offs);
        };
table[ESkoarToke::Crap] = 
        [](wstring *buf, size_t offs) {
            return Toke_Crap::match_toke(buf, offs);
        };
table[ESkoarToke::Volta] = 
        [](wstring *buf, size_t offs) {
            return Toke_Volta::match_toke(buf, offs);
        };
table[ESkoarToke::Portamento] = 
        [](wstring *buf, size_t offs) {
            return Toke_Portamento::match_toke(buf, offs);
        };
table[ESkoarToke::NamedNoat] = 
        [](wstring *buf, size_t offs) {
            return Toke_NamedNoat::match_toke(buf, offs);
        };
table[ESkoarToke::RWing] = 
        [](wstring *buf, size_t offs) {
            return Toke_RWing::match_toke(buf, offs);
        };

}

SkoarToke *SkoarDispensary::match_toke(ESkoarToke::Kind want, wstring *buf, size_t offs) {
    auto f = table[want];
    if (f) 
        return f(buf, offs);
    return nullptr;
}
