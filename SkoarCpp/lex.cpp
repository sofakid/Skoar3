// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2017-03-13 23:20:26 for C++14
// ======================================================================
#include "lex.hpp"
#include "exception.hpp"
#include "memories.hpp"

static wsmatch matches;
// ------------------
// Abstract SkoarToke
// ------------------
 SkoarToke::SkoarToke() {
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
}

 SkoarToke::SkoarToke(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
    ++SkoarMemories.Tokes;
}

 SkoarToke::~SkoarToke() {
    --SkoarMemories.Tokes;
}

// how many characters to burn from the buffer
size_t SkoarToke::burn() {
    return size;
}

// --------------
// Eof is special
// --------------
 Toke_Eof::Toke_Eof() {
    kind = ESkoarToke::Eof;
    ++SkoarMemories.Tokes;
}

 Toke_Eof::~Toke_Eof() {
    --SkoarMemories.Tokes;
}

size_t Toke_Eof::burn(wstring * buf, size_t offs) {
    if (buf->size() > offs) {
        throw new SkoarError(L"Tried to burn Eof when there's more input.");
    }

    return 0;
}

SkoarToke* Toke_Eof::match_toke(wstring * buf, size_t offs) {
    if (buf->size() == offs) {
        return new Toke_Eof();
    }

    return nullptr;
}

// ---------------------
// Whitespace is special
// ---------------------
const wregex Toke_Whitespace::rgx = wregex(L"[ \\t]+");

size_t Toke_Whitespace::burn(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Whitespace::rgx, regex_constants::match_continuous);
    if (!found) {
        return 0;
    }

    return matches[0].length();
}

// --------------
// Everyday Tokes
// --------------
const std::wregex Toke_AlCoda::rgx = wregex(L"al(la)? coda");
 Toke_AlCoda::Toke_AlCoda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlCoda;
    this->style = SkoarStyles::style<ESkoarToke::AlCoda>();
    ++SkoarMemories.Tokes;
}

 Toke_AlCoda::~Toke_AlCoda() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AlCoda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlCoda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlCoda(s,offs,s.length());
}

const std::wregex Toke_AlFine::rgx = wregex(L"al fine");
 Toke_AlFine::Toke_AlFine(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlFine;
    this->style = SkoarStyles::style<ESkoarToke::AlFine>();
    ++SkoarMemories.Tokes;
}

 Toke_AlFine::~Toke_AlFine() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AlFine::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlFine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlFine(s,offs,s.length());
}

const std::wregex Toke_AlSegno::rgx = wregex(L"al segno");
 Toke_AlSegno::Toke_AlSegno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlSegno;
    this->style = SkoarStyles::style<ESkoarToke::AlSegno>();
    ++SkoarMemories.Tokes;
}

 Toke_AlSegno::~Toke_AlSegno() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AlSegno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlSegno(s,offs,s.length());
}

const std::wregex Toke_ArgSpec::rgx = wregex(L"<[a-zA-Z]+(,[a-zA-Z]+)*>");
 Toke_ArgSpec::Toke_ArgSpec(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ArgSpec;
    this->style = SkoarStyles::style<ESkoarToke::ArgSpec>();
    ++SkoarMemories.Tokes;
}

 Toke_ArgSpec::~Toke_ArgSpec() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ArgSpec::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ArgSpec::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ArgSpec(s,offs,s.length());
}

const std::wregex Toke_AssOp::rgx = wregex(L"=>|[+]>|->");
 Toke_AssOp::Toke_AssOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AssOp;
    this->style = SkoarStyles::style<ESkoarToke::AssOp>();
    ++SkoarMemories.Tokes;
}

 Toke_AssOp::~Toke_AssOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_AssOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AssOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AssOp(s,offs,s.length());
}

const std::wregex Toke_Bars::rgx = wregex(L":?\\|+:?");
 Toke_Bars::Toke_Bars(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Bars;
    this->style = SkoarStyles::style<ESkoarToke::Bars>();
    ++SkoarMemories.Tokes;
}

 Toke_Bars::~Toke_Bars() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Bars::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Bars::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Bars(s,offs,s.length());
}

const std::wregex Toke_BooleanOp::rgx = wregex(L"==|!=|<=|>=|and|or|xor");
 Toke_BooleanOp::Toke_BooleanOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BooleanOp;
    this->style = SkoarStyles::style<ESkoarToke::BooleanOp>();
    ++SkoarMemories.Tokes;
}

 Toke_BooleanOp::~Toke_BooleanOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_BooleanOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_BooleanOp(s,offs,s.length());
}

const std::wregex Toke_Caesura::rgx = wregex(L"//");
 Toke_Caesura::Toke_Caesura(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Caesura;
    this->style = SkoarStyles::style<ESkoarToke::Caesura>();
    ++SkoarMemories.Tokes;
}

 Toke_Caesura::~Toke_Caesura() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Caesura::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Caesura::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Caesura(s,offs,s.length());
}

const std::wregex Toke_Carrot::rgx = wregex(L"\\^(?!\\^[(])");
 Toke_Carrot::Toke_Carrot(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Carrot;
    this->style = SkoarStyles::style<ESkoarToke::Carrot>();
    ++SkoarMemories.Tokes;
}

 Toke_Carrot::~Toke_Carrot() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Carrot::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Carrot::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Carrot(s,offs,s.length());
}

const std::wregex Toke_Choard::rgx = wregex(L"[ABCDEFG](?![ce-ln-rt-zA-LN-Z])(#|b)?([Mm0-9]|sus|dim|aug|dom|add)*");
 Toke_Choard::Toke_Choard(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Choard;
    this->style = SkoarStyles::style<ESkoarToke::Choard>();
    ++SkoarMemories.Tokes;
}

 Toke_Choard::~Toke_Choard() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Choard::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Choard::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Choard(s,offs,s.length());
}

const std::wregex Toke_Coda::rgx = wregex(L"\\([+]\\)(?:`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*)?");
 Toke_Coda::Toke_Coda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Coda;
    this->style = SkoarStyles::style<ESkoarToke::Coda>();
    ++SkoarMemories.Tokes;
}

 Toke_Coda::~Toke_Coda() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Coda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Coda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Coda(s,offs,s.length());
}

const std::wregex Toke_Comment::rgx = wregex(L"<[?](.|[\\n\\r\\f])*?[?]>");
 Toke_Comment::Toke_Comment(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Comment;
    this->style = SkoarStyles::style<ESkoarToke::Comment>();
    ++SkoarMemories.Tokes;
}

 Toke_Comment::~Toke_Comment() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Comment::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Comment::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Comment(s,offs,s.length());
}

const std::wregex Toke_CondE::rgx = wregex(L"[?][}]");
 Toke_CondE::Toke_CondE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondE;
    this->style = SkoarStyles::style<ESkoarToke::CondE>();
    ++SkoarMemories.Tokes;
}

 Toke_CondE::~Toke_CondE() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_CondE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondE(s,offs,s.length());
}

const std::wregex Toke_CondIf::rgx = wregex(L"[?][?](?![}])");
 Toke_CondIf::Toke_CondIf(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondIf;
    this->style = SkoarStyles::style<ESkoarToke::CondIf>();
    ++SkoarMemories.Tokes;
}

 Toke_CondIf::~Toke_CondIf() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_CondIf::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondIf::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondIf(s,offs,s.length());
}

const std::wregex Toke_CondS::rgx = wregex(L"[{][?][\\n]*");
 Toke_CondS::Toke_CondS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondS;
    this->style = SkoarStyles::style<ESkoarToke::CondS>();
    ++SkoarMemories.Tokes;
}

 Toke_CondS::~Toke_CondS() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_CondS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondS(s,offs,s.length());
}

const std::wregex Toke_Crap::rgx = wregex(L"crap");
 Toke_Crap::Toke_Crap(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Crap;
    this->style = SkoarStyles::style<ESkoarToke::Crap>();
    ++SkoarMemories.Tokes;
}

 Toke_Crap::~Toke_Crap() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Crap::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crap::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Crap(s,offs,s.length());
}

const std::wregex Toke_Crotchets::rgx = wregex(L"[}]+\\.?");
 Toke_Crotchets::Toke_Crotchets(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Crotchets;
    this->style = SkoarStyles::style<ESkoarToke::Crotchets>();
    ++SkoarMemories.Tokes;
}

 Toke_Crotchets::~Toke_Crotchets() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Crotchets::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crotchets::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Crotchets(s,offs,s.length());
}

const std::wregex Toke_DaCapo::rgx = wregex(L"D\\.C\\.|Da Capo");
 Toke_DaCapo::Toke_DaCapo(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DaCapo;
    this->style = SkoarStyles::style<ESkoarToke::DaCapo>();
    ++SkoarMemories.Tokes;
}

 Toke_DaCapo::~Toke_DaCapo() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DaCapo::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DaCapo::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DaCapo(s,offs,s.length());
}

const std::wregex Toke_DalSegno::rgx = wregex(L"D\\.S\\.|Dal Segno");
 Toke_DalSegno::Toke_DalSegno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DalSegno;
    this->style = SkoarStyles::style<ESkoarToke::DalSegno>();
    ++SkoarMemories.Tokes;
}

 Toke_DalSegno::~Toke_DalSegno() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DalSegno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DalSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DalSegno(s,offs,s.length());
}

const std::wregex Toke_Deref::rgx = wregex(L"!(?![!}]|=)");
 Toke_Deref::Toke_Deref(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Deref;
    this->style = SkoarStyles::style<ESkoarToke::Deref>();
    ++SkoarMemories.Tokes;
}

 Toke_Deref::~Toke_Deref() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Deref::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Deref::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Deref(s,offs,s.length());
}

const std::wregex Toke_DynFP::rgx = wregex(L"fp");
 Toke_DynFP::Toke_DynFP(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynFP;
    this->style = SkoarStyles::style<ESkoarToke::DynFP>();
    ++SkoarMemories.Tokes;
}

 Toke_DynFP::~Toke_DynFP() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynFP::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynFP::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynFP(s,offs,s.length());
}

const std::wregex Toke_DynForte::rgx = wregex(L"m(ezzo)?f(orte)?|f+orte|ff+");
 Toke_DynForte::Toke_DynForte(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynForte;
    this->style = SkoarStyles::style<ESkoarToke::DynForte>();
    ++SkoarMemories.Tokes;
}

 Toke_DynForte::~Toke_DynForte() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynForte::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynForte::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynForte(s,offs,s.length());
}

const std::wregex Toke_DynPiano::rgx = wregex(L"(m(ezzo)?p|p+)(iano)?");
 Toke_DynPiano::Toke_DynPiano(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynPiano;
    this->style = SkoarStyles::style<ESkoarToke::DynPiano>();
    ++SkoarMemories.Tokes;
}

 Toke_DynPiano::~Toke_DynPiano() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynPiano::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynPiano::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynPiano(s,offs,s.length());
}

const std::wregex Toke_DynSFZ::rgx = wregex(L"sfz");
 Toke_DynSFZ::Toke_DynSFZ(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynSFZ;
    this->style = SkoarStyles::style<ESkoarToke::DynSFZ>();
    ++SkoarMemories.Tokes;
}

 Toke_DynSFZ::~Toke_DynSFZ() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_DynSFZ::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynSFZ::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynSFZ(s,offs,s.length());
}

const std::wregex Toke_Eighths::rgx = wregex(L"\\.?\\]+(?:__?)?\\.?");
 Toke_Eighths::Toke_Eighths(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Eighths;
    this->style = SkoarStyles::style<ESkoarToke::Eighths>();
    ++SkoarMemories.Tokes;
}

 Toke_Eighths::~Toke_Eighths() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Eighths::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Eighths::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Eighths(s,offs,s.length());
}

const std::wregex Toke_Fairy::rgx = wregex(L"[$]");
 Toke_Fairy::Toke_Fairy(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fairy;
    this->style = SkoarStyles::style<ESkoarToke::Fairy>();
    ++SkoarMemories.Tokes;
}

 Toke_Fairy::~Toke_Fairy() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Fairy::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fairy::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Fairy(s,offs,s.length());
}

const std::wregex Toke_False::rgx = wregex(L"no");
 Toke_False::Toke_False(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::False;
    this->style = SkoarStyles::style<ESkoarToke::False>();
    ++SkoarMemories.Tokes;
}

 Toke_False::~Toke_False() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_False::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_False::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_False(s,offs,s.length());
}

const std::wregex Toke_Fine::rgx = wregex(L"fine");
 Toke_Fine::Toke_Fine(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fine;
    this->style = SkoarStyles::style<ESkoarToke::Fine>();
    ++SkoarMemories.Tokes;
}

 Toke_Fine::~Toke_Fine() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Fine::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Fine(s,offs,s.length());
}

const std::wregex Toke_Float::rgx = wregex(L"(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz)");
 Toke_Float::Toke_Float(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Float;
    this->style = SkoarStyles::style<ESkoarToke::Float>();
    ++SkoarMemories.Tokes;
}

 Toke_Float::~Toke_Float() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Float::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Float::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Float(s,offs,s.length());
}

const std::wregex Toke_Freq::rgx = wregex(L"(0|[1-9][0-9]*)(\\.[0-9]+)?Hz");
 Toke_Freq::Toke_Freq(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Freq;
    this->style = SkoarStyles::style<ESkoarToke::Freq>();
    ++SkoarMemories.Tokes;
}

 Toke_Freq::~Toke_Freq() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Freq::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Freq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Freq(s,offs,s.length());
}

const std::wregex Toke_HashLevel::rgx = wregex(L"\\[#*[ ]*\\]");
 Toke_HashLevel::Toke_HashLevel(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::HashLevel;
    this->style = SkoarStyles::style<ESkoarToke::HashLevel>();
    ++SkoarMemories.Tokes;
}

 Toke_HashLevel::~Toke_HashLevel() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_HashLevel::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_HashLevel::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_HashLevel(s,offs,s.length());
}

const std::wregex Toke_Int::rgx = wregex(L"(-)?(0|[1-9][0-9]*)(?![0-9]*Hz|[mv][ab]|\\.[0-9]|/)");
 Toke_Int::Toke_Int(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Int;
    this->style = SkoarStyles::style<ESkoarToke::Int>();
    ++SkoarMemories.Tokes;
}

 Toke_Int::~Toke_Int() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Int::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Int::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Int(s,offs,s.length());
}

const std::wregex Toke_LWing::rgx = wregex(L"\\^\\^[(]");
 Toke_LWing::Toke_LWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LWing;
    this->style = SkoarStyles::style<ESkoarToke::LWing>();
    ++SkoarMemories.Tokes;
}

 Toke_LWing::~Toke_LWing() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LWing(s,offs,s.length());
}

const std::wregex Toke_ListE::rgx = wregex(L">(?![=])");
 Toke_ListE::Toke_ListE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListE;
    this->style = SkoarStyles::style<ESkoarToke::ListE>();
    ++SkoarMemories.Tokes;
}

 Toke_ListE::~Toke_ListE() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ListE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListE(s,offs,s.length());
}

const std::wregex Toke_ListS::rgx = wregex(L"<(?![=?])");
 Toke_ListS::Toke_ListS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListS;
    this->style = SkoarStyles::style<ESkoarToke::ListS>();
    ++SkoarMemories.Tokes;
}

 Toke_ListS::~Toke_ListS() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ListS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListS(s,offs,s.length());
}

const std::wregex Toke_ListSep::rgx = wregex(L",");
 Toke_ListSep::Toke_ListSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListSep;
    this->style = SkoarStyles::style<ESkoarToke::ListSep>();
    ++SkoarMemories.Tokes;
}

 Toke_ListSep::~Toke_ListSep() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_ListSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListSep(s,offs,s.length());
}

const std::wregex Toke_Loco::rgx = wregex(L"loco");
 Toke_Loco::Toke_Loco(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Loco;
    this->style = SkoarStyles::style<ESkoarToke::Loco>();
    ++SkoarMemories.Tokes;
}

 Toke_Loco::~Toke_Loco() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Loco::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Loco::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Loco(s,offs,s.length());
}

const std::wregex Toke_LoopE::rgx = wregex(L":[}]");
 Toke_LoopE::Toke_LoopE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopE;
    this->style = SkoarStyles::style<ESkoarToke::LoopE>();
    ++SkoarMemories.Tokes;
}

 Toke_LoopE::~Toke_LoopE() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LoopE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopE(s,offs,s.length());
}

const std::wregex Toke_LoopS::rgx = wregex(L"[{]:[\\n]*");
 Toke_LoopS::Toke_LoopS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopS;
    this->style = SkoarStyles::style<ESkoarToke::LoopS>();
    ++SkoarMemories.Tokes;
}

 Toke_LoopS::~Toke_LoopS() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LoopS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopS(s,offs,s.length());
}

const std::wregex Toke_LoopSep::rgx = wregex(L"::[\\n]*(?![|])");
 Toke_LoopSep::Toke_LoopSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopSep;
    this->style = SkoarStyles::style<ESkoarToke::LoopSep>();
    ++SkoarMemories.Tokes;
}

 Toke_LoopSep::~Toke_LoopSep() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_LoopSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopSep(s,offs,s.length());
}

const std::wregex Toke_MathOp::rgx = wregex(L"[+x\\-](?!>|or)");
 Toke_MathOp::Toke_MathOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MathOp;
    this->style = SkoarStyles::style<ESkoarToke::MathOp>();
    ++SkoarMemories.Tokes;
}

 Toke_MathOp::~Toke_MathOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MathOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MathOp(s,offs,s.length());
}

const std::wregex Toke_Meter::rgx = wregex(L"[1-9][0-9]*/[1-9][0-9]*");
 Toke_Meter::Toke_Meter(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Meter;
    this->style = SkoarStyles::style<ESkoarToke::Meter>();
    ++SkoarMemories.Tokes;
}

 Toke_Meter::~Toke_Meter() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Meter::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Meter::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Meter(s,offs,s.length());
}

const std::wregex Toke_MsgName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*(?!<)");
 Toke_MsgName::Toke_MsgName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgName;
    this->style = SkoarStyles::style<ESkoarToke::MsgName>();
    ++SkoarMemories.Tokes;
}

 Toke_MsgName::~Toke_MsgName() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MsgName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgName(s,offs,s.length());
}

const std::wregex Toke_MsgNameWithArgs::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*<");
 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgNameWithArgs;
    this->style = SkoarStyles::style<ESkoarToke::MsgNameWithArgs>();
    ++SkoarMemories.Tokes;
}

 Toke_MsgNameWithArgs::~Toke_MsgNameWithArgs() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MsgNameWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgNameWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgNameWithArgs(s,offs,s.length());
}

const std::wregex Toke_MsgOp::rgx = wregex(L"\\.(?![)\\]])");
 Toke_MsgOp::Toke_MsgOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgOp;
    this->style = SkoarStyles::style<ESkoarToke::MsgOp>();
    ++SkoarMemories.Tokes;
}

 Toke_MsgOp::~Toke_MsgOp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_MsgOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgOp(s,offs,s.length());
}

const std::wregex Toke_NamedNoat::rgx = wregex(L"(?:_?)(?:[a-g](?![ac-zA-Z_]))(#|b)?");
 Toke_NamedNoat::Toke_NamedNoat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::NamedNoat;
    this->style = SkoarStyles::style<ESkoarToke::NamedNoat>();
    ++SkoarMemories.Tokes;
}

 Toke_NamedNoat::~Toke_NamedNoat() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_NamedNoat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_NamedNoat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_NamedNoat(s,offs,s.length());
}

const std::wregex Toke_Newline::rgx = wregex(L"[\\n\\r\\f \\t]*[\\n\\r\\f]");
 Toke_Newline::Toke_Newline(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Newline;
    this->style = SkoarStyles::style<ESkoarToke::Newline>();
    ++SkoarMemories.Tokes;
}

 Toke_Newline::~Toke_Newline() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Newline::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Newline::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Newline(s,offs,s.length());
}

const std::wregex Toke_Nosey::rgx = wregex(L",");
 Toke_Nosey::Toke_Nosey(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Nosey;
    this->style = SkoarStyles::style<ESkoarToke::Nosey>();
    ++SkoarMemories.Tokes;
}

 Toke_Nosey::~Toke_Nosey() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Nosey::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Nosey::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Nosey(s,offs,s.length());
}

const std::wregex Toke_OctaveShift::rgx = wregex(L"~+o|o~+");
 Toke_OctaveShift::Toke_OctaveShift(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OctaveShift;
    this->style = SkoarStyles::style<ESkoarToke::OctaveShift>();
    ++SkoarMemories.Tokes;
}

 Toke_OctaveShift::~Toke_OctaveShift() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_OctaveShift::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OctaveShift::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OctaveShift(s,offs,s.length());
}

const std::wregex Toke_OttavaA::rgx = wregex(L"8va|ottava (alta|sopra)|all' ottava");
 Toke_OttavaA::Toke_OttavaA(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaA;
    this->style = SkoarStyles::style<ESkoarToke::OttavaA>();
    ++SkoarMemories.Tokes;
}

 Toke_OttavaA::~Toke_OttavaA() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_OttavaA::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OttavaA(s,offs,s.length());
}

const std::wregex Toke_OttavaB::rgx = wregex(L"8vb|ottava (bassa|sotto)");
 Toke_OttavaB::Toke_OttavaB(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaB;
    this->style = SkoarStyles::style<ESkoarToke::OttavaB>();
    ++SkoarMemories.Tokes;
}

 Toke_OttavaB::~Toke_OttavaB() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_OttavaB::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OttavaB(s,offs,s.length());
}

const std::wregex Toke_PedalDown::rgx = wregex(L"Ped\\.?");
 Toke_PedalDown::Toke_PedalDown(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::PedalDown;
    this->style = SkoarStyles::style<ESkoarToke::PedalDown>();
    ++SkoarMemories.Tokes;
}

 Toke_PedalDown::~Toke_PedalDown() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_PedalDown::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalDown::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_PedalDown(s,offs,s.length());
}

const std::wregex Toke_PedalUp::rgx = wregex(L"[*](?!>)");
 Toke_PedalUp::Toke_PedalUp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::PedalUp;
    this->style = SkoarStyles::style<ESkoarToke::PedalUp>();
    ++SkoarMemories.Tokes;
}

 Toke_PedalUp::~Toke_PedalUp() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_PedalUp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalUp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_PedalUp(s,offs,s.length());
}

const std::wregex Toke_Portamento::rgx = wregex(L"port\\.?");
 Toke_Portamento::Toke_Portamento(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Portamento;
    this->style = SkoarStyles::style<ESkoarToke::Portamento>();
    ++SkoarMemories.Tokes;
}

 Toke_Portamento::~Toke_Portamento() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Portamento::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Portamento::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Portamento(s,offs,s.length());
}

const std::wregex Toke_Quarters::rgx = wregex(L"\\.?[)]+(?:__?)?\\.?");
 Toke_Quarters::Toke_Quarters(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quarters;
    this->style = SkoarStyles::style<ESkoarToke::Quarters>();
    ++SkoarMemories.Tokes;
}

 Toke_Quarters::~Toke_Quarters() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Quarters::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quarters::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quarters(s,offs,s.length());
}

const std::wregex Toke_Quavers::rgx = wregex(L"o+/\\.?");
 Toke_Quavers::Toke_Quavers(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quavers;
    this->style = SkoarStyles::style<ESkoarToke::Quavers>();
    ++SkoarMemories.Tokes;
}

 Toke_Quavers::~Toke_Quavers() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Quavers::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quavers::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quavers(s,offs,s.length());
}

const std::wregex Toke_QuindicesimaA::rgx = wregex(L"15ma|alla quindicesima");
 Toke_QuindicesimaA::Toke_QuindicesimaA(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaA;
    this->style = SkoarStyles::style<ESkoarToke::QuindicesimaA>();
    ++SkoarMemories.Tokes;
}

 Toke_QuindicesimaA::~Toke_QuindicesimaA() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_QuindicesimaA::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_QuindicesimaA(s,offs,s.length());
}

const std::wregex Toke_QuindicesimaB::rgx = wregex(L"15mb");
 Toke_QuindicesimaB::Toke_QuindicesimaB(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaB;
    this->style = SkoarStyles::style<ESkoarToke::QuindicesimaB>();
    ++SkoarMemories.Tokes;
}

 Toke_QuindicesimaB::~Toke_QuindicesimaB() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_QuindicesimaB::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_QuindicesimaB(s,offs,s.length());
}

const std::wregex Toke_RWing::rgx = wregex(L"[)]\\^\\^");
 Toke_RWing::Toke_RWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::RWing;
    this->style = SkoarStyles::style<ESkoarToke::RWing>();
    ++SkoarMemories.Tokes;
}

 Toke_RWing::~Toke_RWing() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_RWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_RWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_RWing(s,offs,s.length());
}

const std::wregex Toke_Rep::rgx = wregex(L"%+");
 Toke_Rep::Toke_Rep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Rep;
    this->style = SkoarStyles::style<ESkoarToke::Rep>();
    ++SkoarMemories.Tokes;
}

 Toke_Rep::~Toke_Rep() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Rep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Rep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Rep(s,offs,s.length());
}

const std::wregex Toke_Segno::rgx = wregex(L",[Ss](?:egno)?`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*");
 Toke_Segno::Toke_Segno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Segno;
    this->style = SkoarStyles::style<ESkoarToke::Segno>();
    ++SkoarMemories.Tokes;
}

 Toke_Segno::~Toke_Segno() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Segno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Segno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Segno(s,offs,s.length());
}

const std::wregex Toke_Semicolon::rgx = wregex(L";");
 Toke_Semicolon::Toke_Semicolon(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Semicolon;
    this->style = SkoarStyles::style<ESkoarToke::Semicolon>();
    ++SkoarMemories.Tokes;
}

 Toke_Semicolon::~Toke_Semicolon() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Semicolon::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Semicolon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Semicolon(s,offs,s.length());
}

const std::wregex Toke_SkoarpionEnd::rgx = wregex(L"![}]");
 Toke_SkoarpionEnd::Toke_SkoarpionEnd(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionEnd;
    this->style = SkoarStyles::style<ESkoarToke::SkoarpionEnd>();
    ++SkoarMemories.Tokes;
}

 Toke_SkoarpionEnd::~Toke_SkoarpionEnd() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SkoarpionEnd::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionEnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionEnd(s,offs,s.length());
}

const std::wregex Toke_SkoarpionSep::rgx = wregex(L"!!");
 Toke_SkoarpionSep::Toke_SkoarpionSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionSep;
    this->style = SkoarStyles::style<ESkoarToke::SkoarpionSep>();
    ++SkoarMemories.Tokes;
}

 Toke_SkoarpionSep::~Toke_SkoarpionSep() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SkoarpionSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionSep(s,offs,s.length());
}

const std::wregex Toke_SkoarpionStart::rgx = wregex(L"[{]!");
 Toke_SkoarpionStart::Toke_SkoarpionStart(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionStart;
    this->style = SkoarStyles::style<ESkoarToke::SkoarpionStart>();
    ++SkoarMemories.Tokes;
}

 Toke_SkoarpionStart::~Toke_SkoarpionStart() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SkoarpionStart::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStart::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionStart(s,offs,s.length());
}

const std::wregex Toke_Slash::rgx = wregex(L"/(?![/0-9])");
 Toke_Slash::Toke_Slash(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Slash;
    this->style = SkoarStyles::style<ESkoarToke::Slash>();
    ++SkoarMemories.Tokes;
}

 Toke_Slash::~Toke_Slash() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Slash::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Slash::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Slash(s,offs,s.length());
}

const std::wregex Toke_String::rgx = wregex(L"'[^']*'");
 Toke_String::Toke_String(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::String;
    this->style = SkoarStyles::style<ESkoarToke::String>();
    ++SkoarMemories.Tokes;
}

 Toke_String::~Toke_String() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_String::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_String::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_String(s,offs,s.length());
}

const std::wregex Toke_Symbol::rgx = wregex(L"[\\\\@][a-zA-Z_][a-zA-Z0-9_]*");
 Toke_Symbol::Toke_Symbol(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Symbol;
    this->style = SkoarStyles::style<ESkoarToke::Symbol>();
    ++SkoarMemories.Tokes;
}

 Toke_Symbol::~Toke_Symbol() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Symbol::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Symbol::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Symbol(s,offs,s.length());
}

const std::wregex Toke_SymbolName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*");
 Toke_SymbolName::Toke_SymbolName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolName;
    this->style = SkoarStyles::style<ESkoarToke::SymbolName>();
    ++SkoarMemories.Tokes;
}

 Toke_SymbolName::~Toke_SymbolName() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_SymbolName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SymbolName(s,offs,s.length());
}

const std::wregex Toke_Times::rgx = wregex(L"[Tt]imes");
 Toke_Times::Toke_Times(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Times;
    this->style = SkoarStyles::style<ESkoarToke::Times>();
    ++SkoarMemories.Tokes;
}

 Toke_Times::~Toke_Times() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Times::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Times::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Times(s,offs,s.length());
}

const std::wregex Toke_True::rgx = wregex(L"yes");
 Toke_True::Toke_True(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::True;
    this->style = SkoarStyles::style<ESkoarToke::True>();
    ++SkoarMemories.Tokes;
}

 Toke_True::~Toke_True() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_True::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_True::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_True(s,offs,s.length());
}

const std::wregex Toke_Tuplet::rgx = wregex(L"/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?");
 Toke_Tuplet::Toke_Tuplet(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Tuplet;
    this->style = SkoarStyles::style<ESkoarToke::Tuplet>();
    ++SkoarMemories.Tokes;
}

 Toke_Tuplet::~Toke_Tuplet() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Tuplet::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Tuplet::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Tuplet(s,offs,s.length());
}

const std::wregex Toke_Voice::rgx = wregex(L"\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)");
 Toke_Voice::Toke_Voice(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Voice;
    this->style = SkoarStyles::style<ESkoarToke::Voice>();
    ++SkoarMemories.Tokes;
}

 Toke_Voice::~Toke_Voice() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Voice::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Voice::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Voice(s,offs,s.length());
}

const std::wregex Toke_Volta::rgx = wregex(L"\\[\\d+\\.\\]");
 Toke_Volta::Toke_Volta(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Volta;
    this->style = SkoarStyles::style<ESkoarToke::Volta>();
    ++SkoarMemories.Tokes;
}

 Toke_Volta::~Toke_Volta() {
    --SkoarMemories.Tokes;
}

SkoarToke* Toke_Volta::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Volta::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Volta(s,offs,s.length());
}


   
SkoarDispensary::SkoarDispensary() {
table[ESkoarToke::AlCoda] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlCoda::match_toke(buf, offs);
        };
table[ESkoarToke::AlFine] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlFine::match_toke(buf, offs);
        };
table[ESkoarToke::AlSegno] = 
        [](wstring *buf, size_t offs) {
            return Toke_AlSegno::match_toke(buf, offs);
        };
table[ESkoarToke::ArgSpec] = 
        [](wstring *buf, size_t offs) {
            return Toke_ArgSpec::match_toke(buf, offs);
        };
table[ESkoarToke::AssOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_AssOp::match_toke(buf, offs);
        };
table[ESkoarToke::Bars] = 
        [](wstring *buf, size_t offs) {
            return Toke_Bars::match_toke(buf, offs);
        };
table[ESkoarToke::BooleanOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_BooleanOp::match_toke(buf, offs);
        };
table[ESkoarToke::Caesura] = 
        [](wstring *buf, size_t offs) {
            return Toke_Caesura::match_toke(buf, offs);
        };
table[ESkoarToke::Carrot] = 
        [](wstring *buf, size_t offs) {
            return Toke_Carrot::match_toke(buf, offs);
        };
table[ESkoarToke::Choard] = 
        [](wstring *buf, size_t offs) {
            return Toke_Choard::match_toke(buf, offs);
        };
table[ESkoarToke::Coda] = 
        [](wstring *buf, size_t offs) {
            return Toke_Coda::match_toke(buf, offs);
        };
table[ESkoarToke::Comment] = 
        [](wstring *buf, size_t offs) {
            return Toke_Comment::match_toke(buf, offs);
        };
table[ESkoarToke::CondE] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondE::match_toke(buf, offs);
        };
table[ESkoarToke::CondIf] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondIf::match_toke(buf, offs);
        };
table[ESkoarToke::CondS] = 
        [](wstring *buf, size_t offs) {
            return Toke_CondS::match_toke(buf, offs);
        };
table[ESkoarToke::Crap] = 
        [](wstring *buf, size_t offs) {
            return Toke_Crap::match_toke(buf, offs);
        };
table[ESkoarToke::Crotchets] = 
        [](wstring *buf, size_t offs) {
            return Toke_Crotchets::match_toke(buf, offs);
        };
table[ESkoarToke::DaCapo] = 
        [](wstring *buf, size_t offs) {
            return Toke_DaCapo::match_toke(buf, offs);
        };
table[ESkoarToke::DalSegno] = 
        [](wstring *buf, size_t offs) {
            return Toke_DalSegno::match_toke(buf, offs);
        };
table[ESkoarToke::Deref] = 
        [](wstring *buf, size_t offs) {
            return Toke_Deref::match_toke(buf, offs);
        };
table[ESkoarToke::DynFP] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynFP::match_toke(buf, offs);
        };
table[ESkoarToke::DynForte] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynForte::match_toke(buf, offs);
        };
table[ESkoarToke::DynPiano] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynPiano::match_toke(buf, offs);
        };
table[ESkoarToke::DynSFZ] = 
        [](wstring *buf, size_t offs) {
            return Toke_DynSFZ::match_toke(buf, offs);
        };
table[ESkoarToke::Eighths] = 
        [](wstring *buf, size_t offs) {
            return Toke_Eighths::match_toke(buf, offs);
        };
table[ESkoarToke::Fairy] = 
        [](wstring *buf, size_t offs) {
            return Toke_Fairy::match_toke(buf, offs);
        };
table[ESkoarToke::False] = 
        [](wstring *buf, size_t offs) {
            return Toke_False::match_toke(buf, offs);
        };
table[ESkoarToke::Fine] = 
        [](wstring *buf, size_t offs) {
            return Toke_Fine::match_toke(buf, offs);
        };
table[ESkoarToke::Float] = 
        [](wstring *buf, size_t offs) {
            return Toke_Float::match_toke(buf, offs);
        };
table[ESkoarToke::Freq] = 
        [](wstring *buf, size_t offs) {
            return Toke_Freq::match_toke(buf, offs);
        };
table[ESkoarToke::HashLevel] = 
        [](wstring *buf, size_t offs) {
            return Toke_HashLevel::match_toke(buf, offs);
        };
table[ESkoarToke::Int] = 
        [](wstring *buf, size_t offs) {
            return Toke_Int::match_toke(buf, offs);
        };
table[ESkoarToke::LWing] = 
        [](wstring *buf, size_t offs) {
            return Toke_LWing::match_toke(buf, offs);
        };
table[ESkoarToke::ListE] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListE::match_toke(buf, offs);
        };
table[ESkoarToke::ListS] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListS::match_toke(buf, offs);
        };
table[ESkoarToke::ListSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_ListSep::match_toke(buf, offs);
        };
table[ESkoarToke::Loco] = 
        [](wstring *buf, size_t offs) {
            return Toke_Loco::match_toke(buf, offs);
        };
table[ESkoarToke::LoopE] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopE::match_toke(buf, offs);
        };
table[ESkoarToke::LoopS] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopS::match_toke(buf, offs);
        };
table[ESkoarToke::LoopSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_LoopSep::match_toke(buf, offs);
        };
table[ESkoarToke::MathOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_MathOp::match_toke(buf, offs);
        };
table[ESkoarToke::Meter] = 
        [](wstring *buf, size_t offs) {
            return Toke_Meter::match_toke(buf, offs);
        };
table[ESkoarToke::MsgName] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgName::match_toke(buf, offs);
        };
table[ESkoarToke::MsgNameWithArgs] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgNameWithArgs::match_toke(buf, offs);
        };
table[ESkoarToke::MsgOp] = 
        [](wstring *buf, size_t offs) {
            return Toke_MsgOp::match_toke(buf, offs);
        };
table[ESkoarToke::NamedNoat] = 
        [](wstring *buf, size_t offs) {
            return Toke_NamedNoat::match_toke(buf, offs);
        };
table[ESkoarToke::Newline] = 
        [](wstring *buf, size_t offs) {
            return Toke_Newline::match_toke(buf, offs);
        };
table[ESkoarToke::Nosey] = 
        [](wstring *buf, size_t offs) {
            return Toke_Nosey::match_toke(buf, offs);
        };
table[ESkoarToke::OctaveShift] = 
        [](wstring *buf, size_t offs) {
            return Toke_OctaveShift::match_toke(buf, offs);
        };
table[ESkoarToke::OttavaA] = 
        [](wstring *buf, size_t offs) {
            return Toke_OttavaA::match_toke(buf, offs);
        };
table[ESkoarToke::OttavaB] = 
        [](wstring *buf, size_t offs) {
            return Toke_OttavaB::match_toke(buf, offs);
        };
table[ESkoarToke::PedalDown] = 
        [](wstring *buf, size_t offs) {
            return Toke_PedalDown::match_toke(buf, offs);
        };
table[ESkoarToke::PedalUp] = 
        [](wstring *buf, size_t offs) {
            return Toke_PedalUp::match_toke(buf, offs);
        };
table[ESkoarToke::Portamento] = 
        [](wstring *buf, size_t offs) {
            return Toke_Portamento::match_toke(buf, offs);
        };
table[ESkoarToke::Quarters] = 
        [](wstring *buf, size_t offs) {
            return Toke_Quarters::match_toke(buf, offs);
        };
table[ESkoarToke::Quavers] = 
        [](wstring *buf, size_t offs) {
            return Toke_Quavers::match_toke(buf, offs);
        };
table[ESkoarToke::QuindicesimaA] = 
        [](wstring *buf, size_t offs) {
            return Toke_QuindicesimaA::match_toke(buf, offs);
        };
table[ESkoarToke::QuindicesimaB] = 
        [](wstring *buf, size_t offs) {
            return Toke_QuindicesimaB::match_toke(buf, offs);
        };
table[ESkoarToke::RWing] = 
        [](wstring *buf, size_t offs) {
            return Toke_RWing::match_toke(buf, offs);
        };
table[ESkoarToke::Rep] = 
        [](wstring *buf, size_t offs) {
            return Toke_Rep::match_toke(buf, offs);
        };
table[ESkoarToke::Segno] = 
        [](wstring *buf, size_t offs) {
            return Toke_Segno::match_toke(buf, offs);
        };
table[ESkoarToke::Semicolon] = 
        [](wstring *buf, size_t offs) {
            return Toke_Semicolon::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionEnd] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionEnd::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionSep] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionSep::match_toke(buf, offs);
        };
table[ESkoarToke::SkoarpionStart] = 
        [](wstring *buf, size_t offs) {
            return Toke_SkoarpionStart::match_toke(buf, offs);
        };
table[ESkoarToke::Slash] = 
        [](wstring *buf, size_t offs) {
            return Toke_Slash::match_toke(buf, offs);
        };
table[ESkoarToke::String] = 
        [](wstring *buf, size_t offs) {
            return Toke_String::match_toke(buf, offs);
        };
table[ESkoarToke::Symbol] = 
        [](wstring *buf, size_t offs) {
            return Toke_Symbol::match_toke(buf, offs);
        };
table[ESkoarToke::SymbolName] = 
        [](wstring *buf, size_t offs) {
            return Toke_SymbolName::match_toke(buf, offs);
        };
table[ESkoarToke::Times] = 
        [](wstring *buf, size_t offs) {
            return Toke_Times::match_toke(buf, offs);
        };
table[ESkoarToke::True] = 
        [](wstring *buf, size_t offs) {
            return Toke_True::match_toke(buf, offs);
        };
table[ESkoarToke::Tuplet] = 
        [](wstring *buf, size_t offs) {
            return Toke_Tuplet::match_toke(buf, offs);
        };
table[ESkoarToke::Voice] = 
        [](wstring *buf, size_t offs) {
            return Toke_Voice::match_toke(buf, offs);
        };
table[ESkoarToke::Volta] = 
        [](wstring *buf, size_t offs) {
            return Toke_Volta::match_toke(buf, offs);
        };

}

SkoarToke* SkoarDispensary::match_toke(ESkoarToke::Kind want, wstring *buf, size_t offs) {
    auto f = table[want];
    if (f) 
        return f(buf, offs);
    return nullptr;
}
