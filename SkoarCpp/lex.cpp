// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2015-08-02 05:38:07 for C++14
// ======================================================================
#include "lex.hpp"
#include "exception.hpp"
// ------------------
// Abstract SkoarToke
// ------------------
SkoarToke * SkoarToke::aninstance = nullptr;
SkoarToke * SkoarToke::instance() {
    if (aninstance == nullptr) {;
        aninstance = new SkoarToke();;
    };
    return aninstance;;
}

 SkoarToke::SkoarToke() {
}

 SkoarToke::SkoarToke(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

// how many characters to burn from the buffer
size_t SkoarToke::burn() {
    return size;
}

// we override and return nullptr for no match, new toke otherwise
SkoarToke* SkoarToke::match_toke(string * buf, size_t offs) {
    return nullptr;
}

// --------------
// EOF is special
// --------------
 Toke_EOF::Toke_EOF() {
    this->lexeme = nullptr;
    this->size = 0;
}

Toke_EOF * Toke_EOF::aninstance = nullptr;
Toke_EOF * Toke_EOF::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_EOF();;
    };
    return aninstance;;
}

size_t Toke_EOF::burn(string * buf, size_t offs) {
    if (buf->size() > offs) {
        throw new SkoarError("Tried to burn EOF when there's more input.");
    }

    return 0;
}

SkoarToke* Toke_EOF::match_toke(string * buf, size_t offs) {
    if (buf->size() < offs) {
        throw new SkoarError("Tried to burn EOF when there's more input.");
    }

    if (buf->size() == offs) {
        return new Toke_EOF();
    }

    return nullptr;
}

// ---------------------
// Whitespace is special
// ---------------------
 Toke_Whitespace::Toke_Whitespace() {
    this->lexeme = nullptr;
    this->size = 0;
}

Toke_Whitespace * Toke_Whitespace::aninstance = nullptr;
Toke_Whitespace * Toke_Whitespace::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Whitespace();;
    };
    return aninstance;;
}

const regex Toke_Whitespace::rgx = regex("[ \\t]*");

size_t Toke_Whitespace::burn(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Whitespace::rgx, regex_constants::match_continuous);
    if (!found) {
        return 0;
    }

    return matches[0].length();
}

// --------------
// Everyday Tokes
// --------------
const std::regex Toke_Comment::rgx = regex("<[?](.|[\\n\\r\\f])*?[?]>");
Toke_Comment * Toke_Comment::aninstance = nullptr;
Toke_Comment * Toke_Comment::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Comment();;
    };
    return aninstance;;
}

 Toke_Comment::Toke_Comment() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Comment::Toke_Comment(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Comment::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Comment::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Comment(s,s->length());
}

const std::regex Toke_Volta::rgx = regex("\\[\\d+\\.\\]");
Toke_Volta * Toke_Volta::aninstance = nullptr;
Toke_Volta * Toke_Volta::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Volta();;
    };
    return aninstance;;
}

 Toke_Volta::Toke_Volta() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Volta::Toke_Volta(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Volta::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Volta::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Volta(s,s->length());
}

const std::regex Toke_Quavers::rgx = regex("o+/\\.?");
Toke_Quavers * Toke_Quavers::aninstance = nullptr;
Toke_Quavers * Toke_Quavers::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Quavers();;
    };
    return aninstance;;
}

 Toke_Quavers::Toke_Quavers() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Quavers::Toke_Quavers(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Quavers::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quavers::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Quavers(s,s->length());
}

const std::regex Toke_OttavaB::rgx = regex("8vb|ottava (bassa|sotto)");
Toke_OttavaB * Toke_OttavaB::aninstance = nullptr;
Toke_OttavaB * Toke_OttavaB::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_OttavaB();;
    };
    return aninstance;;
}

 Toke_OttavaB::Toke_OttavaB() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_OttavaB::Toke_OttavaB(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_OttavaB::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_OttavaB(s,s->length());
}

const std::regex Toke_Choard::rgx = regex("(D(?![a.])|[ABCEFG])([Mm0-9]|sus|dim)*");
Toke_Choard * Toke_Choard::aninstance = nullptr;
Toke_Choard * Toke_Choard::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Choard();;
    };
    return aninstance;;
}

 Toke_Choard::Toke_Choard() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Choard::Toke_Choard(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Choard::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Choard::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Choard(s,s->length());
}

const std::regex Toke_Crotchets::rgx = regex("[}]+\\.?");
Toke_Crotchets * Toke_Crotchets::aninstance = nullptr;
Toke_Crotchets * Toke_Crotchets::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Crotchets();;
    };
    return aninstance;;
}

 Toke_Crotchets::Toke_Crotchets() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Crotchets::Toke_Crotchets(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Crotchets::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crotchets::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Crotchets(s,s->length());
}

const std::regex Toke_Caesura::rgx = regex("//");
Toke_Caesura * Toke_Caesura::aninstance = nullptr;
Toke_Caesura * Toke_Caesura::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Caesura();;
    };
    return aninstance;;
}

 Toke_Caesura::Toke_Caesura() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Caesura::Toke_Caesura(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Caesura::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Caesura::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Caesura(s,s->length());
}

const std::regex Toke_ListS::rgx = regex("<(?![=?])");
Toke_ListS * Toke_ListS::aninstance = nullptr;
Toke_ListS * Toke_ListS::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_ListS();;
    };
    return aninstance;;
}

 Toke_ListS::Toke_ListS() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_ListS::Toke_ListS(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_ListS::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_ListS(s,s->length());
}

const std::regex Toke_String::rgx = regex("'[^']*'");
Toke_String * Toke_String::aninstance = nullptr;
Toke_String * Toke_String::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_String();;
    };
    return aninstance;;
}

 Toke_String::Toke_String() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_String::Toke_String(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_String::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_String::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_String(s,s->length());
}

const std::regex Toke_RWing::rgx = regex("[)]\\^\\^");
Toke_RWing * Toke_RWing::aninstance = nullptr;
Toke_RWing * Toke_RWing::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_RWing();;
    };
    return aninstance;;
}

 Toke_RWing::Toke_RWing() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_RWing::Toke_RWing(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_RWing::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_RWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_RWing(s,s->length());
}

const std::regex Toke_Portamento::rgx = regex("port\\.?");
Toke_Portamento * Toke_Portamento::aninstance = nullptr;
Toke_Portamento * Toke_Portamento::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Portamento();;
    };
    return aninstance;;
}

 Toke_Portamento::Toke_Portamento() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Portamento::Toke_Portamento(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Portamento::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Portamento::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Portamento(s,s->length());
}

const std::regex Toke_Coda::rgx = regex("\\([+]\\)");
Toke_Coda * Toke_Coda::aninstance = nullptr;
Toke_Coda * Toke_Coda::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Coda();;
    };
    return aninstance;;
}

 Toke_Coda::Toke_Coda() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Coda::Toke_Coda(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Coda::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Coda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Coda(s,s->length());
}

const std::regex Toke_MsgName::rgx = regex("[a-zA-Z_][a-zA-Z0-9_]*(?!<)");
Toke_MsgName * Toke_MsgName::aninstance = nullptr;
Toke_MsgName * Toke_MsgName::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MsgName();;
    };
    return aninstance;;
}

 Toke_MsgName::Toke_MsgName() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MsgName::Toke_MsgName(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MsgName::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_MsgName(s,s->length());
}

const std::regex Toke_Newline::rgx = regex("[\\n\\r\\f][\\n\\r\\f \\t]*");
Toke_Newline * Toke_Newline::aninstance = nullptr;
Toke_Newline * Toke_Newline::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Newline();;
    };
    return aninstance;;
}

 Toke_Newline::Toke_Newline() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Newline::Toke_Newline(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Newline::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Newline::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Newline(s,s->length());
}

const std::regex Toke_SkoarpionSep::rgx = regex("!!");
Toke_SkoarpionSep * Toke_SkoarpionSep::aninstance = nullptr;
Toke_SkoarpionSep * Toke_SkoarpionSep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SkoarpionSep();;
    };
    return aninstance;;
}

 Toke_SkoarpionSep::Toke_SkoarpionSep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SkoarpionSep::Toke_SkoarpionSep(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SkoarpionSep::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_SkoarpionSep(s,s->length());
}

const std::regex Toke_Semicolon::rgx = regex(";");
Toke_Semicolon * Toke_Semicolon::aninstance = nullptr;
Toke_Semicolon * Toke_Semicolon::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Semicolon();;
    };
    return aninstance;;
}

 Toke_Semicolon::Toke_Semicolon() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Semicolon::Toke_Semicolon(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Semicolon::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Semicolon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Semicolon(s,s->length());
}

const std::regex Toke_Segno::rgx = regex(",segno`(?:_[a-zA-Z_][a-zA-Z0-9_]*`)*");
Toke_Segno * Toke_Segno::aninstance = nullptr;
Toke_Segno * Toke_Segno::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Segno();;
    };
    return aninstance;;
}

 Toke_Segno::Toke_Segno() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Segno::Toke_Segno(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Segno::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Segno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Segno(s,s->length());
}

const std::regex Toke_Int::rgx = regex("(-)?(0|[1-9][0-9]*)(?!Hz|[mv][ab]|\\.[0-9]|/)");
Toke_Int * Toke_Int::aninstance = nullptr;
Toke_Int * Toke_Int::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Int();;
    };
    return aninstance;;
}

 Toke_Int::Toke_Int() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Int::Toke_Int(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Int::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Int::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Int(s,s->length());
}

const std::regex Toke_Nosey::rgx = regex(",");
Toke_Nosey * Toke_Nosey::aninstance = nullptr;
Toke_Nosey * Toke_Nosey::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Nosey();;
    };
    return aninstance;;
}

 Toke_Nosey::Toke_Nosey() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Nosey::Toke_Nosey(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Nosey::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Nosey::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Nosey(s,s->length());
}

const std::regex Toke_DynFP::rgx = regex("fp");
Toke_DynFP * Toke_DynFP::aninstance = nullptr;
Toke_DynFP * Toke_DynFP::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynFP();;
    };
    return aninstance;;
}

 Toke_DynFP::Toke_DynFP() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynFP::Toke_DynFP(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynFP::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynFP::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_DynFP(s,s->length());
}

const std::regex Toke_Tuplet::rgx = regex("/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?");
Toke_Tuplet * Toke_Tuplet::aninstance = nullptr;
Toke_Tuplet * Toke_Tuplet::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Tuplet();;
    };
    return aninstance;;
}

 Toke_Tuplet::Toke_Tuplet() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Tuplet::Toke_Tuplet(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Tuplet::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Tuplet::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Tuplet(s,s->length());
}

const std::regex Toke_MsgOp::rgx = regex("\\.(?![)\\]])");
Toke_MsgOp * Toke_MsgOp::aninstance = nullptr;
Toke_MsgOp * Toke_MsgOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MsgOp();;
    };
    return aninstance;;
}

 Toke_MsgOp::Toke_MsgOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MsgOp::Toke_MsgOp(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MsgOp::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_MsgOp(s,s->length());
}

const std::regex Toke_DaCapo::rgx = regex("D\\.C\\.|Da Capo");
Toke_DaCapo * Toke_DaCapo::aninstance = nullptr;
Toke_DaCapo * Toke_DaCapo::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DaCapo();;
    };
    return aninstance;;
}

 Toke_DaCapo::Toke_DaCapo() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DaCapo::Toke_DaCapo(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DaCapo::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DaCapo::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_DaCapo(s,s->length());
}

const std::regex Toke_Symbol::rgx = regex("[\\\\@][a-zA-Z_][a-zA-Z0-9_]*");
Toke_Symbol * Toke_Symbol::aninstance = nullptr;
Toke_Symbol * Toke_Symbol::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Symbol();;
    };
    return aninstance;;
}

 Toke_Symbol::Toke_Symbol() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Symbol::Toke_Symbol(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Symbol::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Symbol::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Symbol(s,s->length());
}

const std::regex Toke_Loco::rgx = regex("loco");
Toke_Loco * Toke_Loco::aninstance = nullptr;
Toke_Loco * Toke_Loco::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Loco();;
    };
    return aninstance;;
}

 Toke_Loco::Toke_Loco() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Loco::Toke_Loco(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Loco::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Loco::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Loco(s,s->length());
}

const std::regex Toke_AlSegno::rgx = regex("al segno");
Toke_AlSegno * Toke_AlSegno::aninstance = nullptr;
Toke_AlSegno * Toke_AlSegno::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AlSegno();;
    };
    return aninstance;;
}

 Toke_AlSegno::Toke_AlSegno() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AlSegno::Toke_AlSegno(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AlSegno::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_AlSegno(s,s->length());
}

const std::regex Toke_OttavaA::rgx = regex("8va|ottava (alta|sopra)|all' ottava");
Toke_OttavaA * Toke_OttavaA::aninstance = nullptr;
Toke_OttavaA * Toke_OttavaA::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_OttavaA();;
    };
    return aninstance;;
}

 Toke_OttavaA::Toke_OttavaA() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_OttavaA::Toke_OttavaA(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_OttavaA::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_OttavaA(s,s->length());
}

const std::regex Toke_DalSegno::rgx = regex("D\\.S\\.|Dal Segno");
Toke_DalSegno * Toke_DalSegno::aninstance = nullptr;
Toke_DalSegno * Toke_DalSegno::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DalSegno();;
    };
    return aninstance;;
}

 Toke_DalSegno::Toke_DalSegno() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DalSegno::Toke_DalSegno(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DalSegno::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DalSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_DalSegno(s,s->length());
}

const std::regex Toke_OctaveShift::rgx = regex("~+o|o~+");
Toke_OctaveShift * Toke_OctaveShift::aninstance = nullptr;
Toke_OctaveShift * Toke_OctaveShift::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_OctaveShift();;
    };
    return aninstance;;
}

 Toke_OctaveShift::Toke_OctaveShift() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_OctaveShift::Toke_OctaveShift(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_OctaveShift::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OctaveShift::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_OctaveShift(s,s->length());
}

const std::regex Toke_DynSFZ::rgx = regex("sfz");
Toke_DynSFZ * Toke_DynSFZ::aninstance = nullptr;
Toke_DynSFZ * Toke_DynSFZ::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynSFZ();;
    };
    return aninstance;;
}

 Toke_DynSFZ::Toke_DynSFZ() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynSFZ::Toke_DynSFZ(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynSFZ::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynSFZ::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_DynSFZ(s,s->length());
}

const std::regex Toke_QuindicesimaB::rgx = regex("15mb");
Toke_QuindicesimaB * Toke_QuindicesimaB::aninstance = nullptr;
Toke_QuindicesimaB * Toke_QuindicesimaB::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_QuindicesimaB();;
    };
    return aninstance;;
}

 Toke_QuindicesimaB::Toke_QuindicesimaB() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_QuindicesimaB::Toke_QuindicesimaB(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_QuindicesimaB::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_QuindicesimaB(s,s->length());
}

const std::regex Toke_DynForte::rgx = regex("mf(orte)?|f+orte|ff+");
Toke_DynForte * Toke_DynForte::aninstance = nullptr;
Toke_DynForte * Toke_DynForte::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynForte();;
    };
    return aninstance;;
}

 Toke_DynForte::Toke_DynForte() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynForte::Toke_DynForte(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynForte::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynForte::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_DynForte(s,s->length());
}

const std::regex Toke_SkoarpionEnd::rgx = regex("![}]");
Toke_SkoarpionEnd * Toke_SkoarpionEnd::aninstance = nullptr;
Toke_SkoarpionEnd * Toke_SkoarpionEnd::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SkoarpionEnd();;
    };
    return aninstance;;
}

 Toke_SkoarpionEnd::Toke_SkoarpionEnd() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SkoarpionEnd::Toke_SkoarpionEnd(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SkoarpionEnd::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionEnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_SkoarpionEnd(s,s->length());
}

const std::regex Toke_SymbolName::rgx = regex("[a-zA-Z_][a-zA-Z0-9_]*");
Toke_SymbolName * Toke_SymbolName::aninstance = nullptr;
Toke_SymbolName * Toke_SymbolName::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SymbolName();;
    };
    return aninstance;;
}

 Toke_SymbolName::Toke_SymbolName() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SymbolName::Toke_SymbolName(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SymbolName::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_SymbolName(s,s->length());
}

const std::regex Toke_Eighths::rgx = regex("\\.?\\]+(?:__?)?\\.?");
Toke_Eighths * Toke_Eighths::aninstance = nullptr;
Toke_Eighths * Toke_Eighths::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Eighths();;
    };
    return aninstance;;
}

 Toke_Eighths::Toke_Eighths() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Eighths::Toke_Eighths(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Eighths::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Eighths::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Eighths(s,s->length());
}

const std::regex Toke_Quarters::rgx = regex("\\.?[)]+(?:__?)?\\.?");
Toke_Quarters * Toke_Quarters::aninstance = nullptr;
Toke_Quarters * Toke_Quarters::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Quarters();;
    };
    return aninstance;;
}

 Toke_Quarters::Toke_Quarters() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Quarters::Toke_Quarters(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Quarters::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quarters::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Quarters(s,s->length());
}

const std::regex Toke_Float::rgx = regex("(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz)");
Toke_Float * Toke_Float::aninstance = nullptr;
Toke_Float * Toke_Float::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Float();;
    };
    return aninstance;;
}

 Toke_Float::Toke_Float() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Float::Toke_Float(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Float::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Float::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Float(s,s->length());
}

const std::regex Toke_AlFine::rgx = regex("al fine");
Toke_AlFine * Toke_AlFine::aninstance = nullptr;
Toke_AlFine * Toke_AlFine::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AlFine();;
    };
    return aninstance;;
}

 Toke_AlFine::Toke_AlFine() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AlFine::Toke_AlFine(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AlFine::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlFine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_AlFine(s,s->length());
}

const std::regex Toke_Slash::rgx = regex("/(?![/0-9])");
Toke_Slash * Toke_Slash::aninstance = nullptr;
Toke_Slash * Toke_Slash::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Slash();;
    };
    return aninstance;;
}

 Toke_Slash::Toke_Slash() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Slash::Toke_Slash(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Slash::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Slash::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Slash(s,s->length());
}

const std::regex Toke_Bars::rgx = regex(":?\\|+:?");
Toke_Bars * Toke_Bars::aninstance = nullptr;
Toke_Bars * Toke_Bars::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Bars();;
    };
    return aninstance;;
}

 Toke_Bars::Toke_Bars() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Bars::Toke_Bars(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Bars::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Bars::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Bars(s,s->length());
}

const std::regex Toke_BooleanOp::rgx = regex("==|!=|<(?!=)|<=|>(?!=)|>=|and|or|xor");
Toke_BooleanOp * Toke_BooleanOp::aninstance = nullptr;
Toke_BooleanOp * Toke_BooleanOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_BooleanOp();;
    };
    return aninstance;;
}

 Toke_BooleanOp::Toke_BooleanOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_BooleanOp::Toke_BooleanOp(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_BooleanOp::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_BooleanOp(s,s->length());
}

const std::regex Toke_CondE::rgx = regex("[?][}]");
Toke_CondE * Toke_CondE::aninstance = nullptr;
Toke_CondE * Toke_CondE::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_CondE();;
    };
    return aninstance;;
}

 Toke_CondE::Toke_CondE() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_CondE::Toke_CondE(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_CondE::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_CondE(s,s->length());
}

const std::regex Toke_Fine::rgx = regex("fine");
Toke_Fine * Toke_Fine::aninstance = nullptr;
Toke_Fine * Toke_Fine::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Fine();;
    };
    return aninstance;;
}

 Toke_Fine::Toke_Fine() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Fine::Toke_Fine(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Fine::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Fine(s,s->length());
}

const std::regex Toke_AlCoda::rgx = regex("al(la)? coda");
Toke_AlCoda * Toke_AlCoda::aninstance = nullptr;
Toke_AlCoda * Toke_AlCoda::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AlCoda();;
    };
    return aninstance;;
}

 Toke_AlCoda::Toke_AlCoda() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AlCoda::Toke_AlCoda(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AlCoda::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlCoda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_AlCoda(s,s->length());
}

const std::regex Toke_QuindicesimaA::rgx = regex("15ma|alla quindicesima");
Toke_QuindicesimaA * Toke_QuindicesimaA::aninstance = nullptr;
Toke_QuindicesimaA * Toke_QuindicesimaA::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_QuindicesimaA();;
    };
    return aninstance;;
}

 Toke_QuindicesimaA::Toke_QuindicesimaA() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_QuindicesimaA::Toke_QuindicesimaA(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_QuindicesimaA::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_QuindicesimaA(s,s->length());
}

const std::regex Toke_Fairy::rgx = regex("[$]");
Toke_Fairy * Toke_Fairy::aninstance = nullptr;
Toke_Fairy * Toke_Fairy::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Fairy();;
    };
    return aninstance;;
}

 Toke_Fairy::Toke_Fairy() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Fairy::Toke_Fairy(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Fairy::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fairy::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Fairy(s,s->length());
}

const std::regex Toke_SkoarpionStart::rgx = regex("[{]!");
Toke_SkoarpionStart * Toke_SkoarpionStart::aninstance = nullptr;
Toke_SkoarpionStart * Toke_SkoarpionStart::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_SkoarpionStart();;
    };
    return aninstance;;
}

 Toke_SkoarpionStart::Toke_SkoarpionStart() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_SkoarpionStart::Toke_SkoarpionStart(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_SkoarpionStart::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStart::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_SkoarpionStart(s,s->length());
}

const std::regex Toke_Freq::rgx = regex("(0|[1-9][0-9]*)(\\.[0-9]+)?Hz");
Toke_Freq * Toke_Freq::aninstance = nullptr;
Toke_Freq * Toke_Freq::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Freq();;
    };
    return aninstance;;
}

 Toke_Freq::Toke_Freq() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Freq::Toke_Freq(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Freq::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Freq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Freq(s,s->length());
}

const std::regex Toke_DynPiano::rgx = regex("(mp|p+)(iano)?");
Toke_DynPiano * Toke_DynPiano::aninstance = nullptr;
Toke_DynPiano * Toke_DynPiano::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_DynPiano();;
    };
    return aninstance;;
}

 Toke_DynPiano::Toke_DynPiano() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_DynPiano::Toke_DynPiano(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_DynPiano::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynPiano::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_DynPiano(s,s->length());
}

const std::regex Toke_Meter::rgx = regex("[1-9][0-9]*/[1-9][0-9]*");
Toke_Meter * Toke_Meter::aninstance = nullptr;
Toke_Meter * Toke_Meter::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Meter();;
    };
    return aninstance;;
}

 Toke_Meter::Toke_Meter() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Meter::Toke_Meter(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Meter::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Meter::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Meter(s,s->length());
}

const std::regex Toke_AssOp::rgx = regex("=>|[+]>|->");
Toke_AssOp * Toke_AssOp::aninstance = nullptr;
Toke_AssOp * Toke_AssOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_AssOp();;
    };
    return aninstance;;
}

 Toke_AssOp::Toke_AssOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_AssOp::Toke_AssOp(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_AssOp::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AssOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_AssOp(s,s->length());
}

const std::regex Toke_CondS::rgx = regex("[{][?][\\n]*");
Toke_CondS * Toke_CondS::aninstance = nullptr;
Toke_CondS * Toke_CondS::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_CondS();;
    };
    return aninstance;;
}

 Toke_CondS::Toke_CondS() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_CondS::Toke_CondS(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_CondS::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_CondS(s,s->length());
}

const std::regex Toke_LoopS::rgx = regex("[{]:[\\n]*");
Toke_LoopS * Toke_LoopS::aninstance = nullptr;
Toke_LoopS * Toke_LoopS::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LoopS();;
    };
    return aninstance;;
}

 Toke_LoopS::Toke_LoopS() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LoopS::Toke_LoopS(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LoopS::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_LoopS(s,s->length());
}

const std::regex Toke_PedalUp::rgx = regex("[*](?!>)");
Toke_PedalUp * Toke_PedalUp::aninstance = nullptr;
Toke_PedalUp * Toke_PedalUp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_PedalUp();;
    };
    return aninstance;;
}

 Toke_PedalUp::Toke_PedalUp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_PedalUp::Toke_PedalUp(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_PedalUp::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalUp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_PedalUp(s,s->length());
}

const std::regex Toke_LWing::rgx = regex("\\^\\^[(]");
Toke_LWing * Toke_LWing::aninstance = nullptr;
Toke_LWing * Toke_LWing::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LWing();;
    };
    return aninstance;;
}

 Toke_LWing::Toke_LWing() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LWing::Toke_LWing(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LWing::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_LWing(s,s->length());
}

const std::regex Toke_LoopE::rgx = regex(":[}]");
Toke_LoopE * Toke_LoopE::aninstance = nullptr;
Toke_LoopE * Toke_LoopE::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LoopE();;
    };
    return aninstance;;
}

 Toke_LoopE::Toke_LoopE() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LoopE::Toke_LoopE(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LoopE::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_LoopE(s,s->length());
}

const std::regex Toke_LoopSep::rgx = regex("::[\\n]*(?![|])");
Toke_LoopSep * Toke_LoopSep::aninstance = nullptr;
Toke_LoopSep * Toke_LoopSep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_LoopSep();;
    };
    return aninstance;;
}

 Toke_LoopSep::Toke_LoopSep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_LoopSep::Toke_LoopSep(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_LoopSep::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_LoopSep(s,s->length());
}

const std::regex Toke_NamedNoat::rgx = regex("(?:_?)(?:[a-eg]|f(?![ac-zA-Z_]))(#*|b*)");
Toke_NamedNoat * Toke_NamedNoat::aninstance = nullptr;
Toke_NamedNoat * Toke_NamedNoat::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_NamedNoat();;
    };
    return aninstance;;
}

 Toke_NamedNoat::Toke_NamedNoat() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_NamedNoat::Toke_NamedNoat(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_NamedNoat::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_NamedNoat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_NamedNoat(s,s->length());
}

const std::regex Toke_MathOp::rgx = regex("[+x\\-](?!>)");
Toke_MathOp * Toke_MathOp::aninstance = nullptr;
Toke_MathOp * Toke_MathOp::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MathOp();;
    };
    return aninstance;;
}

 Toke_MathOp::Toke_MathOp() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MathOp::Toke_MathOp(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MathOp::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_MathOp(s,s->length());
}

const std::regex Toke_ListE::rgx = regex(">");
Toke_ListE * Toke_ListE::aninstance = nullptr;
Toke_ListE * Toke_ListE::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_ListE();;
    };
    return aninstance;;
}

 Toke_ListE::Toke_ListE() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_ListE::Toke_ListE(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_ListE::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_ListE(s,s->length());
}

const std::regex Toke_MsgNameWithArgs::rgx = regex("[a-zA-Z_][a-zA-Z0-9_]*<");
Toke_MsgNameWithArgs * Toke_MsgNameWithArgs::aninstance = nullptr;
Toke_MsgNameWithArgs * Toke_MsgNameWithArgs::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_MsgNameWithArgs();;
    };
    return aninstance;;
}

 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_MsgNameWithArgs::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgNameWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_MsgNameWithArgs(s,s->length());
}

const std::regex Toke_Voice::rgx = regex("\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)");
Toke_Voice * Toke_Voice::aninstance = nullptr;
Toke_Voice * Toke_Voice::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Voice();;
    };
    return aninstance;;
}

 Toke_Voice::Toke_Voice() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Voice::Toke_Voice(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Voice::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Voice::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Voice(s,s->length());
}

const std::regex Toke_Deref::rgx = regex("!(?![!}]|=)");
Toke_Deref * Toke_Deref::aninstance = nullptr;
Toke_Deref * Toke_Deref::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Deref();;
    };
    return aninstance;;
}

 Toke_Deref::Toke_Deref() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Deref::Toke_Deref(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Deref::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Deref::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Deref(s,s->length());
}

const std::regex Toke_Carrot::rgx = regex("\\^(?!\\^[(])");
Toke_Carrot * Toke_Carrot::aninstance = nullptr;
Toke_Carrot * Toke_Carrot::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Carrot();;
    };
    return aninstance;;
}

 Toke_Carrot::Toke_Carrot() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Carrot::Toke_Carrot(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Carrot::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Carrot::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Carrot(s,s->length());
}

const std::regex Toke_ListSep::rgx = regex(",");
Toke_ListSep * Toke_ListSep::aninstance = nullptr;
Toke_ListSep * Toke_ListSep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_ListSep();;
    };
    return aninstance;;
}

 Toke_ListSep::Toke_ListSep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_ListSep::Toke_ListSep(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_ListSep::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_ListSep(s,s->length());
}

const std::regex Toke_PedalDown::rgx = regex("Ped\\.?");
Toke_PedalDown * Toke_PedalDown::aninstance = nullptr;
Toke_PedalDown * Toke_PedalDown::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_PedalDown();;
    };
    return aninstance;;
}

 Toke_PedalDown::Toke_PedalDown() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_PedalDown::Toke_PedalDown(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_PedalDown::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_PedalDown::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_PedalDown(s,s->length());
}

const std::regex Toke_Rep::rgx = regex("%+");
Toke_Rep * Toke_Rep::aninstance = nullptr;
Toke_Rep * Toke_Rep::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_Rep();;
    };
    return aninstance;;
}

 Toke_Rep::Toke_Rep() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_Rep::Toke_Rep(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_Rep::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Rep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_Rep(s,s->length());
}

const std::regex Toke_CondIf::rgx = regex("[?][?](?![}])");
Toke_CondIf * Toke_CondIf::aninstance = nullptr;
Toke_CondIf * Toke_CondIf::instance() {
    if (aninstance == nullptr) {;
        aninstance = new Toke_CondIf();;
    };
    return aninstance;;
}

 Toke_CondIf::Toke_CondIf() {
    this->lexeme = nullptr;
    this->size = 0;
}

 Toke_CondIf::Toke_CondIf(string * s, size_t n) {
    this->lexeme = s;
    this->size = n;
}

SkoarToke* Toke_CondIf::match_toke(string * buf, size_t offs) {
    smatch matches;
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondIf::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    string *s = new string(matches[0]);
    return new Toke_CondIf(s,s->length());
}

