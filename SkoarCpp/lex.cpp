// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2017-03-30 11:19:23 for C++14
// ======================================================================
#include "lex.hpp"
#include "exception.hpp"
#include "memories.hpp"

static wsmatch matches;
// ------------------
// Abstract SkoarToke
// ------------------
 SkoarToke::SkoarToke() {
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
}

 SkoarToke::SkoarToke(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    kind = ESkoarToke::Unknown;
    style = SkoarStyles::EStyle::nostyle;
}

 SkoarToke::~SkoarToke() {
}

// how many characters to burn from the buffer
size_t SkoarToke::burn() {
    return size;
}

// --------------
// Eof is special
// --------------
 Toke_Eof::Toke_Eof() {
    kind = ESkoarToke::Eof;

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Eof");
#endif
}

 Toke_Eof::~Toke_Eof() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Eof");
#endif
}

size_t Toke_Eof::burn(wstring * buf, size_t offs) {
    if (buf->size() > offs) {
        throw SkoarError(L"Tried to burn Eof when there's more input.");
    }

    return 0;
}

SkoarToke* Toke_Eof::match_toke(wstring * buf, size_t offs) {
    if (buf->size() == offs) {
        return new Toke_Eof();
    }

    return nullptr;
}

// ---------------------
// Whitespace is special
// ---------------------
const wregex Toke_Whitespace::rgx = wregex(L"[ \\t]*");

size_t Toke_Whitespace::burn(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Whitespace::rgx, regex_constants::match_continuous);
    if (!found) {
        return 0;
    }

    return matches[0].length();
}

// --------------
// Everyday Tokes
// --------------
const std::wregex Toke_AUGen::rgx = wregex(L"a[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)");
 Toke_AUGen::Toke_AUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AUGen>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"AUGen");
#endif
}

 Toke_AUGen::~Toke_AUGen() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"AUGen");
#endif
}

SkoarToke* Toke_AUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AUGen(s, offs, s.length());
}

const std::wregex Toke_AUGenWithArgs::rgx = wregex(L"a[A-Z][a-zA-Z0-9_]*<");
 Toke_AUGenWithArgs::Toke_AUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AUGenWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"AUGenWithArgs");
#endif
}

 Toke_AUGenWithArgs::~Toke_AUGenWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"AUGenWithArgs");
#endif
}

SkoarToke* Toke_AUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_AlCoda::rgx = wregex(L"al(la)? coda");
 Toke_AlCoda::Toke_AlCoda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlCoda;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AlCoda>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"AlCoda");
#endif
}

 Toke_AlCoda::~Toke_AlCoda() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"AlCoda");
#endif
}

SkoarToke* Toke_AlCoda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlCoda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlCoda(s, offs, s.length());
}

const std::wregex Toke_AlFine::rgx = wregex(L"al fine");
 Toke_AlFine::Toke_AlFine(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlFine;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AlFine>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"AlFine");
#endif
}

 Toke_AlFine::~Toke_AlFine() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"AlFine");
#endif
}

SkoarToke* Toke_AlFine::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlFine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlFine(s, offs, s.length());
}

const std::wregex Toke_AlSegno::rgx = wregex(L"al segno");
 Toke_AlSegno::Toke_AlSegno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AlSegno;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AlSegno>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"AlSegno");
#endif
}

 Toke_AlSegno::~Toke_AlSegno() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"AlSegno");
#endif
}

SkoarToke* Toke_AlSegno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AlSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AlSegno(s, offs, s.length());
}

const std::wregex Toke_AssOp::rgx = wregex(L"=>|[+]>|->|[*]>");
 Toke_AssOp::Toke_AssOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::AssOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::AssOp>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"AssOp");
#endif
}

 Toke_AssOp::~Toke_AssOp() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"AssOp");
#endif
}

SkoarToke* Toke_AssOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_AssOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_AssOp(s, offs, s.length());
}

const std::wregex Toke_Bars::rgx = wregex(L":?\\|+:?");
 Toke_Bars::Toke_Bars(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Bars;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Bars>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Bars");
#endif
}

 Toke_Bars::~Toke_Bars() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Bars");
#endif
}

SkoarToke* Toke_Bars::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Bars::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Bars(s, offs, s.length());
}

const std::wregex Toke_BooleanOp::rgx = wregex(L"==|!=|<=|>=|and|or|xor");
 Toke_BooleanOp::Toke_BooleanOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::BooleanOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::BooleanOp>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"BooleanOp");
#endif
}

 Toke_BooleanOp::~Toke_BooleanOp() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"BooleanOp");
#endif
}

SkoarToke* Toke_BooleanOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_BooleanOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_BooleanOp(s, offs, s.length());
}

const std::wregex Toke_Carrot::rgx = wregex(L"\\^(?!\\^[(])");
 Toke_Carrot::Toke_Carrot(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Carrot;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Carrot>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Carrot");
#endif
}

 Toke_Carrot::~Toke_Carrot() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Carrot");
#endif
}

SkoarToke* Toke_Carrot::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Carrot::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Carrot(s, offs, s.length());
}

const std::wregex Toke_Cat::rgx = wregex(L"=\\^\\.\\^=");
 Toke_Cat::Toke_Cat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Cat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Cat>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Cat");
#endif
}

 Toke_Cat::~Toke_Cat() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Cat");
#endif
}

SkoarToke* Toke_Cat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Cat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Cat(s, offs, s.length());
}

const std::wregex Toke_Choard::rgx = wregex(L"~*[ABCDEFG](?![.ce-ln-rt-zA-LN-Z]|a[l ])(#|b)?([Mm0-9]|sus|dim|aug|dom)*~*");
 Toke_Choard::Toke_Choard(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Choard;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Choard>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Choard");
#endif
}

 Toke_Choard::~Toke_Choard() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Choard");
#endif
}

SkoarToke* Toke_Choard::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Choard::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Choard(s, offs, s.length());
}

const std::wregex Toke_Coda::rgx = wregex(L"\\([+]\\)(?:`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*)?");
 Toke_Coda::Toke_Coda(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Coda;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Coda>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Coda");
#endif
}

 Toke_Coda::~Toke_Coda() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Coda");
#endif
}

SkoarToke* Toke_Coda::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Coda::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Coda(s, offs, s.length());
}

const std::wregex Toke_Comment::rgx = wregex(L"<[?](.|[\\n\\r])*?[?]>");
 Toke_Comment::Toke_Comment(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Comment;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Comment>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Comment");
#endif
}

 Toke_Comment::~Toke_Comment() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Comment");
#endif
}

SkoarToke* Toke_Comment::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Comment::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Comment(s, offs, s.length());
}

const std::wregex Toke_CondE::rgx = wregex(L"[?][}]");
 Toke_CondE::Toke_CondE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"CondE");
#endif
}

 Toke_CondE::~Toke_CondE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"CondE");
#endif
}

SkoarToke* Toke_CondE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondE(s, offs, s.length());
}

const std::wregex Toke_CondIf::rgx = wregex(L"[?][?](?![}])");
 Toke_CondIf::Toke_CondIf(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondIf;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondIf>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"CondIf");
#endif
}

 Toke_CondIf::~Toke_CondIf() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"CondIf");
#endif
}

SkoarToke* Toke_CondIf::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondIf::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondIf(s, offs, s.length());
}

const std::wregex Toke_CondS::rgx = wregex(L"[{][?][\\n]*");
 Toke_CondS::Toke_CondS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::CondS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::CondS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"CondS");
#endif
}

 Toke_CondS::~Toke_CondS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"CondS");
#endif
}

SkoarToke* Toke_CondS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_CondS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_CondS(s, offs, s.length());
}

const std::wregex Toke_Crotchets::rgx = wregex(L"[}]+\\.?");
 Toke_Crotchets::Toke_Crotchets(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Crotchets;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Crotchets>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Crotchets");
#endif
}

 Toke_Crotchets::~Toke_Crotchets() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Crotchets");
#endif
}

SkoarToke* Toke_Crotchets::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Crotchets::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Crotchets(s, offs, s.length());
}

const std::wregex Toke_DUGen::rgx = wregex(L"d[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)");
 Toke_DUGen::Toke_DUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DUGen>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DUGen");
#endif
}

 Toke_DUGen::~Toke_DUGen() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DUGen");
#endif
}

SkoarToke* Toke_DUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DUGen(s, offs, s.length());
}

const std::wregex Toke_DUGenWithArgs::rgx = wregex(L"d[A-Z][a-zA-Z0-9_]*<");
 Toke_DUGenWithArgs::Toke_DUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DUGenWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DUGenWithArgs");
#endif
}

 Toke_DUGenWithArgs::~Toke_DUGenWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DUGenWithArgs");
#endif
}

SkoarToke* Toke_DUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_DaCapo::rgx = wregex(L"D\\.C\\.|Da Capo");
 Toke_DaCapo::Toke_DaCapo(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DaCapo;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DaCapo>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DaCapo");
#endif
}

 Toke_DaCapo::~Toke_DaCapo() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DaCapo");
#endif
}

SkoarToke* Toke_DaCapo::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DaCapo::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DaCapo(s, offs, s.length());
}

const std::wregex Toke_DalSegno::rgx = wregex(L"D\\.S\\.|Dal Segno");
 Toke_DalSegno::Toke_DalSegno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DalSegno;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DalSegno>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DalSegno");
#endif
}

 Toke_DalSegno::~Toke_DalSegno() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DalSegno");
#endif
}

SkoarToke* Toke_DalSegno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DalSegno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DalSegno(s, offs, s.length());
}

const std::wregex Toke_Deref::rgx = wregex(L"!(?![!}]|=)");
 Toke_Deref::Toke_Deref(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Deref;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Deref>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Deref");
#endif
}

 Toke_Deref::~Toke_Deref() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Deref");
#endif
}

SkoarToke* Toke_Deref::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Deref::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Deref(s, offs, s.length());
}

const std::wregex Toke_Duration::rgx = wregex(L"[0-9]+:[0-9]+(\\.[0-9]+)?");
 Toke_Duration::Toke_Duration(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Duration;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Duration>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Duration");
#endif
}

 Toke_Duration::~Toke_Duration() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Duration");
#endif
}

SkoarToke* Toke_Duration::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Duration::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Duration(s, offs, s.length());
}

const std::wregex Toke_DynFP::rgx = wregex(L"fp(?![a-oq-zA-Z0-9_])");
 Toke_DynFP::Toke_DynFP(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynFP;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynFP>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DynFP");
#endif
}

 Toke_DynFP::~Toke_DynFP() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DynFP");
#endif
}

SkoarToke* Toke_DynFP::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynFP::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynFP(s, offs, s.length());
}

const std::wregex Toke_DynForte::rgx = wregex(L"m(ezzo)?f(orte)?|f+orte|ff+(?![a-oq-zA-Z0-9_])");
 Toke_DynForte::Toke_DynForte(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynForte;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynForte>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DynForte");
#endif
}

 Toke_DynForte::~Toke_DynForte() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DynForte");
#endif
}

SkoarToke* Toke_DynForte::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynForte::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynForte(s, offs, s.length());
}

const std::wregex Toke_DynPiano::rgx = wregex(L"(m(ezzo)?p|p+)(iano)?(?![a-oq-zA-Z0-9_])");
 Toke_DynPiano::Toke_DynPiano(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynPiano;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynPiano>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DynPiano");
#endif
}

 Toke_DynPiano::~Toke_DynPiano() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DynPiano");
#endif
}

SkoarToke* Toke_DynPiano::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynPiano::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynPiano(s, offs, s.length());
}

const std::wregex Toke_DynSFZ::rgx = wregex(L"sfz(?![a-oq-zA-Z0-9_])");
 Toke_DynSFZ::Toke_DynSFZ(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::DynSFZ;
    this->style = SkoarStyles::Toke::style<ESkoarToke::DynSFZ>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"DynSFZ");
#endif
}

 Toke_DynSFZ::~Toke_DynSFZ() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"DynSFZ");
#endif
}

SkoarToke* Toke_DynSFZ::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_DynSFZ::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_DynSFZ(s, offs, s.length());
}

const std::wregex Toke_Eighths::rgx = wregex(L"\\.?\\]+(?:__?)?\\.?");
 Toke_Eighths::Toke_Eighths(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Eighths;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Eighths>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Eighths");
#endif
}

 Toke_Eighths::~Toke_Eighths() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Eighths");
#endif
}

SkoarToke* Toke_Eighths::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Eighths::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Eighths(s, offs, s.length());
}

const std::wregex Toke_ExactBeat::rgx = wregex(L"[(](?![+])");
 Toke_ExactBeat::Toke_ExactBeat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExactBeat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExactBeat>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"ExactBeat");
#endif
}

 Toke_ExactBeat::~Toke_ExactBeat() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"ExactBeat");
#endif
}

SkoarToke* Toke_ExactBeat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExactBeat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExactBeat(s, offs, s.length());
}

const std::wregex Toke_ExactRest::rgx = wregex(L"[{](?![=?:!])");
 Toke_ExactRest::Toke_ExactRest(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ExactRest;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ExactRest>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"ExactRest");
#endif
}

 Toke_ExactRest::~Toke_ExactRest() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"ExactRest");
#endif
}

SkoarToke* Toke_ExactRest::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ExactRest::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ExactRest(s, offs, s.length());
}

const std::wregex Toke_Fairy::rgx = wregex(L"[$]");
 Toke_Fairy::Toke_Fairy(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fairy;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Fairy>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Fairy");
#endif
}

 Toke_Fairy::~Toke_Fairy() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Fairy");
#endif
}

SkoarToke* Toke_Fairy::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fairy::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Fairy(s, offs, s.length());
}

const std::wregex Toke_False::rgx = wregex(L"no|false");
 Toke_False::Toke_False(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::False;
    this->style = SkoarStyles::Toke::style<ESkoarToke::False>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"False");
#endif
}

 Toke_False::~Toke_False() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"False");
#endif
}

SkoarToke* Toke_False::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_False::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_False(s, offs, s.length());
}

const std::wregex Toke_Fine::rgx = wregex(L"fine");
 Toke_Fine::Toke_Fine(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Fine;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Fine>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Fine");
#endif
}

 Toke_Fine::~Toke_Fine() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Fine");
#endif
}

SkoarToke* Toke_Fine::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Fine::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Fine(s, offs, s.length());
}

const std::wregex Toke_Float::rgx = wregex(L"(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz|:[0-9])");
 Toke_Float::Toke_Float(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Float;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Float>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Float");
#endif
}

 Toke_Float::~Toke_Float() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Float");
#endif
}

SkoarToke* Toke_Float::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Float::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Float(s, offs, s.length());
}

const std::wregex Toke_Freq::rgx = wregex(L"(0|[1-9][0-9]*)(\\.[0-9]+)?Hz");
 Toke_Freq::Toke_Freq(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Freq;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Freq>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Freq");
#endif
}

 Toke_Freq::~Toke_Freq() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Freq");
#endif
}

SkoarToke* Toke_Freq::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Freq::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Freq(s, offs, s.length());
}

const std::wregex Toke_HashLevel::rgx = wregex(L"\\[#*[ ]*\\]");
 Toke_HashLevel::Toke_HashLevel(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::HashLevel;
    this->style = SkoarStyles::Toke::style<ESkoarToke::HashLevel>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"HashLevel");
#endif
}

 Toke_HashLevel::~Toke_HashLevel() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"HashLevel");
#endif
}

SkoarToke* Toke_HashLevel::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_HashLevel::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_HashLevel(s, offs, s.length());
}

const std::wregex Toke_Int::rgx = wregex(L"(-)?(0|[1-9][0-9]*)(?![0-9]*Hz|[mv][ab]|\\.[0-9]|:[0-9])");
 Toke_Int::Toke_Int(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Int;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Int>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Int");
#endif
}

 Toke_Int::~Toke_Int() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Int");
#endif
}

SkoarToke* Toke_Int::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Int::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Int(s, offs, s.length());
}

const std::wregex Toke_KUGen::rgx = wregex(L"k[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)");
 Toke_KUGen::Toke_KUGen(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::KUGen;
    this->style = SkoarStyles::Toke::style<ESkoarToke::KUGen>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"KUGen");
#endif
}

 Toke_KUGen::~Toke_KUGen() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"KUGen");
#endif
}

SkoarToke* Toke_KUGen::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_KUGen::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_KUGen(s, offs, s.length());
}

const std::wregex Toke_KUGenWithArgs::rgx = wregex(L"k[A-Z][a-zA-Z0-9_]*<");
 Toke_KUGenWithArgs::Toke_KUGenWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::KUGenWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::KUGenWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"KUGenWithArgs");
#endif
}

 Toke_KUGenWithArgs::~Toke_KUGenWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"KUGenWithArgs");
#endif
}

SkoarToke* Toke_KUGenWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_KUGenWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_KUGenWithArgs(s, offs, s.length());
}

const std::wregex Toke_LWing::rgx = wregex(L"\\^\\^[(]");
 Toke_LWing::Toke_LWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LWing;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LWing>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"LWing");
#endif
}

 Toke_LWing::~Toke_LWing() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"LWing");
#endif
}

SkoarToke* Toke_LWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LWing(s, offs, s.length());
}

const std::wregex Toke_ListE::rgx = wregex(L">(?![=])");
 Toke_ListE::Toke_ListE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"ListE");
#endif
}

 Toke_ListE::~Toke_ListE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"ListE");
#endif
}

SkoarToke* Toke_ListE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListE(s, offs, s.length());
}

const std::wregex Toke_ListS::rgx = wregex(L"<(?![=?])|<(?=[=]\\^\\.)");
 Toke_ListS::Toke_ListS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"ListS");
#endif
}

 Toke_ListS::~Toke_ListS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"ListS");
#endif
}

SkoarToke* Toke_ListS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListS(s, offs, s.length());
}

const std::wregex Toke_ListSep::rgx = wregex(L",");
 Toke_ListSep::Toke_ListSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::ListSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::ListSep>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"ListSep");
#endif
}

 Toke_ListSep::~Toke_ListSep() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"ListSep");
#endif
}

SkoarToke* Toke_ListSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_ListSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_ListSep(s, offs, s.length());
}

const std::wregex Toke_Loco::rgx = wregex(L"loco");
 Toke_Loco::Toke_Loco(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Loco;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Loco>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Loco");
#endif
}

 Toke_Loco::~Toke_Loco() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Loco");
#endif
}

SkoarToke* Toke_Loco::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Loco::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Loco(s, offs, s.length());
}

const std::wregex Toke_LoopE::rgx = wregex(L":[}]");
 Toke_LoopE::Toke_LoopE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"LoopE");
#endif
}

 Toke_LoopE::~Toke_LoopE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"LoopE");
#endif
}

SkoarToke* Toke_LoopE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopE(s, offs, s.length());
}

const std::wregex Toke_LoopS::rgx = wregex(L"[{]:[\\n]*");
 Toke_LoopS::Toke_LoopS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"LoopS");
#endif
}

 Toke_LoopS::~Toke_LoopS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"LoopS");
#endif
}

SkoarToke* Toke_LoopS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopS(s, offs, s.length());
}

const std::wregex Toke_LoopSep::rgx = wregex(L"::[\\n]*(?![|])");
 Toke_LoopSep::Toke_LoopSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LoopSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LoopSep>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"LoopSep");
#endif
}

 Toke_LoopSep::~Toke_LoopSep() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"LoopSep");
#endif
}

SkoarToke* Toke_LoopSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LoopSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LoopSep(s, offs, s.length());
}

const std::wregex Toke_Lute::rgx = wregex(L"&(?!<)");
 Toke_Lute::Toke_Lute(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Lute;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Lute>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Lute");
#endif
}

 Toke_Lute::~Toke_Lute() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Lute");
#endif
}

SkoarToke* Toke_Lute::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Lute::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Lute(s, offs, s.length());
}

const std::wregex Toke_LuteWithArgs::rgx = wregex(L"&<");
 Toke_LuteWithArgs::Toke_LuteWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::LuteWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::LuteWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"LuteWithArgs");
#endif
}

 Toke_LuteWithArgs::~Toke_LuteWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"LuteWithArgs");
#endif
}

SkoarToke* Toke_LuteWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_LuteWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_LuteWithArgs(s, offs, s.length());
}

const std::wregex Toke_MathOp::rgx = wregex(L"[+*\\-/%](?!>)");
 Toke_MathOp::Toke_MathOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MathOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MathOp>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"MathOp");
#endif
}

 Toke_MathOp::~Toke_MathOp() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"MathOp");
#endif
}

SkoarToke* Toke_MathOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MathOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MathOp(s, offs, s.length());
}

const std::wregex Toke_MeditationE::rgx = wregex(L"=[}]");
 Toke_MeditationE::Toke_MeditationE(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MeditationE;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MeditationE>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"MeditationE");
#endif
}

 Toke_MeditationE::~Toke_MeditationE() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"MeditationE");
#endif
}

SkoarToke* Toke_MeditationE::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MeditationE::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MeditationE(s, offs, s.length());
}

const std::wregex Toke_MeditationS::rgx = wregex(L"[{]=[\\n]*");
 Toke_MeditationS::Toke_MeditationS(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MeditationS;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MeditationS>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"MeditationS");
#endif
}

 Toke_MeditationS::~Toke_MeditationS() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"MeditationS");
#endif
}

SkoarToke* Toke_MeditationS::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MeditationS::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MeditationS(s, offs, s.length());
}

const std::wregex Toke_MsgName::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*(?!<)");
 Toke_MsgName::Toke_MsgName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgName;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgName>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"MsgName");
#endif
}

 Toke_MsgName::~Toke_MsgName() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"MsgName");
#endif
}

SkoarToke* Toke_MsgName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgName(s, offs, s.length());
}

const std::wregex Toke_MsgNameWithArgs::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*<");
 Toke_MsgNameWithArgs::Toke_MsgNameWithArgs(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgNameWithArgs;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgNameWithArgs>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"MsgNameWithArgs");
#endif
}

 Toke_MsgNameWithArgs::~Toke_MsgNameWithArgs() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"MsgNameWithArgs");
#endif
}

SkoarToke* Toke_MsgNameWithArgs::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgNameWithArgs::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgNameWithArgs(s, offs, s.length());
}

const std::wregex Toke_MsgOp::rgx = wregex(L"\\.(?![)\\]])");
 Toke_MsgOp::Toke_MsgOp(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::MsgOp;
    this->style = SkoarStyles::Toke::style<ESkoarToke::MsgOp>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"MsgOp");
#endif
}

 Toke_MsgOp::~Toke_MsgOp() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"MsgOp");
#endif
}

SkoarToke* Toke_MsgOp::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_MsgOp::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_MsgOp(s, offs, s.length());
}

const std::wregex Toke_NamedNoat::rgx = wregex(L"(?:_?)(?:[a-g](?![ac-zA-Z_]))(#|b)?(?![ \\t]*:(?![}:|]))");
 Toke_NamedNoat::Toke_NamedNoat(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::NamedNoat;
    this->style = SkoarStyles::Toke::style<ESkoarToke::NamedNoat>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"NamedNoat");
#endif
}

 Toke_NamedNoat::~Toke_NamedNoat() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"NamedNoat");
#endif
}

SkoarToke* Toke_NamedNoat::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_NamedNoat::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_NamedNoat(s, offs, s.length());
}

const std::wregex Toke_Newline::rgx = wregex(L"[\\n\\r][\\n\\r \\t]*");
 Toke_Newline::Toke_Newline(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Newline;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Newline>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Newline");
#endif
}

 Toke_Newline::~Toke_Newline() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Newline");
#endif
}

SkoarToke* Toke_Newline::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Newline::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Newline(s, offs, s.length());
}

const std::wregex Toke_Nosey::rgx = wregex(L",");
 Toke_Nosey::Toke_Nosey(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Nosey;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Nosey>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Nosey");
#endif
}

 Toke_Nosey::~Toke_Nosey() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Nosey");
#endif
}

SkoarToke* Toke_Nosey::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Nosey::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Nosey(s, offs, s.length());
}

const std::wregex Toke_OctaveShift::rgx = wregex(L"~+o|o~+");
 Toke_OctaveShift::Toke_OctaveShift(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OctaveShift;
    this->style = SkoarStyles::Toke::style<ESkoarToke::OctaveShift>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"OctaveShift");
#endif
}

 Toke_OctaveShift::~Toke_OctaveShift() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"OctaveShift");
#endif
}

SkoarToke* Toke_OctaveShift::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OctaveShift::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OctaveShift(s, offs, s.length());
}

const std::wregex Toke_OttavaA::rgx = wregex(L"8va|ottava (alta|sopra)|all' ottava");
 Toke_OttavaA::Toke_OttavaA(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaA;
    this->style = SkoarStyles::Toke::style<ESkoarToke::OttavaA>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"OttavaA");
#endif
}

 Toke_OttavaA::~Toke_OttavaA() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"OttavaA");
#endif
}

SkoarToke* Toke_OttavaA::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OttavaA(s, offs, s.length());
}

const std::wregex Toke_OttavaB::rgx = wregex(L"8vb|ottava (bassa|sotto)");
 Toke_OttavaB::Toke_OttavaB(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::OttavaB;
    this->style = SkoarStyles::Toke::style<ESkoarToke::OttavaB>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"OttavaB");
#endif
}

 Toke_OttavaB::~Toke_OttavaB() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"OttavaB");
#endif
}

SkoarToke* Toke_OttavaB::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_OttavaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_OttavaB(s, offs, s.length());
}

const std::wregex Toke_Quarters::rgx = wregex(L"\\.?[)]+(?:__?)?\\.?");
 Toke_Quarters::Toke_Quarters(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quarters;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Quarters>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Quarters");
#endif
}

 Toke_Quarters::~Toke_Quarters() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Quarters");
#endif
}

SkoarToke* Toke_Quarters::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quarters::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quarters(s, offs, s.length());
}

const std::wregex Toke_Quavers::rgx = wregex(L"o+/\\.?");
 Toke_Quavers::Toke_Quavers(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Quavers;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Quavers>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Quavers");
#endif
}

 Toke_Quavers::~Toke_Quavers() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Quavers");
#endif
}

SkoarToke* Toke_Quavers::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Quavers::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Quavers(s, offs, s.length());
}

const std::wregex Toke_QuindicesimaA::rgx = wregex(L"15ma|alla quindicesima");
 Toke_QuindicesimaA::Toke_QuindicesimaA(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaA;
    this->style = SkoarStyles::Toke::style<ESkoarToke::QuindicesimaA>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"QuindicesimaA");
#endif
}

 Toke_QuindicesimaA::~Toke_QuindicesimaA() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"QuindicesimaA");
#endif
}

SkoarToke* Toke_QuindicesimaA::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaA::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_QuindicesimaA(s, offs, s.length());
}

const std::wregex Toke_QuindicesimaB::rgx = wregex(L"15mb");
 Toke_QuindicesimaB::Toke_QuindicesimaB(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::QuindicesimaB;
    this->style = SkoarStyles::Toke::style<ESkoarToke::QuindicesimaB>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"QuindicesimaB");
#endif
}

 Toke_QuindicesimaB::~Toke_QuindicesimaB() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"QuindicesimaB");
#endif
}

SkoarToke* Toke_QuindicesimaB::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_QuindicesimaB::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_QuindicesimaB(s, offs, s.length());
}

const std::wregex Toke_RWing::rgx = wregex(L"[)]\\^\\^");
 Toke_RWing::Toke_RWing(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::RWing;
    this->style = SkoarStyles::Toke::style<ESkoarToke::RWing>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"RWing");
#endif
}

 Toke_RWing::~Toke_RWing() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"RWing");
#endif
}

SkoarToke* Toke_RWing::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_RWing::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_RWing(s, offs, s.length());
}

const std::wregex Toke_Segno::rgx = wregex(L",[Ss](?:egno)?`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*");
 Toke_Segno::Toke_Segno(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Segno;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Segno>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Segno");
#endif
}

 Toke_Segno::~Toke_Segno() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Segno");
#endif
}

SkoarToke* Toke_Segno::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Segno::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Segno(s, offs, s.length());
}

const std::wregex Toke_Semicolon::rgx = wregex(L";");
 Toke_Semicolon::Toke_Semicolon(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Semicolon;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Semicolon>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Semicolon");
#endif
}

 Toke_Semicolon::~Toke_Semicolon() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Semicolon");
#endif
}

SkoarToke* Toke_Semicolon::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Semicolon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Semicolon(s, offs, s.length());
}

const std::wregex Toke_SkoarpionEnd::rgx = wregex(L"![}]");
 Toke_SkoarpionEnd::Toke_SkoarpionEnd(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionEnd;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionEnd>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"SkoarpionEnd");
#endif
}

 Toke_SkoarpionEnd::~Toke_SkoarpionEnd() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"SkoarpionEnd");
#endif
}

SkoarToke* Toke_SkoarpionEnd::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionEnd::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionEnd(s, offs, s.length());
}

const std::wregex Toke_SkoarpionSep::rgx = wregex(L"!!");
 Toke_SkoarpionSep::Toke_SkoarpionSep(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionSep;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionSep>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"SkoarpionSep");
#endif
}

 Toke_SkoarpionSep::~Toke_SkoarpionSep() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"SkoarpionSep");
#endif
}

SkoarToke* Toke_SkoarpionSep::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionSep::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionSep(s, offs, s.length());
}

const std::wregex Toke_SkoarpionStart::rgx = wregex(L"[{]!(?=([^!](?!!!))*![}])");
 Toke_SkoarpionStart::Toke_SkoarpionStart(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionStart;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionStart>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"SkoarpionStart");
#endif
}

 Toke_SkoarpionStart::~Toke_SkoarpionStart() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"SkoarpionStart");
#endif
}

SkoarToke* Toke_SkoarpionStart::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStart::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionStart(s, offs, s.length());
}

const std::wregex Toke_SkoarpionStartWithSig::rgx = wregex(L"[{]!(?=([^!](?!![}]))*!!)");
 Toke_SkoarpionStartWithSig::Toke_SkoarpionStartWithSig(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SkoarpionStartWithSig;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SkoarpionStartWithSig>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"SkoarpionStartWithSig");
#endif
}

 Toke_SkoarpionStartWithSig::~Toke_SkoarpionStartWithSig() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"SkoarpionStartWithSig");
#endif
}

SkoarToke* Toke_SkoarpionStartWithSig::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SkoarpionStartWithSig::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SkoarpionStartWithSig(s, offs, s.length());
}

const std::wregex Toke_String::rgx = wregex(L"'[^']*'");
 Toke_String::Toke_String(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::String;
    this->style = SkoarStyles::Toke::style<ESkoarToke::String>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"String");
#endif
}

 Toke_String::~Toke_String() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"String");
#endif
}

SkoarToke* Toke_String::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_String::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_String(s, offs, s.length());
}

const std::wregex Toke_Symbol::rgx = wregex(L"[\\\\@][a-zA-Z0-9_][a-zA-Z0-9_]*");
 Toke_Symbol::Toke_Symbol(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Symbol;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Symbol>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Symbol");
#endif
}

 Toke_Symbol::~Toke_Symbol() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Symbol");
#endif
}

SkoarToke* Toke_Symbol::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Symbol::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Symbol(s, offs, s.length());
}

const std::wregex Toke_SymbolColon::rgx = wregex(L"[a-zA-Z_][a-zA-Z0-9_]*[ \\t]*:(?![:|}])");
 Toke_SymbolColon::Toke_SymbolColon(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolColon;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SymbolColon>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"SymbolColon");
#endif
}

 Toke_SymbolColon::~Toke_SymbolColon() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"SymbolColon");
#endif
}

SkoarToke* Toke_SymbolColon::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolColon::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SymbolColon(s, offs, s.length());
}

const std::wregex Toke_SymbolName::rgx = wregex(L"[a-zA-Z0-9_][a-zA-Z0-9_]*(?![[a-zA-Z0-9_fi \\t]*:)");
 Toke_SymbolName::Toke_SymbolName(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::SymbolName;
    this->style = SkoarStyles::Toke::style<ESkoarToke::SymbolName>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"SymbolName");
#endif
}

 Toke_SymbolName::~Toke_SymbolName() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"SymbolName");
#endif
}

SkoarToke* Toke_SymbolName::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_SymbolName::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_SymbolName(s, offs, s.length());
}

const std::wregex Toke_Times::rgx = wregex(L"[Tt]imes");
 Toke_Times::Toke_Times(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Times;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Times>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Times");
#endif
}

 Toke_Times::~Toke_Times() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Times");
#endif
}

SkoarToke* Toke_Times::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Times::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Times(s, offs, s.length());
}

const std::wregex Toke_True::rgx = wregex(L"yes|true");
 Toke_True::Toke_True(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::True;
    this->style = SkoarStyles::Toke::style<ESkoarToke::True>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"True");
#endif
}

 Toke_True::~Toke_True() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"True");
#endif
}

SkoarToke* Toke_True::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_True::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_True(s, offs, s.length());
}

const std::wregex Toke_Tuplet::rgx = wregex(L"/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?");
 Toke_Tuplet::Toke_Tuplet(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Tuplet;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Tuplet>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Tuplet");
#endif
}

 Toke_Tuplet::~Toke_Tuplet() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Tuplet");
#endif
}

SkoarToke* Toke_Tuplet::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Tuplet::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Tuplet(s, offs, s.length());
}

const std::wregex Toke_Voice::rgx = wregex(L"\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)");
 Toke_Voice::Toke_Voice(wstring s, size_t offs, size_t n) {
    this->lexeme = s;
    this->offs = offs;
    this->size = n;
    this->kind = ESkoarToke::Voice;
    this->style = SkoarStyles::Toke::style<ESkoarToke::Voice>();

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.allocToke(L"Voice");
#endif
}

 Toke_Voice::~Toke_Voice() {

#if SKOAR_DEBUG_MEMORY
    SkoarMemories.deallocToke(L"Voice");
#endif
}

SkoarToke* Toke_Voice::match_toke(wstring * buf, size_t offs) {
    auto found = std::regex_search(buf->cbegin() + offs, buf->cend(), matches, Toke_Voice::rgx, regex_constants::match_continuous);
    if (!found) {
        return nullptr;
    }

    auto s = wstring(matches.str());
    return new Toke_Voice(s, offs, s.length());
}


   
SkoarDispensary::SkoarDispensary() :
   table({
        { ESkoarToke::AUGen, 
            [](wstring *buf, size_t offs) {
                return Toke_AUGen::match_toke(buf, offs);
            }
        },
        { ESkoarToke::AUGenWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_AUGenWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::AlCoda, 
            [](wstring *buf, size_t offs) {
                return Toke_AlCoda::match_toke(buf, offs);
            }
        },
        { ESkoarToke::AlFine, 
            [](wstring *buf, size_t offs) {
                return Toke_AlFine::match_toke(buf, offs);
            }
        },
        { ESkoarToke::AlSegno, 
            [](wstring *buf, size_t offs) {
                return Toke_AlSegno::match_toke(buf, offs);
            }
        },
        { ESkoarToke::AssOp, 
            [](wstring *buf, size_t offs) {
                return Toke_AssOp::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Bars, 
            [](wstring *buf, size_t offs) {
                return Toke_Bars::match_toke(buf, offs);
            }
        },
        { ESkoarToke::BooleanOp, 
            [](wstring *buf, size_t offs) {
                return Toke_BooleanOp::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Carrot, 
            [](wstring *buf, size_t offs) {
                return Toke_Carrot::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Cat, 
            [](wstring *buf, size_t offs) {
                return Toke_Cat::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Choard, 
            [](wstring *buf, size_t offs) {
                return Toke_Choard::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Coda, 
            [](wstring *buf, size_t offs) {
                return Toke_Coda::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Comment, 
            [](wstring *buf, size_t offs) {
                return Toke_Comment::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CondE, 
            [](wstring *buf, size_t offs) {
                return Toke_CondE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CondIf, 
            [](wstring *buf, size_t offs) {
                return Toke_CondIf::match_toke(buf, offs);
            }
        },
        { ESkoarToke::CondS, 
            [](wstring *buf, size_t offs) {
                return Toke_CondS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Crotchets, 
            [](wstring *buf, size_t offs) {
                return Toke_Crotchets::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DUGen, 
            [](wstring *buf, size_t offs) {
                return Toke_DUGen::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DUGenWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_DUGenWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DaCapo, 
            [](wstring *buf, size_t offs) {
                return Toke_DaCapo::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DalSegno, 
            [](wstring *buf, size_t offs) {
                return Toke_DalSegno::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Deref, 
            [](wstring *buf, size_t offs) {
                return Toke_Deref::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Duration, 
            [](wstring *buf, size_t offs) {
                return Toke_Duration::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DynFP, 
            [](wstring *buf, size_t offs) {
                return Toke_DynFP::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DynForte, 
            [](wstring *buf, size_t offs) {
                return Toke_DynForte::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DynPiano, 
            [](wstring *buf, size_t offs) {
                return Toke_DynPiano::match_toke(buf, offs);
            }
        },
        { ESkoarToke::DynSFZ, 
            [](wstring *buf, size_t offs) {
                return Toke_DynSFZ::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Eighths, 
            [](wstring *buf, size_t offs) {
                return Toke_Eighths::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ExactBeat, 
            [](wstring *buf, size_t offs) {
                return Toke_ExactBeat::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ExactRest, 
            [](wstring *buf, size_t offs) {
                return Toke_ExactRest::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Fairy, 
            [](wstring *buf, size_t offs) {
                return Toke_Fairy::match_toke(buf, offs);
            }
        },
        { ESkoarToke::False, 
            [](wstring *buf, size_t offs) {
                return Toke_False::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Fine, 
            [](wstring *buf, size_t offs) {
                return Toke_Fine::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Float, 
            [](wstring *buf, size_t offs) {
                return Toke_Float::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Freq, 
            [](wstring *buf, size_t offs) {
                return Toke_Freq::match_toke(buf, offs);
            }
        },
        { ESkoarToke::HashLevel, 
            [](wstring *buf, size_t offs) {
                return Toke_HashLevel::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Int, 
            [](wstring *buf, size_t offs) {
                return Toke_Int::match_toke(buf, offs);
            }
        },
        { ESkoarToke::KUGen, 
            [](wstring *buf, size_t offs) {
                return Toke_KUGen::match_toke(buf, offs);
            }
        },
        { ESkoarToke::KUGenWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_KUGenWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LWing, 
            [](wstring *buf, size_t offs) {
                return Toke_LWing::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ListE, 
            [](wstring *buf, size_t offs) {
                return Toke_ListE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ListS, 
            [](wstring *buf, size_t offs) {
                return Toke_ListS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::ListSep, 
            [](wstring *buf, size_t offs) {
                return Toke_ListSep::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Loco, 
            [](wstring *buf, size_t offs) {
                return Toke_Loco::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LoopE, 
            [](wstring *buf, size_t offs) {
                return Toke_LoopE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LoopS, 
            [](wstring *buf, size_t offs) {
                return Toke_LoopS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LoopSep, 
            [](wstring *buf, size_t offs) {
                return Toke_LoopSep::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Lute, 
            [](wstring *buf, size_t offs) {
                return Toke_Lute::match_toke(buf, offs);
            }
        },
        { ESkoarToke::LuteWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_LuteWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MathOp, 
            [](wstring *buf, size_t offs) {
                return Toke_MathOp::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MeditationE, 
            [](wstring *buf, size_t offs) {
                return Toke_MeditationE::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MeditationS, 
            [](wstring *buf, size_t offs) {
                return Toke_MeditationS::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MsgName, 
            [](wstring *buf, size_t offs) {
                return Toke_MsgName::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MsgNameWithArgs, 
            [](wstring *buf, size_t offs) {
                return Toke_MsgNameWithArgs::match_toke(buf, offs);
            }
        },
        { ESkoarToke::MsgOp, 
            [](wstring *buf, size_t offs) {
                return Toke_MsgOp::match_toke(buf, offs);
            }
        },
        { ESkoarToke::NamedNoat, 
            [](wstring *buf, size_t offs) {
                return Toke_NamedNoat::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Newline, 
            [](wstring *buf, size_t offs) {
                return Toke_Newline::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Nosey, 
            [](wstring *buf, size_t offs) {
                return Toke_Nosey::match_toke(buf, offs);
            }
        },
        { ESkoarToke::OctaveShift, 
            [](wstring *buf, size_t offs) {
                return Toke_OctaveShift::match_toke(buf, offs);
            }
        },
        { ESkoarToke::OttavaA, 
            [](wstring *buf, size_t offs) {
                return Toke_OttavaA::match_toke(buf, offs);
            }
        },
        { ESkoarToke::OttavaB, 
            [](wstring *buf, size_t offs) {
                return Toke_OttavaB::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Quarters, 
            [](wstring *buf, size_t offs) {
                return Toke_Quarters::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Quavers, 
            [](wstring *buf, size_t offs) {
                return Toke_Quavers::match_toke(buf, offs);
            }
        },
        { ESkoarToke::QuindicesimaA, 
            [](wstring *buf, size_t offs) {
                return Toke_QuindicesimaA::match_toke(buf, offs);
            }
        },
        { ESkoarToke::QuindicesimaB, 
            [](wstring *buf, size_t offs) {
                return Toke_QuindicesimaB::match_toke(buf, offs);
            }
        },
        { ESkoarToke::RWing, 
            [](wstring *buf, size_t offs) {
                return Toke_RWing::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Segno, 
            [](wstring *buf, size_t offs) {
                return Toke_Segno::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Semicolon, 
            [](wstring *buf, size_t offs) {
                return Toke_Semicolon::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SkoarpionEnd, 
            [](wstring *buf, size_t offs) {
                return Toke_SkoarpionEnd::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SkoarpionSep, 
            [](wstring *buf, size_t offs) {
                return Toke_SkoarpionSep::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SkoarpionStart, 
            [](wstring *buf, size_t offs) {
                return Toke_SkoarpionStart::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SkoarpionStartWithSig, 
            [](wstring *buf, size_t offs) {
                return Toke_SkoarpionStartWithSig::match_toke(buf, offs);
            }
        },
        { ESkoarToke::String, 
            [](wstring *buf, size_t offs) {
                return Toke_String::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Symbol, 
            [](wstring *buf, size_t offs) {
                return Toke_Symbol::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SymbolColon, 
            [](wstring *buf, size_t offs) {
                return Toke_SymbolColon::match_toke(buf, offs);
            }
        },
        { ESkoarToke::SymbolName, 
            [](wstring *buf, size_t offs) {
                return Toke_SymbolName::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Times, 
            [](wstring *buf, size_t offs) {
                return Toke_Times::match_toke(buf, offs);
            }
        },
        { ESkoarToke::True, 
            [](wstring *buf, size_t offs) {
                return Toke_True::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Tuplet, 
            [](wstring *buf, size_t offs) {
                return Toke_Tuplet::match_toke(buf, offs);
            }
        },
        { ESkoarToke::Voice, 
            [](wstring *buf, size_t offs) {
                return Toke_Voice::match_toke(buf, offs);
            }
        }
   })
{
}

SkoarToke* SkoarDispensary::match_toke(ESkoarToke::Kind want, wstring *buf, size_t offs) {
    auto f = table[want];
    if (f) 
        return f(buf, offs);
    return nullptr;
}
