// ======================================================================
// lex.cpp - Generated by Code_Cpp_Lexer on 2015-08-05 18:46:19 for C++14
// ======================================================================
#pragma once
#include "skoarcery.hpp"


namespace ESkoarToke {
enum Kind {
        Unknown = 0,
        Eof,
        Whitespace,
    Float,
    SymbolName,
    BooleanOp,
    Bars,
    Volta,
    Quarters,
    Int,
    Tuplet,
    False,
    AlSegno,
    ListS,
    OttavaB,
    Choard,
    Portamento,
    Loco,
    Slash,
    Caesura,
    LWing,
    Eighths,
    ArgSpec,
    LoopS,
    Deref,
    ListE,
    CondS,
    Meter,
    MathOp,
    String,
    Symbol,
    Crap,
    LoopSep,
    PedalUp,
    Rep,
    SkoarpionStart,
    Semicolon,
    DynForte,
    MsgOp,
    DynSFZ,
    SkoarpionEnd,
    Fairy,
    MsgNameWithArgs,
    DaCapo,
    CondIf,
    DalSegno,
    DynFP,
    Crotchets,
    True,
    ListSep,
    Newline,
    AlFine,
    HashLevel,
    QuindicesimaB,
    DynPiano,
    CondE,
    MsgName,
    Voice,
    OctaveShift,
    OttavaA,
    AlCoda,
    Fine,
    Times,
    Nosey,
    Coda,
    NamedNoat,
    Freq,
    Segno,
    Quavers,
    Comment,
    AssOp,
    PedalDown,
    QuindicesimaA,
    SkoarpionSep,
    Carrot,
    LoopE,
    RWing,

};
};

namespace ESkoarNoad {
enum Kind {
    unknown = 0,
    toke,
    artificial,
    args,
    moar_listy_entries,
    skrp_sig,
    cond_else,
    phrasey,
    listy_entries,
    ottavas,
    cond_ifs_suffix,
    pedally,
    loop_body,
    al_x,
    msgable,
    expr_prime,
    skrp_lines,
    musical_keyword,
    opt_arg_spec,
    dynamic,
    listy_suffix,
    settable,
    loop_condition,
    skrp_moar_lines,
    branch,
    msg,
    math,
    deref_prime,
    skrp_suffix,
    if_body,
    nouny_literal,
    cond_ifs,
    msg_chain_node,
    loop,
    expr,
    nouny,
    cthulhu_prime,
    listy,
    coda,
    optional_voice,
    deref,
    skoarpion,
    conditional,
    cond_if,
    assignment,
    boolean,
    cthulhu,
    beat,
    marker,
    dal_goto,
    phrases,
    optional_al_coda,
    skoar,
    times,
    musical_keyword_misc,
    branches,

};
};
// --------------
// Abstract Token
// --------------
class SkoarToke {
public:
    wstring * lexeme;
    size_t offs;
    size_t size;
    ESkoarToke::Kind kind;

     SkoarToke();
     SkoarToke(wstring * s, size_t offs, size_t n);
    // how many characters to burn from the buffer
    size_t burn();
};

// --------------
// Eof is special
// --------------
class Toke_Eof: public SkoarToke {
public:

     Toke_Eof();
    static     size_t burn(wstring * buf, size_t offs);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

// ---------------------
// Whitespace is special
// ---------------------
class Toke_Whitespace: public SkoarToke {
public:
    static const wregex rgx;

    static     size_t burn(wstring * buf, size_t offs);
};

// --------------
// Everyday Tokes
// --------------
class Toke_Float: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Float(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_SymbolName: public SkoarToke {
public:
    static const wregex rgx;


     Toke_SymbolName(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_BooleanOp: public SkoarToke {
public:
    static const wregex rgx;


     Toke_BooleanOp(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Bars: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Bars(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Volta: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Volta(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Quarters: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Quarters(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Int: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Int(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Tuplet: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Tuplet(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_False: public SkoarToke {
public:
    static const wregex rgx;


     Toke_False(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_AlSegno: public SkoarToke {
public:
    static const wregex rgx;


     Toke_AlSegno(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_ListS: public SkoarToke {
public:
    static const wregex rgx;


     Toke_ListS(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_OttavaB: public SkoarToke {
public:
    static const wregex rgx;


     Toke_OttavaB(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Choard: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Choard(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Portamento: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Portamento(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Loco: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Loco(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Slash: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Slash(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Caesura: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Caesura(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_LWing: public SkoarToke {
public:
    static const wregex rgx;


     Toke_LWing(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Eighths: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Eighths(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_ArgSpec: public SkoarToke {
public:
    static const wregex rgx;


     Toke_ArgSpec(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_LoopS: public SkoarToke {
public:
    static const wregex rgx;


     Toke_LoopS(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Deref: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Deref(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_ListE: public SkoarToke {
public:
    static const wregex rgx;


     Toke_ListE(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_CondS: public SkoarToke {
public:
    static const wregex rgx;


     Toke_CondS(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Meter: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Meter(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_MathOp: public SkoarToke {
public:
    static const wregex rgx;


     Toke_MathOp(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_String: public SkoarToke {
public:
    static const wregex rgx;


     Toke_String(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Symbol: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Symbol(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Crap: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Crap(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_LoopSep: public SkoarToke {
public:
    static const wregex rgx;


     Toke_LoopSep(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_PedalUp: public SkoarToke {
public:
    static const wregex rgx;


     Toke_PedalUp(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Rep: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Rep(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_SkoarpionStart: public SkoarToke {
public:
    static const wregex rgx;


     Toke_SkoarpionStart(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Semicolon: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Semicolon(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_DynForte: public SkoarToke {
public:
    static const wregex rgx;


     Toke_DynForte(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_MsgOp: public SkoarToke {
public:
    static const wregex rgx;


     Toke_MsgOp(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_DynSFZ: public SkoarToke {
public:
    static const wregex rgx;


     Toke_DynSFZ(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_SkoarpionEnd: public SkoarToke {
public:
    static const wregex rgx;


     Toke_SkoarpionEnd(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Fairy: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Fairy(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_MsgNameWithArgs: public SkoarToke {
public:
    static const wregex rgx;


     Toke_MsgNameWithArgs(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_DaCapo: public SkoarToke {
public:
    static const wregex rgx;


     Toke_DaCapo(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_CondIf: public SkoarToke {
public:
    static const wregex rgx;


     Toke_CondIf(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_DalSegno: public SkoarToke {
public:
    static const wregex rgx;


     Toke_DalSegno(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_DynFP: public SkoarToke {
public:
    static const wregex rgx;


     Toke_DynFP(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Crotchets: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Crotchets(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_True: public SkoarToke {
public:
    static const wregex rgx;


     Toke_True(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_ListSep: public SkoarToke {
public:
    static const wregex rgx;


     Toke_ListSep(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Newline: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Newline(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_AlFine: public SkoarToke {
public:
    static const wregex rgx;


     Toke_AlFine(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_HashLevel: public SkoarToke {
public:
    static const wregex rgx;


     Toke_HashLevel(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_QuindicesimaB: public SkoarToke {
public:
    static const wregex rgx;


     Toke_QuindicesimaB(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_DynPiano: public SkoarToke {
public:
    static const wregex rgx;


     Toke_DynPiano(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_CondE: public SkoarToke {
public:
    static const wregex rgx;


     Toke_CondE(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_MsgName: public SkoarToke {
public:
    static const wregex rgx;


     Toke_MsgName(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Voice: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Voice(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_OctaveShift: public SkoarToke {
public:
    static const wregex rgx;


     Toke_OctaveShift(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_OttavaA: public SkoarToke {
public:
    static const wregex rgx;


     Toke_OttavaA(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_AlCoda: public SkoarToke {
public:
    static const wregex rgx;


     Toke_AlCoda(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Fine: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Fine(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Times: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Times(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Nosey: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Nosey(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Coda: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Coda(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_NamedNoat: public SkoarToke {
public:
    static const wregex rgx;


     Toke_NamedNoat(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Freq: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Freq(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Segno: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Segno(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Quavers: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Quavers(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Comment: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Comment(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_AssOp: public SkoarToke {
public:
    static const wregex rgx;


     Toke_AssOp(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_PedalDown: public SkoarToke {
public:
    static const wregex rgx;


     Toke_PedalDown(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_QuindicesimaA: public SkoarToke {
public:
    static const wregex rgx;


     Toke_QuindicesimaA(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_SkoarpionSep: public SkoarToke {
public:
    static const wregex rgx;


     Toke_SkoarpionSep(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_Carrot: public SkoarToke {
public:
    static const wregex rgx;


     Toke_Carrot(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_LoopE: public SkoarToke {
public:
    static const wregex rgx;


     Toke_LoopE(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};

class Toke_RWing: public SkoarToke {
public:
    static const wregex rgx;


     Toke_RWing(wstring * s, size_t offs, size_t n);
    static     SkoarToke* match_toke(wstring * buf, size_t offs);
};


class SkoarDispensary {
    map<ESkoarToke::Kind, function<SkoarToke*(wstring *buf, size_t offs)>> table;
public: 
    SkoarDispensary();   
    SkoarToke *match_toke(ESkoarToke::Kind want, wstring *buf, size_t offs);
};
