// ================================================================================
// lex.sc - Generated by Code_Sc_Lexer on 2016-02-21 17:05:51 for SuperCollider 3.7
// ================================================================================
// --------------
// SkoarException
// --------------
SkoarError : Exception {
    *new {
        | msg |

        ^super.new(msg);
    }

    *errorString {
        ^"SKOAR" ++ super.errorString;
    }

}

// --------------
// Abstract Token
// --------------
SkoarToke {
    var <lexeme;
    var <size;
    var <offs;
    classvar <regex = nil;

    *new {
        | s, o, n |

        ^super.new.init( s, o, n );
    }

    init {
        | s, o, n |

        lexeme = s;
        offs = o;
        size = n;
    }

    // how many characters to burn from the buffer
    burn {
        ^size;
    }

    // override and return nil for no match, new toke otherwise
    *match {
        | buf, offs |

        SubclassResponsibilityError("What are you doing human?").throw;
    }

    // match requested toke
    *match_toke {
        | buf, offs, toke_class |

        var match;
        match = buf.findRegexpAt(toke_class.regex, offs);
        if (match.isNil) {
            ^nil;
        };

        ^toke_class.new(match[0], offs, match[1], toke_class);
    }

}

// ---------------------
// Whitespace is special
// ---------------------
Toke_Whitespace : SkoarToke {
    classvar <regex = "[ \\t]*";
    classvar <>freq = 0.0;

    *burn {
        | buf, offs |

        var match;
        match = buf.findRegexpAt(Toke_Whitespace.regex, offs);
        if (match != nil) {
            ^match[1];
        };

        ^0;
    }

}

// --------------
// EOF is special
// --------------
Toke_EOF : SkoarToke {
    classvar <>freq = 0.0;
    *burn {
        | buf, offs |

        if (buf.size > offs) {
            SkoarError("Tried to burn EOF when there's more input.").throw;
        };

        ^0;
    }

    *match {
        | buf, offs |

        if (buf.size < offs) {
            SkoarError("Tried to burn EOF when there's more input.").throw;
        };

        if (buf.size == offs) {
            ^Toke_EOF.new();
        };

        ^nil;
    }

}

// --------------
// Everyday Tokes
// --------------
Toke_CondS : SkoarToke {
    classvar <regex = "[{][?][\\n]*";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_CondS);
    }

}

Toke_SkoarpionStart : SkoarToke {
    classvar <regex = "[{]!(?=(.(?!!!))*!})";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SkoarpionStart);
    }

}

Toke_ExactRest : SkoarToke {
    classvar <regex = "[{](?![=?:!])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ExactRest);
    }

}

Toke_False : SkoarToke {
    classvar <regex = "no|false";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_False);
    }

}

Toke_True : SkoarToke {
    classvar <regex = "yes|true";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_True);
    }

}

Toke_Times : SkoarToke {
    classvar <regex = "[Tt]imes";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Times);
    }

}

Toke_LoopE : SkoarToke {
    classvar <regex = ":[}]";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_LoopE);
    }

}

Toke_DynSFZ : SkoarToke {
    classvar <regex = "sfz(?![a-oq-zA-Z0-9_])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynSFZ);
    }

}

Toke_QuindicesimaA : SkoarToke {
    classvar <regex = "15ma|alla quindicesima";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_QuindicesimaA);
    }

}

Toke_Choard : SkoarToke {
    classvar <regex = "~*[ABCDEFG](?![.ce-ln-rt-zA-LN-Z]|a[l ])(#|b)?([Mm0-9]|sus|dim|aug|dom)*~*";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Choard);
    }

}

Toke_Lute : SkoarToke {
    classvar <regex = "&(?!<)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Lute);
    }

}

Toke_Semicolon : SkoarToke {
    classvar <regex = ";";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Semicolon);
    }

}

Toke_SymbolName : SkoarToke {
    classvar <regex = "[a-zA-Z0-9_][a-zA-Z0-9_]*(?![[a-zA-Z0-9_fi \\t]*:)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SymbolName);
    }

}

Toke_Segno : SkoarToke {
    classvar <regex = ",[Ss](?:egno)?`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Segno);
    }

}

Toke_SymbolColon : SkoarToke {
    classvar <regex = "[a-zA-Z_][a-zA-Z0-9_]*[ \\t]*:(?![:|}])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SymbolColon);
    }

}

Toke_Coda : SkoarToke {
    classvar <regex = "\\([+]\\)(?:`(?:[a-zA-Z_][a-zA-Z0-9_]*`)*)?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Coda);
    }

}

Toke_LuteWithArgs : SkoarToke {
    classvar <regex = "&<";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_LuteWithArgs);
    }

}

Toke_Symbol : SkoarToke {
    classvar <regex = "[\\\\@][a-zA-Z0-9_][a-zA-Z0-9_]*";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Symbol);
    }

}

Toke_OttavaA : SkoarToke {
    classvar <regex = "8va|ottava (alta|sopra)|all' ottava";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_OttavaA);
    }

}

Toke_Comment : SkoarToke {
    classvar <regex = "<[?](.|[\\n\\r])*?[?]>";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Comment);
    }

}

Toke_Quavers : SkoarToke {
    classvar <regex = "o+/\\.?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Quavers);
    }

}

Toke_Newline : SkoarToke {
    classvar <regex = "[\\n\\r][\\n\\r \\t]*";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Newline);
    }

}

Toke_ListSep : SkoarToke {
    classvar <regex = ",";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ListSep);
    }

}

Toke_MathOp : SkoarToke {
    classvar <regex = "[+*\\-/%](?!>)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MathOp);
    }

}

Toke_BooleanOp : SkoarToke {
    classvar <regex = "==|!=|<=|>=|and|or|xor";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_BooleanOp);
    }

}

Toke_CondE : SkoarToke {
    classvar <regex = "[?][}]";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_CondE);
    }

}

Toke_DynPiano : SkoarToke {
    classvar <regex = "(m(ezzo)?p|p+)(iano)?(?![a-oq-zA-Z0-9_])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynPiano);
    }

}

Toke_KUGenWithArgs : SkoarToke {
    classvar <regex = "k[A-Z][a-zA-Z0-9_]*<";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_KUGenWithArgs);
    }

}

Toke_KUGen : SkoarToke {
    classvar <regex = "k[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_KUGen);
    }

}

Toke_Quarters : SkoarToke {
    classvar <regex = "\\.?[)]+(?:__?)?\\.?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Quarters);
    }

}

Toke_DUGenWithArgs : SkoarToke {
    classvar <regex = "d[A-Z][a-zA-Z0-9_]*<";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DUGenWithArgs);
    }

}

Toke_HashLevel : SkoarToke {
    classvar <regex = "\\[#*[ ]*\\]";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_HashLevel);
    }

}

Toke_DaCapo : SkoarToke {
    classvar <regex = "D\\.C\\.|Da Capo";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DaCapo);
    }

}

Toke_Bars : SkoarToke {
    classvar <regex = ":?\\|+:?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Bars);
    }

}

Toke_ExactBeat : SkoarToke {
    classvar <regex = "[(](?![+])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ExactBeat);
    }

}

Toke_DynFP : SkoarToke {
    classvar <regex = "fp(?![a-oq-zA-Z0-9_])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynFP);
    }

}

Toke_CondIf : SkoarToke {
    classvar <regex = "[?][?](?![}])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_CondIf);
    }

}

Toke_SkoarpionStartWithSig : SkoarToke {
    classvar <regex = "[{]!(?=(.(?!!}))*!!)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SkoarpionStartWithSig);
    }

}

Toke_AUGenWithArgs : SkoarToke {
    classvar <regex = "a[A-Z][a-zA-Z0-9_]*<";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AUGenWithArgs);
    }

}

Toke_ListE : SkoarToke {
    classvar <regex = ">(?![=])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ListE);
    }

}

Toke_AssOp : SkoarToke {
    classvar <regex = "=>|[+]>|->|[*]>";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AssOp);
    }

}

Toke_DynForte : SkoarToke {
    classvar <regex = "m(ezzo)?f(orte)?|f+orte|ff+(?![a-oq-zA-Z0-9_])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DynForte);
    }

}

Toke_Carrot : SkoarToke {
    classvar <regex = "\\^(?!\\^[(])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Carrot);
    }

}

Toke_SkoarpionEnd : SkoarToke {
    classvar <regex = "![}]";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SkoarpionEnd);
    }

}

Toke_SkoarpionSep : SkoarToke {
    classvar <regex = "!!";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_SkoarpionSep);
    }

}

Toke_Cat : SkoarToke {
    classvar <regex = "=\\^\\.\\^=";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Cat);
    }

}

Toke_AlFine : SkoarToke {
    classvar <regex = "al fine";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AlFine);
    }

}

Toke_Voice : SkoarToke {
    classvar <regex = "\\.(([a-zA-Z_][a-zA-Z0-9_]*)?|\\.+)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Voice);
    }

}

Toke_Fairy : SkoarToke {
    classvar <regex = "[$]";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Fairy);
    }

}

Toke_Deref : SkoarToke {
    classvar <regex = "!(?![!}]|=)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Deref);
    }

}

Toke_AlSegno : SkoarToke {
    classvar <regex = "al segno";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AlSegno);
    }

}

Toke_Loco : SkoarToke {
    classvar <regex = "loco";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Loco);
    }

}

Toke_Eighths : SkoarToke {
    classvar <regex = "\\.?\\]+(?:__?)?\\.?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Eighths);
    }

}

Toke_MeditationS : SkoarToke {
    classvar <regex = "[{]=[\\n]*";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MeditationS);
    }

}

Toke_MsgName : SkoarToke {
    classvar <regex = "[a-zA-Z_][a-zA-Z0-9_]*(?!<)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MsgName);
    }

}

Toke_LoopS : SkoarToke {
    classvar <regex = "[{]:[\\n]*";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_LoopS);
    }

}

Toke_Freq : SkoarToke {
    classvar <regex = "(0|[1-9][0-9]*)(\\.[0-9]+)?Hz";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Freq);
    }

}

Toke_RWing : SkoarToke {
    classvar <regex = "[)]\\^\\^";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_RWing);
    }

}

Toke_LWing : SkoarToke {
    classvar <regex = "\\^\\^[(]";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_LWing);
    }

}

Toke_Crotchets : SkoarToke {
    classvar <regex = "[}]+\\.?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Crotchets);
    }

}

Toke_String : SkoarToke {
    classvar <regex = "'[^']*'";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_String);
    }

}

Toke_Nosey : SkoarToke {
    classvar <regex = ",";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Nosey);
    }

}

Toke_NamedNoat : SkoarToke {
    classvar <regex = "(?:_?)(?:[a-g](?![ac-zA-Z_]))(#|b)?(?![ \\t]*:(?![}:|]))";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_NamedNoat);
    }

}

Toke_MeditationE : SkoarToke {
    classvar <regex = "=[}]";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MeditationE);
    }

}

Toke_ListS : SkoarToke {
    classvar <regex = "<(?![=?])|<(?=[=]\\^\\.)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_ListS);
    }

}

Toke_OctaveShift : SkoarToke {
    classvar <regex = "~+o|o~+";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_OctaveShift);
    }

}

Toke_MsgOp : SkoarToke {
    classvar <regex = "\\.(?![)\\]])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MsgOp);
    }

}

Toke_AUGen : SkoarToke {
    classvar <regex = "a[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AUGen);
    }

}

Toke_DalSegno : SkoarToke {
    classvar <regex = "D\\.S\\.|Dal Segno";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DalSegno);
    }

}

Toke_OttavaB : SkoarToke {
    classvar <regex = "8vb|ottava (bassa|sotto)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_OttavaB);
    }

}

Toke_LoopSep : SkoarToke {
    classvar <regex = "::[\\n]*(?![|])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_LoopSep);
    }

}

Toke_QuindicesimaB : SkoarToke {
    classvar <regex = "15mb";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_QuindicesimaB);
    }

}

Toke_Tuplet : SkoarToke {
    classvar <regex = "/\\d+(:\\d+)?|(du|tri|quadru)plets?|(quin|sex|sep|oc)tuplets?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Tuplet);
    }

}

Toke_MsgNameWithArgs : SkoarToke {
    classvar <regex = "[a-zA-Z_][a-zA-Z0-9_]*<";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_MsgNameWithArgs);
    }

}

Toke_Duration : SkoarToke {
    classvar <regex = "[0-9]+:[0-9]+(\\.[0-9]+)?";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Duration);
    }

}

Toke_DUGen : SkoarToke {
    classvar <regex = "d[A-Z][a-zA-Z0-9_]*(?![a-zA-Z0-9_]*<)";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_DUGen);
    }

}

Toke_Int : SkoarToke {
    classvar <regex = "(-)?(0|[1-9][0-9]*)(?![0-9]*Hz|[mv][ab]|\\.[0-9]|:[0-9])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Int);
    }

}

Toke_Fine : SkoarToke {
    classvar <regex = "fine";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Fine);
    }

}

Toke_Float : SkoarToke {
    classvar <regex = "(-)?(0|[1-9][0-9]*)\\.[0-9]+(?!Hz|:[0-9])";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_Float);
    }

}

Toke_AlCoda : SkoarToke {
    classvar <regex = "al(la)? coda";
    classvar <>freq = 0.0;

    *match {
        | buf, offs |

        ^SkoarToke.match_toke(buf, offs, Toke_AlCoda);
    }

}

