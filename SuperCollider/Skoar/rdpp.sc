// ===============================================================================================================================
// rdpp.sc - Generated by Code_Parser_Sc - Create Recursive Descent Predictive Parser on 2016-02-21 17:05:51 for SuperCollider 3.7
// ===============================================================================================================================

SkoarParseException : Exception {

}

SkoarParser {

    classvar <desirables;
    var runtime, toker, deep;

    *new {
        | rt |
        ^super.new.init( rt )
    }

    init {
        | rt |
        runtime = rt;
        toker = runtime.toker;
        deep = 0;
    }

    *initClass {
        desirables = IdentityDictionary();
        SkoarParser.init_desirables;
    }

    fail {
        //toker.dump;
        SkoarParseException("Fail").throw;
    }

    fail_too_deep {
        "Parse tree too deep!".postln;
        //toker.dump;
        SkoarParseException("Parse tree too deep").throw;
    }


    //print {
    //    | line, end |
    //    (line ++ end).postln;
    //}

    *init_desirables {

        // arg_listy_suffix
        desirables.put('arg_listy_suffix -> Newline arg_listy_entries ListE', [Toke_Newline]);
        desirables.put('arg_listy_suffix -> arg_listy_entries ListE', [Toke_SymbolColon, Toke_SymbolName]);
        desirables.put('arg_listy_suffix -> ListE', [Toke_ListE]);

        // skrp_moar_lines
        desirables.put('skrp_moar_lines -> Newline skrp_lines', [Toke_Newline]);

        // lute
        desirables.put('lute -> Lute', [Toke_Lute]);
        desirables.put('lute -> LuteWithArgs listy_suffix', [Toke_LuteWithArgs]);

        // moar_listy_entries
        desirables.put('moar_listy_entries -> ListSep moar_listy_entries', [Toke_ListSep]);
        desirables.put('moar_listy_entries -> Newline moar_listy_entries', [Toke_Newline]);
        desirables.put('moar_listy_entries -> listy_entries', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP,
                   Toke_Duration, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB,
                   Toke_OttavaA, Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Float]);

        // deref_prime
        desirables.put('deref_prime -> MsgNameWithArgs listy_suffix', [Toke_MsgNameWithArgs]);
        desirables.put('deref_prime -> MsgName', [Toke_MsgName]);

        // al_x
        desirables.put('al_x -> AlCoda', [Toke_AlCoda]);
        desirables.put('al_x -> AlSegno', [Toke_AlSegno]);
        desirables.put('al_x -> AlFine', [Toke_AlFine]);

        // expr
        desirables.put('expr -> SymbolColon expr', [Toke_SymbolColon]);
        desirables.put('expr -> msgable expr_prime', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_Symbol, Toke_LuteWithArgs, Toke_Cat,
                   Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano, Toke_KUGenWithArgs,
                   Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP, Toke_Duration,
                   Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int, Toke_DynForte,
                   Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS, Toke_Freq,
                   Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB, Toke_OttavaA,
                   Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String, Toke_DUGen,
                   Toke_Float]);

        // expr_prime
        desirables.put('expr_prime -> assignment expr_prime', [Toke_AssOp]);
        desirables.put('expr_prime -> math expr_prime', [Toke_MathOp]);
        desirables.put('expr_prime -> boolean', [Toke_BooleanOp]);
        desirables.put('expr_prime -> times', [Toke_Times]);

        // opt_voiced_phrases
        desirables.put('opt_voiced_phrases -> Voice phrases', [Toke_Voice]);
        desirables.put('opt_voiced_phrases -> phrases', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_SkoarpionEnd, Toke_DaCapo, Toke_NamedNoat,
                   Toke_DUGenWithArgs, Toke_Newline, Toke_DynPiano, Toke_False, Toke_KUGenWithArgs,
                   Toke_KUGen, Toke_Quarters, Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat,
                   Toke_Duration, Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs,
                   Toke_Int, Toke_DynForte, Toke_Carrot, Toke_Deref, Toke_Loco,
                   Toke_Eighths, Toke_LoopS, Toke_Freq, Toke_LWing, Toke_Crotchets,
                   Toke_QuindicesimaB, Toke_ListS, Toke_OctaveShift, Toke_Fairy, Toke_MeditationS,
                   Toke_OttavaA, Toke_MeditationE, Toke_DalSegno, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Fine, Toke_Float]);

        // skoar
        desirables.put('skoar -> branches', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_Newline, Toke_DaCapo, Toke_NamedNoat,
                   Toke_DUGenWithArgs, Toke_EOF, Toke_DynPiano, Toke_False, Toke_KUGenWithArgs,
                   Toke_KUGen, Toke_Quarters, Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat,
                   Toke_Duration, Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs,
                   Toke_Int, Toke_DynForte, Toke_Carrot, Toke_Voice, Toke_Deref,
                   Toke_Loco, Toke_Eighths, Toke_LoopS, Toke_Freq, Toke_LWing,
                   Toke_Crotchets, Toke_QuindicesimaB, Toke_ListS, Toke_OctaveShift, Toke_Fairy,
                   Toke_MeditationS, Toke_OttavaA, Toke_DalSegno, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Fine, Toke_Float]);

        // meditation
        desirables.put('meditation -> MeditationS skrp_lines MeditationE', [Toke_MeditationS]);

        // loop_body
        desirables.put('loop_body -> phrases', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_DaCapo, Toke_NamedNoat, Toke_DUGenWithArgs,
                   Toke_DynPiano, Toke_False, Toke_KUGenWithArgs, Toke_KUGen, Toke_Quarters,
                   Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat, Toke_Duration, Toke_DynFP,
                   Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int, Toke_DynForte,
                   Toke_Carrot, Toke_Deref, Toke_Loco, Toke_Eighths, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Crotchets, Toke_QuindicesimaB, Toke_ListS,
                   Toke_OctaveShift, Toke_Fairy, Toke_MeditationS, Toke_OttavaA, Toke_LoopE,
                   Toke_DalSegno, Toke_OttavaB, Toke_LoopSep, Toke_String, Toke_DUGen,
                   Toke_Fine, Toke_Float]);

        // phrases
        desirables.put('phrases -> phrasey phrases', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_DaCapo, Toke_NamedNoat, Toke_DUGenWithArgs,
                   Toke_DynPiano, Toke_False, Toke_KUGenWithArgs, Toke_KUGen, Toke_Quarters,
                   Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat, Toke_Duration, Toke_DynFP,
                   Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int, Toke_DynForte,
                   Toke_Carrot, Toke_Deref, Toke_Loco, Toke_Eighths, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Crotchets, Toke_QuindicesimaB, Toke_ListS,
                   Toke_OctaveShift, Toke_Fairy, Toke_MeditationS, Toke_OttavaA, Toke_DalSegno,
                   Toke_OttavaB, Toke_String, Toke_DUGen, Toke_Fine, Toke_Float]);

        // ugen_simple
        desirables.put('ugen_simple -> AUGen', [Toke_AUGen]);
        desirables.put('ugen_simple -> KUGen', [Toke_KUGen]);
        desirables.put('ugen_simple -> DUGen', [Toke_DUGen]);

        // skrp_sig
        desirables.put('skrp_sig -> SymbolName skrp_sig_prime', [Toke_SymbolName]);
        desirables.put('skrp_sig -> arg_listy SkoarpionSep', [Toke_ListS]);

        // boolean
        desirables.put('boolean -> BooleanOp expr', [Toke_BooleanOp]);

        // optional_voice
        desirables.put('optional_voice -> Voice', [Toke_Voice]);

        // dynamic
        desirables.put('dynamic -> DynPiano', [Toke_DynPiano]);
        desirables.put('dynamic -> DynForte', [Toke_DynForte]);
        desirables.put('dynamic -> DynSFZ', [Toke_DynSFZ]);
        desirables.put('dynamic -> DynFP', [Toke_DynFP]);

        // phrasey
        desirables.put('phrasey -> Comment', [Toke_Comment]);
        desirables.put('phrasey -> marker', [Toke_Bars, Toke_Coda, Toke_Segno, Toke_Fine]);
        desirables.put('phrasey -> expr', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP,
                   Toke_Duration, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB,
                   Toke_OttavaA, Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Float]);
        desirables.put('phrasey -> dal_goto', [Toke_DalSegno, Toke_DaCapo]);
        desirables.put('phrasey -> beat', [Toke_Quarters, Toke_Quavers, Toke_ExactRest, Toke_Eighths, Toke_ExactBeat,
                   Toke_Crotchets]);

        // if_body
        desirables.put('if_body -> phrases', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_Newline, Toke_DaCapo, Toke_NamedNoat,
                   Toke_DUGenWithArgs, Toke_CondE, Toke_DynPiano, Toke_False, Toke_KUGenWithArgs,
                   Toke_KUGen, Toke_Quarters, Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat,
                   Toke_Duration, Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs,
                   Toke_CondIf, Toke_Int, Toke_DynForte, Toke_Carrot, Toke_Deref,
                   Toke_Loco, Toke_Eighths, Toke_LoopS, Toke_Freq, Toke_LWing,
                   Toke_Crotchets, Toke_QuindicesimaB, Toke_ListS, Toke_OctaveShift, Toke_Fairy,
                   Toke_MeditationS, Toke_OttavaA, Toke_DalSegno, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Fine, Toke_Float]);

        // msg
        desirables.put('msg -> MsgNameWithArgs listy_suffix', [Toke_MsgNameWithArgs]);
        desirables.put('msg -> MsgName', [Toke_MsgName]);
        desirables.put('msg -> listy', [Toke_ListS]);
        desirables.put('msg -> loop', [Toke_LoopS]);

        // cond_ifs_suffix
        desirables.put('cond_ifs_suffix -> Newline cond_ifs', [Toke_Newline]);

        // msgable
        desirables.put('msgable -> nouny msg_chain_node', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_Symbol, Toke_LuteWithArgs, Toke_Cat,
                   Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano, Toke_KUGenWithArgs,
                   Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP, Toke_Duration,
                   Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int, Toke_DynForte,
                   Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS, Toke_Freq,
                   Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB, Toke_OttavaA,
                   Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String, Toke_DUGen,
                   Toke_Float]);

        // skrp_sig_prime
        desirables.put('skrp_sig_prime -> SkoarpionSep', [Toke_SkoarpionSep]);
        desirables.put('skrp_sig_prime -> arg_listy SkoarpionSep', [Toke_ListS]);

        // arg_listy
        desirables.put('arg_listy -> ListS arg_listy_suffix', [Toke_ListS]);

        // dal_goto
        desirables.put('dal_goto -> DaCapo al_x', [Toke_DaCapo]);
        desirables.put('dal_goto -> DalSegno al_x', [Toke_DalSegno]);

        // musical_keyword_misc
        desirables.put('musical_keyword_misc -> Carrot', [Toke_Carrot]);

        // ugen_with_args
        desirables.put('ugen_with_args -> AUGenWithArgs listy_suffix', [Toke_AUGenWithArgs]);
        desirables.put('ugen_with_args -> KUGenWithArgs listy_suffix', [Toke_KUGenWithArgs]);
        desirables.put('ugen_with_args -> DUGenWithArgs listy_suffix', [Toke_DUGenWithArgs]);

        // skrp_lines
        desirables.put('skrp_lines -> opt_voiced_phrases skrp_moar_lines', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_Newline, Toke_DaCapo, Toke_NamedNoat,
                   Toke_DUGenWithArgs, Toke_SkoarpionEnd, Toke_DynPiano, Toke_False, Toke_KUGenWithArgs,
                   Toke_KUGen, Toke_Quarters, Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat,
                   Toke_Duration, Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs,
                   Toke_Int, Toke_DynForte, Toke_Carrot, Toke_Voice, Toke_Deref,
                   Toke_Loco, Toke_Eighths, Toke_LoopS, Toke_Freq, Toke_LWing,
                   Toke_Crotchets, Toke_QuindicesimaB, Toke_ListS, Toke_OctaveShift, Toke_Fairy,
                   Toke_MeditationS, Toke_OttavaA, Toke_MeditationE, Toke_DalSegno, Toke_OttavaB,
                   Toke_String, Toke_DUGen, Toke_Fine, Toke_Float]);

        // exact_beat
        desirables.put('exact_beat -> ExactBeat expr Quarters', [Toke_ExactBeat]);

        // cthulhu
        desirables.put('cthulhu -> LWing Semicolon cthulhu_prime', [Toke_LWing]);

        // cond_else
        desirables.put('cond_else -> CondIf if_body', [Toke_CondIf]);

        // boolean_expr
        desirables.put('boolean_expr -> expr', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP,
                   Toke_Duration, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB,
                   Toke_OttavaA, Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Float]);

        // coda
        desirables.put('coda -> Coda optional_al_coda', [Toke_Coda]);

        // moar_arg_listy_entries
        desirables.put('moar_arg_listy_entries -> ListSep moar_arg_listy_entries', [Toke_ListSep]);
        desirables.put('moar_arg_listy_entries -> Newline moar_arg_listy_entries', [Toke_Newline]);
        desirables.put('moar_arg_listy_entries -> arg_listy_entries', [Toke_SymbolColon, Toke_SymbolName]);

        // regular_beat
        desirables.put('regular_beat -> Crotchets', [Toke_Crotchets]);
        desirables.put('regular_beat -> Quavers', [Toke_Quavers]);
        desirables.put('regular_beat -> Quarters', [Toke_Quarters]);
        desirables.put('regular_beat -> Eighths', [Toke_Eighths]);

        // marker
        desirables.put('marker -> Segno', [Toke_Segno]);
        desirables.put('marker -> Fine', [Toke_Fine]);
        desirables.put('marker -> coda', [Toke_Coda]);
        desirables.put('marker -> Bars', [Toke_Bars]);

        // listy_suffix
        desirables.put('listy_suffix -> Newline listy_entries ListE', [Toke_Newline]);
        desirables.put('listy_suffix -> listy_entries ListE', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP,
                   Toke_Duration, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB,
                   Toke_OttavaA, Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Float]);
        desirables.put('listy_suffix -> ListE', [Toke_ListE]);

        // arg_expr
        desirables.put('arg_expr -> SymbolName', [Toke_SymbolName]);
        desirables.put('arg_expr -> SymbolColon expr', [Toke_SymbolColon]);

        // msg_chain_node
        desirables.put('msg_chain_node -> MsgOp msg msg_chain_node', [Toke_MsgOp]);

        // exact_rest
        desirables.put('exact_rest -> ExactRest expr Crotchets', [Toke_ExactRest]);

        // math
        desirables.put('math -> MathOp msgable', [Toke_MathOp]);

        // skrp_suffix
        desirables.put('skrp_suffix -> skrp_lines SkoarpionEnd', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_Newline, Toke_DaCapo, Toke_NamedNoat,
                   Toke_DUGenWithArgs, Toke_SkoarpionEnd, Toke_DynPiano, Toke_False, Toke_KUGenWithArgs,
                   Toke_KUGen, Toke_Quarters, Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat,
                   Toke_Duration, Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs,
                   Toke_Int, Toke_DynForte, Toke_Carrot, Toke_Voice, Toke_Deref,
                   Toke_Loco, Toke_Eighths, Toke_LoopS, Toke_Freq, Toke_LWing,
                   Toke_Crotchets, Toke_QuindicesimaB, Toke_ListS, Toke_OctaveShift, Toke_Fairy,
                   Toke_MeditationS, Toke_OttavaA, Toke_DalSegno, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Fine, Toke_Float]);

        // assignment
        desirables.put('assignment -> AssOp settable', [Toke_AssOp]);

        // listy_entries
        desirables.put('listy_entries -> expr moar_listy_entries', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP,
                   Toke_Duration, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB,
                   Toke_OttavaA, Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Float]);

        // cond_if
        desirables.put('cond_if -> optional_voice boolean_expr CondIf if_body cond_else', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP,
                   Toke_Duration, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Voice, Toke_Deref, Toke_Loco,
                   Toke_LoopS, Toke_Freq, Toke_LWing, Toke_Fairy, Toke_MeditationS,
                   Toke_QuindicesimaB, Toke_OttavaA, Toke_OctaveShift, Toke_ListS, Toke_OttavaB,
                   Toke_String, Toke_DUGen, Toke_Float]);

        // ugen
        desirables.put('ugen -> ugen_with_args', [Toke_AUGenWithArgs, Toke_KUGenWithArgs, Toke_DUGenWithArgs]);
        desirables.put('ugen -> ugen_simple', [Toke_DUGen, Toke_AUGen, Toke_KUGen]);

        // arg_listy_entries
        desirables.put('arg_listy_entries -> arg_expr moar_arg_listy_entries', [Toke_SymbolColon, Toke_SymbolName]);

        // deref
        desirables.put('deref -> Deref deref_prime', [Toke_Deref]);

        // ottavas
        desirables.put('ottavas -> OctaveShift', [Toke_OctaveShift]);
        desirables.put('ottavas -> OttavaA', [Toke_OttavaA]);
        desirables.put('ottavas -> OttavaB', [Toke_OttavaB]);
        desirables.put('ottavas -> QuindicesimaA', [Toke_QuindicesimaA]);
        desirables.put('ottavas -> QuindicesimaB', [Toke_QuindicesimaB]);
        desirables.put('ottavas -> Loco', [Toke_Loco]);

        // cond_ifs
        desirables.put('cond_ifs -> cond_if cond_ifs_suffix', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_NamedNoat, Toke_DUGenWithArgs, Toke_DynPiano, Toke_False,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_QuindicesimaA, Toke_HashLevel, Toke_Duration,
                   Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Voice, Toke_Deref, Toke_Loco,
                   Toke_LoopS, Toke_Freq, Toke_LWing, Toke_QuindicesimaB, Toke_ListS,
                   Toke_OctaveShift, Toke_Fairy, Toke_MeditationS, Toke_OttavaA, Toke_OttavaB,
                   Toke_String, Toke_DUGen, Toke_Float]);

        // musical_keyword
        desirables.put('musical_keyword -> dynamic', [Toke_DynSFZ, Toke_DynForte, Toke_DynFP, Toke_DynPiano]);
        desirables.put('musical_keyword -> ottavas', [Toke_Loco, Toke_QuindicesimaB, Toke_OttavaA, Toke_OctaveShift, Toke_QuindicesimaA,
                   Toke_OttavaB]);
        desirables.put('musical_keyword -> musical_keyword_misc', [Toke_Carrot]);

        // listy
        desirables.put('listy -> ListS listy_suffix', [Toke_ListS]);

        // optional_al_coda
        desirables.put('optional_al_coda -> AlCoda', [Toke_AlCoda]);

        // cthulhu_prime
        desirables.put('cthulhu_prime -> boolean_expr Semicolon RWing', [Toke_CondS, Toke_SkoarpionStart, Toke_SkoarpionStartWithSig, Toke_True, Toke_DynSFZ,
                   Toke_Choard, Toke_Lute, Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs,
                   Toke_Cat, Toke_DUGenWithArgs, Toke_NamedNoat, Toke_False, Toke_DynPiano,
                   Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel, Toke_QuindicesimaA, Toke_DynFP,
                   Toke_Duration, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Deref, Toke_Loco, Toke_LoopS,
                   Toke_Freq, Toke_LWing, Toke_Fairy, Toke_MeditationS, Toke_QuindicesimaB,
                   Toke_OttavaA, Toke_OctaveShift, Toke_ListS, Toke_OttavaB, Toke_String,
                   Toke_DUGen, Toke_Float]);
        desirables.put('cthulhu_prime -> Nosey Semicolon RWing', [Toke_Nosey]);

        // loop_condition
        desirables.put('loop_condition -> LoopSep boolean_expr', [Toke_LoopSep]);

        // beat
        desirables.put('beat -> regular_beat', [Toke_Quarters, Toke_Quavers, Toke_Eighths, Toke_Crotchets]);
        desirables.put('beat -> exact_beat', [Toke_ExactBeat]);
        desirables.put('beat -> exact_rest', [Toke_ExactRest]);

        // branch
        desirables.put('branch -> opt_voiced_phrases Newline', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_Newline, Toke_DaCapo, Toke_NamedNoat,
                   Toke_DUGenWithArgs, Toke_DynPiano, Toke_False, Toke_KUGenWithArgs, Toke_KUGen,
                   Toke_Quarters, Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat, Toke_Duration,
                   Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Voice, Toke_Deref, Toke_Loco,
                   Toke_Eighths, Toke_LoopS, Toke_Freq, Toke_LWing, Toke_Crotchets,
                   Toke_QuindicesimaB, Toke_ListS, Toke_OctaveShift, Toke_Fairy, Toke_MeditationS,
                   Toke_OttavaA, Toke_DalSegno, Toke_OttavaB, Toke_String, Toke_DUGen,
                   Toke_Fine, Toke_Float]);

        // conditional
        desirables.put('conditional -> CondS cond_ifs CondE', [Toke_CondS]);

        // nouny_literal
        desirables.put('nouny_literal -> Duration', [Toke_Duration]);
        desirables.put('nouny_literal -> ugen', [Toke_DUGenWithArgs, Toke_DUGen, Toke_AUGen, Toke_AUGenWithArgs, Toke_KUGenWithArgs,
                   Toke_KUGen]);
        desirables.put('nouny_literal -> Tuplet', [Toke_Tuplet]);
        desirables.put('nouny_literal -> Freq', [Toke_Freq]);
        desirables.put('nouny_literal -> Int', [Toke_Int]);
        desirables.put('nouny_literal -> Float', [Toke_Float]);
        desirables.put('nouny_literal -> String', [Toke_String]);
        desirables.put('nouny_literal -> Choard', [Toke_Choard]);
        desirables.put('nouny_literal -> NamedNoat', [Toke_NamedNoat]);
        desirables.put('nouny_literal -> Symbol', [Toke_Symbol]);
        desirables.put('nouny_literal -> Fairy', [Toke_Fairy]);
        desirables.put('nouny_literal -> HashLevel', [Toke_HashLevel]);
        desirables.put('nouny_literal -> False', [Toke_False]);
        desirables.put('nouny_literal -> True', [Toke_True]);
        desirables.put('nouny_literal -> Cat', [Toke_Cat]);
        desirables.put('nouny_literal -> lute', [Toke_LuteWithArgs, Toke_Lute]);

        // skoarpion
        desirables.put('skoarpion -> SkoarpionStartWithSig skrp_sig skrp_suffix', [Toke_SkoarpionStartWithSig]);
        desirables.put('skoarpion -> SkoarpionStart skrp_suffix', [Toke_SkoarpionStart]);

        // loop
        desirables.put('loop -> LoopS loop_body loop_condition LoopE', [Toke_LoopS]);

        // times
        desirables.put('times -> Times', [Toke_Times]);

        // nouny
        desirables.put('nouny -> cthulhu', [Toke_LWing]);
        desirables.put('nouny -> meditation', [Toke_MeditationS]);
        desirables.put('nouny -> conditional', [Toke_CondS]);
        desirables.put('nouny -> loop', [Toke_LoopS]);
        desirables.put('nouny -> nouny_literal', [Toke_Float, Toke_True, Toke_Choard, Toke_Lute, Toke_Freq,
                   Toke_Symbol, Toke_LuteWithArgs, Toke_Cat, Toke_Fairy, Toke_DUGenWithArgs,
                   Toke_NamedNoat, Toke_False, Toke_KUGenWithArgs, Toke_KUGen, Toke_HashLevel,
                   Toke_Duration, Toke_Tuplet, Toke_String, Toke_AUGen, Toke_AUGenWithArgs,
                   Toke_DUGen, Toke_Int]);
        desirables.put('nouny -> musical_keyword', [Toke_DynForte, Toke_QuindicesimaB, Toke_OttavaA, Toke_OctaveShift, Toke_Carrot,
                   Toke_DynSFZ, Toke_DynPiano, Toke_OttavaB, Toke_Loco, Toke_QuindicesimaA,
                   Toke_DynFP]);
        desirables.put('nouny -> listy', [Toke_ListS]);
        desirables.put('nouny -> deref', [Toke_Deref]);
        desirables.put('nouny -> skoarpion', [Toke_SkoarpionStart, Toke_SkoarpionStartWithSig]);

        // branches
        desirables.put('branches -> branch branches', [Toke_CondS, Toke_SkoarpionStart, Toke_ExactRest, Toke_SkoarpionStartWithSig, Toke_True,
                   Toke_Bars, Toke_DynSFZ, Toke_Choard, Toke_Lute, Toke_Segno,
                   Toke_SymbolColon, Toke_Symbol, Toke_LuteWithArgs, Toke_Comment, Toke_Coda,
                   Toke_Quavers, Toke_Cat, Toke_Newline, Toke_DaCapo, Toke_NamedNoat,
                   Toke_DUGenWithArgs, Toke_DynPiano, Toke_False, Toke_KUGenWithArgs, Toke_KUGen,
                   Toke_Quarters, Toke_QuindicesimaA, Toke_HashLevel, Toke_ExactBeat, Toke_Duration,
                   Toke_DynFP, Toke_Tuplet, Toke_AUGen, Toke_AUGenWithArgs, Toke_Int,
                   Toke_DynForte, Toke_Carrot, Toke_Voice, Toke_Deref, Toke_Loco,
                   Toke_Eighths, Toke_LoopS, Toke_Freq, Toke_LWing, Toke_Crotchets,
                   Toke_QuindicesimaB, Toke_ListS, Toke_OctaveShift, Toke_Fairy, Toke_MeditationS,
                   Toke_OttavaA, Toke_DalSegno, Toke_OttavaB, Toke_String, Toke_DUGen,
                   Toke_Fine, Toke_Float]);

        // settable
        desirables.put('settable -> Symbol', [Toke_Symbol]);
        desirables.put('settable -> listy', [Toke_ListS]);
        desirables.put('settable -> Quarters', [Toke_Quarters]);
        desirables.put('settable -> Eighths', [Toke_Eighths]);
        desirables.put('settable -> Fairy', [Toke_Fairy]);
    }

    arg_listy_suffix {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['arg_listy_suffix -> Newline arg_listy_entries ListE'];
        // arg_listy_suffix -> Newline arg_listy_entries ListE
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Newline', toker.burn(Toke_Newline));
            this.arg_listy_entries(noad);
            runtime.add_toke(noad, 'Toke_ListE', toker.burn(Toke_ListE));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['arg_listy_suffix -> arg_listy_entries ListE'];
        // arg_listy_suffix -> arg_listy_entries ListE
        if (toker.sees(desires).notNil) {
            this.arg_listy_entries(noad);
            runtime.add_toke(noad, 'Toke_ListE', toker.burn(Toke_ListE));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['arg_listy_suffix -> ListE'];
        // arg_listy_suffix -> ListE
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ListE', toker.burn(Toke_ListE));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_moar_lines {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['skrp_moar_lines -> Newline skrp_lines'];
        // skrp_moar_lines -> Newline skrp_lines
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Newline', toker.burn(Toke_Newline));
            this.skrp_lines(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    lute {
        | parent |

        var noad = SkoarNoad.new('lute', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['lute -> Lute'];
        // lute -> Lute
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Lute', toker.burn(Toke_Lute));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['lute -> LuteWithArgs listy_suffix'];
        // lute -> LuteWithArgs listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_LuteWithArgs', toker.burn(Toke_LuteWithArgs));
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    moar_listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['moar_listy_entries -> ListSep moar_listy_entries'];
        // moar_listy_entries -> ListSep moar_listy_entries
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ListSep', toker.burn(Toke_ListSep));
            this.moar_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['moar_listy_entries -> Newline moar_listy_entries'];
        // moar_listy_entries -> Newline moar_listy_entries
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Newline', toker.burn(Toke_Newline));
            this.moar_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['moar_listy_entries -> listy_entries'];
        // moar_listy_entries -> listy_entries
        if (toker.sees(desires).notNil) {
            this.listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    deref_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['deref_prime -> MsgNameWithArgs listy_suffix'];
        // deref_prime -> MsgNameWithArgs listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_MsgNameWithArgs', toker.burn(Toke_MsgNameWithArgs));
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['deref_prime -> MsgName'];
        // deref_prime -> MsgName
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_MsgName', toker.burn(Toke_MsgName));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    al_x {
        | parent |

        var noad = SkoarNoad.new('al_x', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['al_x -> AlCoda'];
        // al_x -> AlCoda
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_AlCoda', toker.burn(Toke_AlCoda));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['al_x -> AlSegno'];
        // al_x -> AlSegno
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_AlSegno', toker.burn(Toke_AlSegno));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['al_x -> AlFine'];
        // al_x -> AlFine
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_AlFine', toker.burn(Toke_AlFine));
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    expr {
        | parent |

        var noad = SkoarNoad.new('expr', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['expr -> SymbolColon expr'];
        // expr -> SymbolColon expr
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_SymbolColon', toker.burn(Toke_SymbolColon));
            noad.add_noad(this.expr(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['expr -> msgable expr_prime'];
        // expr -> msgable expr_prime
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.msgable(noad));
            noad.add_noad(this.expr_prime(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    expr_prime {
        | parent |

        var noad = SkoarNoad.new('expr_prime', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['expr_prime -> assignment expr_prime'];
        // expr_prime -> assignment expr_prime
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.assignment(noad));
            noad.add_noad(this.expr_prime(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['expr_prime -> math expr_prime'];
        // expr_prime -> math expr_prime
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.math(noad));
            noad.add_noad(this.expr_prime(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['expr_prime -> boolean'];
        // expr_prime -> boolean
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.boolean(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['expr_prime -> times'];
        // expr_prime -> times
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.times(noad));
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    opt_voiced_phrases {
        | parent |

        var noad = SkoarNoad.new('opt_voiced_phrases', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['opt_voiced_phrases -> Voice phrases'];
        // opt_voiced_phrases -> Voice phrases
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Voice', toker.burn(Toke_Voice));
            this.phrases(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['opt_voiced_phrases -> phrases'];
        // opt_voiced_phrases -> phrases
        if (toker.sees(desires).notNil) {
            this.phrases(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skoar {
        | parent |

        var noad = SkoarNoad.new('skoar', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['skoar -> branches'];
        // skoar -> branches
        if (toker.sees(desires).notNil) {
            this.branches(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    meditation {
        | parent |

        var noad = SkoarNoad.new('meditation', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['meditation -> MeditationS skrp_lines MeditationE'];
        // meditation -> MeditationS skrp_lines MeditationE
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_MeditationS', toker.burn(Toke_MeditationS));
            this.skrp_lines(noad);
            runtime.add_toke(noad, 'Toke_MeditationE', toker.burn(Toke_MeditationE));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    loop_body {
        | parent |

        var noad = SkoarNoad.new('loop_body', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['loop_body -> phrases'];
        // loop_body -> phrases
        if (toker.sees(desires).notNil) {
            this.phrases(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    phrases {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['phrases -> phrasey phrases'];
        // phrases -> phrasey phrases
        if (toker.sees(desires).notNil) {
            this.phrasey(noad);
            this.phrases(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    ugen_simple {
        | parent |

        var noad = SkoarNoad.new('ugen_simple', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['ugen_simple -> AUGen'];
        // ugen_simple -> AUGen
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_AUGen', toker.burn(Toke_AUGen));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ugen_simple -> KUGen'];
        // ugen_simple -> KUGen
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_KUGen', toker.burn(Toke_KUGen));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ugen_simple -> DUGen'];
        // ugen_simple -> DUGen
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DUGen', toker.burn(Toke_DUGen));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_sig {
        | parent |

        var noad = SkoarNoad.new('skrp_sig', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['skrp_sig -> SymbolName skrp_sig_prime'];
        // skrp_sig -> SymbolName skrp_sig_prime
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_SymbolName', toker.burn(Toke_SymbolName));
            this.skrp_sig_prime(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['skrp_sig -> arg_listy SkoarpionSep'];
        // skrp_sig -> arg_listy SkoarpionSep
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.arg_listy(noad));
            runtime.add_toke(noad, 'Toke_SkoarpionSep', toker.burn(Toke_SkoarpionSep));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    boolean {
        | parent |

        var noad = SkoarNoad.new('boolean', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['boolean -> BooleanOp expr'];
        // boolean -> BooleanOp expr
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_BooleanOp', toker.burn(Toke_BooleanOp));
            noad.add_noad(this.expr(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    optional_voice {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['optional_voice -> Voice'];
        // optional_voice -> Voice
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Voice', toker.burn(Toke_Voice));
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    dynamic {
        | parent |

        var noad = SkoarNoad.new('dynamic', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['dynamic -> DynPiano'];
        // dynamic -> DynPiano
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DynPiano', toker.burn(Toke_DynPiano));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['dynamic -> DynForte'];
        // dynamic -> DynForte
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DynForte', toker.burn(Toke_DynForte));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['dynamic -> DynSFZ'];
        // dynamic -> DynSFZ
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DynSFZ', toker.burn(Toke_DynSFZ));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['dynamic -> DynFP'];
        // dynamic -> DynFP
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DynFP', toker.burn(Toke_DynFP));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    phrasey {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['phrasey -> Comment'];
        // phrasey -> Comment
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Comment', toker.burn(Toke_Comment));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['phrasey -> marker'];
        // phrasey -> marker
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.marker(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['phrasey -> expr'];
        // phrasey -> expr
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.expr(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['phrasey -> dal_goto'];
        // phrasey -> dal_goto
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.dal_goto(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['phrasey -> beat'];
        // phrasey -> beat
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.beat(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    if_body {
        | parent |

        var noad = SkoarNoad.new('if_body', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['if_body -> phrases'];
        // if_body -> phrases
        if (toker.sees(desires).notNil) {
            this.phrases(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    msg {
        | parent |

        var noad = SkoarNoad.new('msg', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['msg -> MsgNameWithArgs listy_suffix'];
        // msg -> MsgNameWithArgs listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_MsgNameWithArgs', toker.burn(Toke_MsgNameWithArgs));
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['msg -> MsgName'];
        // msg -> MsgName
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_MsgName', toker.burn(Toke_MsgName));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['msg -> listy'];
        // msg -> listy
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.listy(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['msg -> loop'];
        // msg -> loop
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.loop(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    cond_ifs_suffix {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['cond_ifs_suffix -> Newline cond_ifs'];
        // cond_ifs_suffix -> Newline cond_ifs
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Newline', toker.burn(Toke_Newline));
            this.cond_ifs(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    msgable {
        | parent |

        var noad = SkoarNoad.new('msgable', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['msgable -> nouny msg_chain_node'];
        // msgable -> nouny msg_chain_node
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.nouny(noad));
            this.msg_chain_node(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_sig_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['skrp_sig_prime -> SkoarpionSep'];
        // skrp_sig_prime -> SkoarpionSep
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_SkoarpionSep', toker.burn(Toke_SkoarpionSep));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['skrp_sig_prime -> arg_listy SkoarpionSep'];
        // skrp_sig_prime -> arg_listy SkoarpionSep
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.arg_listy(noad));
            runtime.add_toke(noad, 'Toke_SkoarpionSep', toker.burn(Toke_SkoarpionSep));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    arg_listy {
        | parent |

        var noad = SkoarNoad.new('arg_listy', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['arg_listy -> ListS arg_listy_suffix'];
        // arg_listy -> ListS arg_listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ListS', toker.burn(Toke_ListS));
            this.arg_listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    dal_goto {
        | parent |

        var noad = SkoarNoad.new('dal_goto', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['dal_goto -> DaCapo al_x'];
        // dal_goto -> DaCapo al_x
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DaCapo', toker.burn(Toke_DaCapo));
            noad.add_noad(this.al_x(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['dal_goto -> DalSegno al_x'];
        // dal_goto -> DalSegno al_x
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DalSegno', toker.burn(Toke_DalSegno));
            noad.add_noad(this.al_x(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    musical_keyword_misc {
        | parent |

        var noad = SkoarNoad.new('musical_keyword_misc', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['musical_keyword_misc -> Carrot'];
        // musical_keyword_misc -> Carrot
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Carrot', toker.burn(Toke_Carrot));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    ugen_with_args {
        | parent |

        var noad = SkoarNoad.new('ugen_with_args', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['ugen_with_args -> AUGenWithArgs listy_suffix'];
        // ugen_with_args -> AUGenWithArgs listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_AUGenWithArgs', toker.burn(Toke_AUGenWithArgs));
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ugen_with_args -> KUGenWithArgs listy_suffix'];
        // ugen_with_args -> KUGenWithArgs listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_KUGenWithArgs', toker.burn(Toke_KUGenWithArgs));
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ugen_with_args -> DUGenWithArgs listy_suffix'];
        // ugen_with_args -> DUGenWithArgs listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_DUGenWithArgs', toker.burn(Toke_DUGenWithArgs));
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_lines {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['skrp_lines -> opt_voiced_phrases skrp_moar_lines'];
        // skrp_lines -> opt_voiced_phrases skrp_moar_lines
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.opt_voiced_phrases(noad));
            this.skrp_moar_lines(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    exact_beat {
        | parent |

        var noad = SkoarNoad.new('exact_beat', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['exact_beat -> ExactBeat expr Quarters'];
        // exact_beat -> ExactBeat expr Quarters
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ExactBeat', toker.burn(Toke_ExactBeat));
            noad.add_noad(this.expr(noad));
            runtime.add_toke(noad, 'Toke_Quarters', toker.burn(Toke_Quarters));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    cthulhu {
        | parent |

        var noad = SkoarNoad.new('cthulhu', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['cthulhu -> LWing Semicolon cthulhu_prime'];
        // cthulhu -> LWing Semicolon cthulhu_prime
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_LWing', toker.burn(Toke_LWing));
            runtime.add_toke(noad, 'Toke_Semicolon', toker.burn(Toke_Semicolon));
            this.cthulhu_prime(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    cond_else {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['cond_else -> CondIf if_body'];
        // cond_else -> CondIf if_body
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_CondIf', toker.burn(Toke_CondIf));
            noad.add_noad(this.if_body(noad));
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    boolean_expr {
        | parent |

        var noad = SkoarNoad.new('boolean_expr', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['boolean_expr -> expr'];
        // boolean_expr -> expr
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.expr(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    coda {
        | parent |

        var noad = SkoarNoad.new('coda', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['coda -> Coda optional_al_coda'];
        // coda -> Coda optional_al_coda
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Coda', toker.burn(Toke_Coda));
            noad.add_noad(this.optional_al_coda(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    moar_arg_listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['moar_arg_listy_entries -> ListSep moar_arg_listy_entries'];
        // moar_arg_listy_entries -> ListSep moar_arg_listy_entries
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ListSep', toker.burn(Toke_ListSep));
            this.moar_arg_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['moar_arg_listy_entries -> Newline moar_arg_listy_entries'];
        // moar_arg_listy_entries -> Newline moar_arg_listy_entries
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Newline', toker.burn(Toke_Newline));
            this.moar_arg_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['moar_arg_listy_entries -> arg_listy_entries'];
        // moar_arg_listy_entries -> arg_listy_entries
        if (toker.sees(desires).notNil) {
            this.arg_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    regular_beat {
        | parent |

        var noad = SkoarNoad.new('regular_beat', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['regular_beat -> Crotchets'];
        // regular_beat -> Crotchets
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Crotchets', toker.burn(Toke_Crotchets));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['regular_beat -> Quavers'];
        // regular_beat -> Quavers
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Quavers', toker.burn(Toke_Quavers));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['regular_beat -> Quarters'];
        // regular_beat -> Quarters
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Quarters', toker.burn(Toke_Quarters));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['regular_beat -> Eighths'];
        // regular_beat -> Eighths
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Eighths', toker.burn(Toke_Eighths));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    marker {
        | parent |

        var noad = SkoarNoad.new('marker', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['marker -> Segno'];
        // marker -> Segno
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Segno', toker.burn(Toke_Segno));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['marker -> Fine'];
        // marker -> Fine
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Fine', toker.burn(Toke_Fine));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['marker -> coda'];
        // marker -> coda
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.coda(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['marker -> Bars'];
        // marker -> Bars
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Bars', toker.burn(Toke_Bars));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    listy_suffix {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['listy_suffix -> Newline listy_entries ListE'];
        // listy_suffix -> Newline listy_entries ListE
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Newline', toker.burn(Toke_Newline));
            this.listy_entries(noad);
            runtime.add_toke(noad, 'Toke_ListE', toker.burn(Toke_ListE));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['listy_suffix -> listy_entries ListE'];
        // listy_suffix -> listy_entries ListE
        if (toker.sees(desires).notNil) {
            this.listy_entries(noad);
            runtime.add_toke(noad, 'Toke_ListE', toker.burn(Toke_ListE));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['listy_suffix -> ListE'];
        // listy_suffix -> ListE
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ListE', toker.burn(Toke_ListE));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    arg_expr {
        | parent |

        var noad = SkoarNoad.new('arg_expr', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['arg_expr -> SymbolName'];
        // arg_expr -> SymbolName
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_SymbolName', toker.burn(Toke_SymbolName));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['arg_expr -> SymbolColon expr'];
        // arg_expr -> SymbolColon expr
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_SymbolColon', toker.burn(Toke_SymbolColon));
            noad.add_noad(this.expr(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    msg_chain_node {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['msg_chain_node -> MsgOp msg msg_chain_node'];
        // msg_chain_node -> MsgOp msg msg_chain_node
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_MsgOp', toker.burn(Toke_MsgOp));
            noad.add_noad(this.msg(noad));
            this.msg_chain_node(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    exact_rest {
        | parent |

        var noad = SkoarNoad.new('exact_rest', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['exact_rest -> ExactRest expr Crotchets'];
        // exact_rest -> ExactRest expr Crotchets
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ExactRest', toker.burn(Toke_ExactRest));
            noad.add_noad(this.expr(noad));
            runtime.add_toke(noad, 'Toke_Crotchets', toker.burn(Toke_Crotchets));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    math {
        | parent |

        var noad = SkoarNoad.new('math', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['math -> MathOp msgable'];
        // math -> MathOp msgable
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_MathOp', toker.burn(Toke_MathOp));
            noad.add_noad(this.msgable(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skrp_suffix {
        | parent |

        var noad = SkoarNoad.new('skrp_suffix', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['skrp_suffix -> skrp_lines SkoarpionEnd'];
        // skrp_suffix -> skrp_lines SkoarpionEnd
        if (toker.sees(desires).notNil) {
            this.skrp_lines(noad);
            runtime.add_toke(noad, 'Toke_SkoarpionEnd', toker.burn(Toke_SkoarpionEnd));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    assignment {
        | parent |

        var noad = SkoarNoad.new('assignment', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['assignment -> AssOp settable'];
        // assignment -> AssOp settable
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_AssOp', toker.burn(Toke_AssOp));
            this.settable(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['listy_entries -> expr moar_listy_entries'];
        // listy_entries -> expr moar_listy_entries
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.expr(noad));
            this.moar_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    cond_if {
        | parent |

        var noad = SkoarNoad.new('cond_if', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['cond_if -> optional_voice boolean_expr CondIf if_body cond_else'];
        // cond_if -> optional_voice boolean_expr CondIf if_body cond_else
        if (toker.sees(desires).notNil) {
            this.optional_voice(noad);
            noad.add_noad(this.boolean_expr(noad));
            runtime.add_toke(noad, 'Toke_CondIf', toker.burn(Toke_CondIf));
            noad.add_noad(this.if_body(noad));
            this.cond_else(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    ugen {
        | parent |

        var noad = SkoarNoad.new('ugen', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['ugen -> ugen_with_args'];
        // ugen -> ugen_with_args
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.ugen_with_args(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ugen -> ugen_simple'];
        // ugen -> ugen_simple
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.ugen_simple(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    arg_listy_entries {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['arg_listy_entries -> arg_expr moar_arg_listy_entries'];
        // arg_listy_entries -> arg_expr moar_arg_listy_entries
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.arg_expr(noad));
            this.moar_arg_listy_entries(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    deref {
        | parent |

        var noad = SkoarNoad.new('deref', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['deref -> Deref deref_prime'];
        // deref -> Deref deref_prime
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Deref', toker.burn(Toke_Deref));
            this.deref_prime(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    ottavas {
        | parent |

        var noad = SkoarNoad.new('ottavas', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['ottavas -> OctaveShift'];
        // ottavas -> OctaveShift
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_OctaveShift', toker.burn(Toke_OctaveShift));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ottavas -> OttavaA'];
        // ottavas -> OttavaA
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_OttavaA', toker.burn(Toke_OttavaA));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ottavas -> OttavaB'];
        // ottavas -> OttavaB
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_OttavaB', toker.burn(Toke_OttavaB));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ottavas -> QuindicesimaA'];
        // ottavas -> QuindicesimaA
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_QuindicesimaA', toker.burn(Toke_QuindicesimaA));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ottavas -> QuindicesimaB'];
        // ottavas -> QuindicesimaB
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_QuindicesimaB', toker.burn(Toke_QuindicesimaB));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['ottavas -> Loco'];
        // ottavas -> Loco
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Loco', toker.burn(Toke_Loco));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    cond_ifs {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['cond_ifs -> cond_if cond_ifs_suffix'];
        // cond_ifs -> cond_if cond_ifs_suffix
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.cond_if(noad));
            this.cond_ifs_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    musical_keyword {
        | parent |

        var noad = SkoarNoad.new('musical_keyword', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['musical_keyword -> dynamic'];
        // musical_keyword -> dynamic
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.dynamic(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['musical_keyword -> ottavas'];
        // musical_keyword -> ottavas
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.ottavas(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['musical_keyword -> musical_keyword_misc'];
        // musical_keyword -> musical_keyword_misc
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.musical_keyword_misc(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    listy {
        | parent |

        var noad = SkoarNoad.new('listy', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['listy -> ListS listy_suffix'];
        // listy -> ListS listy_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_ListS', toker.burn(Toke_ListS));
            this.listy_suffix(noad);
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    optional_al_coda {
        | parent |

        var noad = SkoarNoad.new('optional_al_coda', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['optional_al_coda -> AlCoda'];
        // optional_al_coda -> AlCoda
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_AlCoda', toker.burn(Toke_AlCoda));
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    cthulhu_prime {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['cthulhu_prime -> boolean_expr Semicolon RWing'];
        // cthulhu_prime -> boolean_expr Semicolon RWing
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.boolean_expr(noad));
            runtime.add_toke(noad, 'Toke_Semicolon', toker.burn(Toke_Semicolon));
            runtime.add_toke(noad, 'Toke_RWing', toker.burn(Toke_RWing));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['cthulhu_prime -> Nosey Semicolon RWing'];
        // cthulhu_prime -> Nosey Semicolon RWing
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Nosey', toker.burn(Toke_Nosey));
            runtime.add_toke(noad, 'Toke_Semicolon', toker.burn(Toke_Semicolon));
            runtime.add_toke(noad, 'Toke_RWing', toker.burn(Toke_RWing));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    loop_condition {
        | parent |

        var noad = SkoarNoad.new('loop_condition', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['loop_condition -> LoopSep boolean_expr'];
        // loop_condition -> LoopSep boolean_expr
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_LoopSep', toker.burn(Toke_LoopSep));
            noad.add_noad(this.boolean_expr(noad));
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    beat {
        | parent |

        var noad = SkoarNoad.new('beat', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['beat -> regular_beat'];
        // beat -> regular_beat
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.regular_beat(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['beat -> exact_beat'];
        // beat -> exact_beat
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.exact_beat(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['beat -> exact_rest'];
        // beat -> exact_rest
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.exact_rest(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    branch {
        | parent |

        var noad = SkoarNoad.new('branch', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['branch -> opt_voiced_phrases Newline'];
        // branch -> opt_voiced_phrases Newline
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.opt_voiced_phrases(noad));
            runtime.add_toke(noad, 'Toke_Newline', toker.burn(Toke_Newline));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    conditional {
        | parent |

        var noad = SkoarNoad.new('conditional', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['conditional -> CondS cond_ifs CondE'];
        // conditional -> CondS cond_ifs CondE
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_CondS', toker.burn(Toke_CondS));
            this.cond_ifs(noad);
            runtime.add_toke(noad, 'Toke_CondE', toker.burn(Toke_CondE));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    nouny_literal {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['nouny_literal -> Duration'];
        // nouny_literal -> Duration
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Duration', toker.burn(Toke_Duration));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> ugen'];
        // nouny_literal -> ugen
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.ugen(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Tuplet'];
        // nouny_literal -> Tuplet
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Tuplet', toker.burn(Toke_Tuplet));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Freq'];
        // nouny_literal -> Freq
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Freq', toker.burn(Toke_Freq));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Int'];
        // nouny_literal -> Int
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Int', toker.burn(Toke_Int));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Float'];
        // nouny_literal -> Float
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Float', toker.burn(Toke_Float));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> String'];
        // nouny_literal -> String
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_String', toker.burn(Toke_String));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Choard'];
        // nouny_literal -> Choard
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Choard', toker.burn(Toke_Choard));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> NamedNoat'];
        // nouny_literal -> NamedNoat
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_NamedNoat', toker.burn(Toke_NamedNoat));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Symbol'];
        // nouny_literal -> Symbol
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Symbol', toker.burn(Toke_Symbol));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Fairy'];
        // nouny_literal -> Fairy
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Fairy', toker.burn(Toke_Fairy));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> HashLevel'];
        // nouny_literal -> HashLevel
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_HashLevel', toker.burn(Toke_HashLevel));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> False'];
        // nouny_literal -> False
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_False', toker.burn(Toke_False));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> True'];
        // nouny_literal -> True
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_True', toker.burn(Toke_True));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> Cat'];
        // nouny_literal -> Cat
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Cat', toker.burn(Toke_Cat));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny_literal -> lute'];
        // nouny_literal -> lute
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.lute(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    skoarpion {
        | parent |

        var noad = SkoarNoad.new('skoarpion', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['skoarpion -> SkoarpionStartWithSig skrp_sig skrp_suffix'];
        // skoarpion -> SkoarpionStartWithSig skrp_sig skrp_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_SkoarpionStartWithSig', toker.burn(Toke_SkoarpionStartWithSig));
            noad.add_noad(this.skrp_sig(noad));
            noad.add_noad(this.skrp_suffix(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['skoarpion -> SkoarpionStart skrp_suffix'];
        // skoarpion -> SkoarpionStart skrp_suffix
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_SkoarpionStart', toker.burn(Toke_SkoarpionStart));
            noad.add_noad(this.skrp_suffix(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    loop {
        | parent |

        var noad = SkoarNoad.new('loop', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['loop -> LoopS loop_body loop_condition LoopE'];
        // loop -> LoopS loop_body loop_condition LoopE
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_LoopS', toker.burn(Toke_LoopS));
            noad.add_noad(this.loop_body(noad));
            noad.add_noad(this.loop_condition(noad));
            runtime.add_toke(noad, 'Toke_LoopE', toker.burn(Toke_LoopE));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    times {
        | parent |

        var noad = SkoarNoad.new('times', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['times -> Times'];
        // times -> Times
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Times', toker.burn(Toke_Times));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    nouny {
        | parent |

        var noad = SkoarNoad.new('nouny', parent);
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['nouny -> cthulhu'];
        // nouny -> cthulhu
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.cthulhu(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> meditation'];
        // nouny -> meditation
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.meditation(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> conditional'];
        // nouny -> conditional
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.conditional(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> loop'];
        // nouny -> loop
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.loop(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> nouny_literal'];
        // nouny -> nouny_literal
        if (toker.sees(desires).notNil) {
            this.nouny_literal(noad);
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> musical_keyword'];
        // nouny -> musical_keyword
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.musical_keyword(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> listy'];
        // nouny -> listy
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.listy(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> deref'];
        // nouny -> deref
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.deref(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['nouny -> skoarpion'];
        // nouny -> skoarpion
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.skoarpion(noad));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

    branches {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['branches -> branch branches'];
        // branches -> branch branches
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.branch(noad));
            this.branches(noad);
            deep = deep - 1;
            ^noad;
        };

        // <e>
        deep = deep - 1;
        ^noad;
    }

    settable {
        | parent |

        var noad = parent;
        var desires = nil;

        deep = deep + 1;
        if (deep > 1000) {
            this.fail_too_deep;
        };

        desires = SkoarParser.desirables['settable -> Symbol'];
        // settable -> Symbol
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Symbol', toker.burn(Toke_Symbol));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['settable -> listy'];
        // settable -> listy
        if (toker.sees(desires).notNil) {
            noad.add_noad(this.listy(noad));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['settable -> Quarters'];
        // settable -> Quarters
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Quarters', toker.burn(Toke_Quarters));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['settable -> Eighths'];
        // settable -> Eighths
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Eighths', toker.burn(Toke_Eighths));
            deep = deep - 1;
            ^noad;
        };

        desires = SkoarParser.desirables['settable -> Fairy'];
        // settable -> Fairy
        if (toker.sees(desires).notNil) {
            runtime.add_toke(noad, 'Toke_Fairy', toker.burn(Toke_Fairy));
            deep = deep - 1;
            ^noad;
        };

        // Error State
        this.fail;
    }

}

